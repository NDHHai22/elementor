(function(le) {
    typeof define == "function" && define.amd ? define(le) : le()
}
)(function() {
    "use strict";
    var Gx = Object.defineProperty;
    var Bx = (le, Ct, G) => Ct in le ? Gx(le, Ct, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: G
    }) : le[Ct] = G;
    var Ae = (le, Ct, G) => (Bx(le, typeof Ct != "symbol" ? Ct + "" : Ct, G),
    G);
    var le;
    (function(t) {
        t.assertEqual = n => n;
        function e(n) {}
        t.assertIs = e;
        function r(n) {
            throw new Error
        }
        t.assertNever = r,
        t.arrayToEnum = n => {
            const s = {};
            for (const i of n)
                s[i] = i;
            return s
        }
        ,
        t.getValidEnumValues = n => {
            const s = t.objectKeys(n).filter(l => typeof n[n[l]] != "number")
              , i = {};
            for (const l of s)
                i[l] = n[l];
            return t.objectValues(i)
        }
        ,
        t.objectValues = n => t.objectKeys(n).map(function(s) {
            return n[s]
        }),
        t.objectKeys = typeof Object.keys == "function" ? n => Object.keys(n) : n => {
            const s = [];
            for (const i in n)
                Object.prototype.hasOwnProperty.call(n, i) && s.push(i);
            return s
        }
        ,
        t.find = (n, s) => {
            for (const i of n)
                if (s(i))
                    return i
        }
        ,
        t.isInteger = typeof Number.isInteger == "function" ? n => Number.isInteger(n) : n => typeof n == "number" && isFinite(n) && Math.floor(n) === n;
        function o(n, s=" | ") {
            return n.map(i => typeof i == "string" ? `'${i}'` : i).join(s)
        }
        t.joinValues = o,
        t.jsonStringifyReplacer = (n, s) => typeof s == "bigint" ? s.toString() : s
    }
    )(le || (le = {}));
    var Ct;
    (function(t) {
        t.mergeShapes = (e, r) => ({
            ...e,
            ...r
        })
    }
    )(Ct || (Ct = {}));
    const G = le.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"])
      , Yt = t => {
        switch (typeof t) {
        case "undefined":
            return G.undefined;
        case "string":
            return G.string;
        case "number":
            return isNaN(t) ? G.nan : G.number;
        case "boolean":
            return G.boolean;
        case "function":
            return G.function;
        case "bigint":
            return G.bigint;
        case "symbol":
            return G.symbol;
        case "object":
            return Array.isArray(t) ? G.array : t === null ? G.null : t.then && typeof t.then == "function" && t.catch && typeof t.catch == "function" ? G.promise : typeof Map < "u" && t instanceof Map ? G.map : typeof Set < "u" && t instanceof Set ? G.set : typeof Date < "u" && t instanceof Date ? G.date : G.object;
        default:
            return G.unknown
        }
    }
      , M = le.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of", "not_finite"])
      , em = t => JSON.stringify(t, null, 2).replace(/"([^"]+)":/g, "$1:");
    let $t = class Vu extends Error {
        get errors() {
            return this.issues
        }
        constructor(e) {
            super(),
            this.issues = [],
            this.addIssue = o => {
                this.issues = [...this.issues, o]
            }
            ,
            this.addIssues = (o=[]) => {
                this.issues = [...this.issues, ...o]
            }
            ;
            const r = new.target.prototype;
            Object.setPrototypeOf ? Object.setPrototypeOf(this, r) : this.__proto__ = r,
            this.name = "ZodError",
            this.issues = e
        }
        format(e) {
            const r = e || function(s) {
                return s.message
            }
              , o = {
                _errors: []
            }
              , n = s => {
                for (const i of s.issues)
                    if (i.code === "invalid_union")
                        i.unionErrors.map(n);
                    else if (i.code === "invalid_return_type")
                        n(i.returnTypeError);
                    else if (i.code === "invalid_arguments")
                        n(i.argumentsError);
                    else if (i.path.length === 0)
                        o._errors.push(r(i));
                    else {
                        let l = o
                          , d = 0;
                        for (; d < i.path.length; ) {
                            const u = i.path[d];
                            d === i.path.length - 1 ? (l[u] = l[u] || {
                                _errors: []
                            },
                            l[u]._errors.push(r(i))) : l[u] = l[u] || {
                                _errors: []
                            },
                            l = l[u],
                            d++
                        }
                    }
            }
            ;
            return n(this),
            o
        }
        static assert(e) {
            if (!(e instanceof Vu))
                throw new Error(`Not a ZodError: ${e}`)
        }
        toString() {
            return this.message
        }
        get message() {
            return JSON.stringify(this.issues, le.jsonStringifyReplacer, 2)
        }
        get isEmpty() {
            return this.issues.length === 0
        }
        flatten(e=r => r.message) {
            const r = {}
              , o = [];
            for (const n of this.issues)
                n.path.length > 0 ? (r[n.path[0]] = r[n.path[0]] || [],
                r[n.path[0]].push(e(n))) : o.push(e(n));
            return {
                formErrors: o,
                fieldErrors: r
            }
        }
        get formErrors() {
            return this.flatten()
        }
    }
    ;
    $t.create = t => new $t(t);
    const jr = (t, e) => {
        let r;
        switch (t.code) {
        case M.invalid_type:
            t.received === G.undefined ? r = "Required" : r = `Expected ${t.expected}, received ${t.received}`;
            break;
        case M.invalid_literal:
            r = `Invalid literal value, expected ${JSON.stringify(t.expected, le.jsonStringifyReplacer)}`;
            break;
        case M.unrecognized_keys:
            r = `Unrecognized key(s) in object: ${le.joinValues(t.keys, ", ")}`;
            break;
        case M.invalid_union:
            r = "Invalid input";
            break;
        case M.invalid_union_discriminator:
            r = `Invalid discriminator value. Expected ${le.joinValues(t.options)}`;
            break;
        case M.invalid_enum_value:
            r = `Invalid enum value. Expected ${le.joinValues(t.options)}, received '${t.received}'`;
            break;
        case M.invalid_arguments:
            r = "Invalid function arguments";
            break;
        case M.invalid_return_type:
            r = "Invalid function return type";
            break;
        case M.invalid_date:
            r = "Invalid date";
            break;
        case M.invalid_string:
            typeof t.validation == "object" ? "includes"in t.validation ? (r = `Invalid input: must include "${t.validation.includes}"`,
            typeof t.validation.position == "number" && (r = `${r} at one or more positions greater than or equal to ${t.validation.position}`)) : "startsWith"in t.validation ? r = `Invalid input: must start with "${t.validation.startsWith}"` : "endsWith"in t.validation ? r = `Invalid input: must end with "${t.validation.endsWith}"` : le.assertNever(t.validation) : t.validation !== "regex" ? r = `Invalid ${t.validation}` : r = "Invalid";
            break;
        case M.too_small:
            t.type === "array" ? r = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "more than"} ${t.minimum} element(s)` : t.type === "string" ? r = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "over"} ${t.minimum} character(s)` : t.type === "number" ? r = `Number must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${t.minimum}` : t.type === "date" ? r = `Date must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(t.minimum))}` : r = "Invalid input";
            break;
        case M.too_big:
            t.type === "array" ? r = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "less than"} ${t.maximum} element(s)` : t.type === "string" ? r = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "under"} ${t.maximum} character(s)` : t.type === "number" ? r = `Number must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "bigint" ? r = `BigInt must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "date" ? r = `Date must be ${t.exact ? "exactly" : t.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(t.maximum))}` : r = "Invalid input";
            break;
        case M.custom:
            r = "Invalid input";
            break;
        case M.invalid_intersection_types:
            r = "Intersection results could not be merged";
            break;
        case M.not_multiple_of:
            r = `Number must be a multiple of ${t.multipleOf}`;
            break;
        case M.not_finite:
            r = "Number must be finite";
            break;
        default:
            r = e.defaultError,
            le.assertNever(t)
        }
        return {
            message: r
        }
    }
    ;
    let ki = jr;
    function tm(t) {
        ki = t
    }
    function to() {
        return ki
    }
    const ro = t => {
        const {data: e, path: r, errorMaps: o, issueData: n} = t
          , s = [...r, ...n.path || []]
          , i = {
            ...n,
            path: s
        };
        if (n.message !== void 0)
            return {
                ...n,
                path: s,
                message: n.message
            };
        let l = "";
        const d = o.filter(u => !!u).slice().reverse();
        for (const u of d)
            l = u(i, {
                data: e,
                defaultError: l
            }).message;
        return {
            ...n,
            path: s,
            message: l
        }
    }
      , rm = [];
    function B(t, e) {
        const r = to()
          , o = ro({
            issueData: e,
            data: t.data,
            path: t.path,
            errorMaps: [t.common.contextualErrorMap, t.schemaErrorMap, r, r === jr ? void 0 : jr].filter(n => !!n)
        });
        t.common.issues.push(o)
    }
    let pt = class Ju {
        constructor() {
            this.value = "valid"
        }
        dirty() {
            this.value === "valid" && (this.value = "dirty")
        }
        abort() {
            this.value !== "aborted" && (this.value = "aborted")
        }
        static mergeArray(e, r) {
            const o = [];
            for (const n of r) {
                if (n.status === "aborted")
                    return oe;
                n.status === "dirty" && e.dirty(),
                o.push(n.value)
            }
            return {
                status: e.value,
                value: o
            }
        }
        static async mergeObjectAsync(e, r) {
            const o = [];
            for (const n of r) {
                const s = await n.key
                  , i = await n.value;
                o.push({
                    key: s,
                    value: i
                })
            }
            return Ju.mergeObjectSync(e, o)
        }
        static mergeObjectSync(e, r) {
            const o = {};
            for (const n of r) {
                const {key: s, value: i} = n;
                if (s.status === "aborted" || i.status === "aborted")
                    return oe;
                s.status === "dirty" && e.dirty(),
                i.status === "dirty" && e.dirty(),
                s.value !== "__proto__" && (typeof i.value < "u" || n.alwaysSet) && (o[s.value] = i.value)
            }
            return {
                status: e.value,
                value: o
            }
        }
    }
    ;
    const oe = Object.freeze({
        status: "aborted"
    })
      , Mr = t => ({
        status: "dirty",
        value: t
    })
      , at = t => ({
        status: "valid",
        value: t
    })
      , Is = t => t.status === "aborted"
      , Cs = t => t.status === "dirty"
      , xr = t => t.status === "valid"
      , dn = t => typeof Promise < "u" && t instanceof Promise;
    function no(t, e, r, o) {
        if (r === "a" && !o)
            throw new TypeError("Private accessor was defined without a getter");
        if (typeof e == "function" ? t !== e || !o : !e.has(t))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return r === "m" ? o : r === "a" ? o.call(t) : o ? o.value : e.get(t)
    }
    function Ii(t, e, r, o, n) {
        if (o === "m")
            throw new TypeError("Private method is not writable");
        if (o === "a" && !n)
            throw new TypeError("Private accessor was defined without a setter");
        if (typeof e == "function" ? t !== e || !n : !e.has(t))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return o === "a" ? n.call(t, r) : n ? n.value = r : e.set(t, r),
        r
    }
    typeof SuppressedError == "function" && SuppressedError;
    var J;
    (function(t) {
        t.errToObj = e => typeof e == "string" ? {
            message: e
        } : e || {},
        t.toString = e => typeof e == "string" ? e : e == null ? void 0 : e.message
    }
    )(J || (J = {}));
    var un, mn;
    let Mt = class {
        constructor(e, r, o, n) {
            this._cachedPath = [],
            this.parent = e,
            this.data = r,
            this._path = o,
            this._key = n
        }
        get path() {
            return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)),
            this._cachedPath
        }
    }
    ;
    const Ci = (t, e) => {
        if (xr(e))
            return {
                success: !0,
                data: e.value
            };
        if (!t.common.issues.length)
            throw new Error("Validation failed but no issues detected.");
        return {
            success: !1,
            get error() {
                if (this._error)
                    return this._error;
                const r = new $t(t.common.issues);
                return this._error = r,
                this._error
            }
        }
    }
    ;
    function ce(t) {
        if (!t)
            return {};
        const {errorMap: e, invalid_type_error: r, required_error: o, description: n} = t;
        if (e && (r || o))
            throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
        return e ? {
            errorMap: e,
            description: n
        } : {
            errorMap: (i, l) => {
                var d, u;
                const {message: g} = t;
                return i.code === "invalid_enum_value" ? {
                    message: g ?? l.defaultError
                } : typeof l.data > "u" ? {
                    message: (d = g ?? o) !== null && d !== void 0 ? d : l.defaultError
                } : i.code !== "invalid_type" ? {
                    message: l.defaultError
                } : {
                    message: (u = g ?? r) !== null && u !== void 0 ? u : l.defaultError
                }
            }
            ,
            description: n
        }
    }
    let ue = class {
        get description() {
            return this._def.description
        }
        _getType(e) {
            return Yt(e.data)
        }
        _getOrReturnCtx(e, r) {
            return r || {
                common: e.parent.common,
                data: e.data,
                parsedType: Yt(e.data),
                schemaErrorMap: this._def.errorMap,
                path: e.path,
                parent: e.parent
            }
        }
        _processInputParams(e) {
            return {
                status: new pt,
                ctx: {
                    common: e.parent.common,
                    data: e.data,
                    parsedType: Yt(e.data),
                    schemaErrorMap: this._def.errorMap,
                    path: e.path,
                    parent: e.parent
                }
            }
        }
        _parseSync(e) {
            const r = this._parse(e);
            if (dn(r))
                throw new Error("Synchronous parse encountered promise.");
            return r
        }
        _parseAsync(e) {
            const r = this._parse(e);
            return Promise.resolve(r)
        }
        parse(e, r) {
            const o = this.safeParse(e, r);
            if (o.success)
                return o.data;
            throw o.error
        }
        safeParse(e, r) {
            var o;
            const n = {
                common: {
                    issues: [],
                    async: (o = r == null ? void 0 : r.async) !== null && o !== void 0 ? o : !1,
                    contextualErrorMap: r == null ? void 0 : r.errorMap
                },
                path: (r == null ? void 0 : r.path) || [],
                schemaErrorMap: this._def.errorMap,
                parent: null,
                data: e,
                parsedType: Yt(e)
            }
              , s = this._parseSync({
                data: e,
                path: n.path,
                parent: n
            });
            return Ci(n, s)
        }
        "~validate"(e) {
            var r, o;
            const n = {
                common: {
                    issues: [],
                    async: !!this["~standard"].async
                },
                path: [],
                schemaErrorMap: this._def.errorMap,
                parent: null,
                data: e,
                parsedType: Yt(e)
            };
            if (!this["~standard"].async)
                try {
                    const s = this._parseSync({
                        data: e,
                        path: [],
                        parent: n
                    });
                    return xr(s) ? {
                        value: s.value
                    } : {
                        issues: n.common.issues
                    }
                } catch (s) {
                    !((o = (r = s == null ? void 0 : s.message) === null || r === void 0 ? void 0 : r.toLowerCase()) === null || o === void 0) && o.includes("encountered") && (this["~standard"].async = !0),
                    n.common = {
                        issues: [],
                        async: !0
                    }
                }
            return this._parseAsync({
                data: e,
                path: [],
                parent: n
            }).then(s => xr(s) ? {
                value: s.value
            } : {
                issues: n.common.issues
            })
        }
        async parseAsync(e, r) {
            const o = await this.safeParseAsync(e, r);
            if (o.success)
                return o.data;
            throw o.error
        }
        async safeParseAsync(e, r) {
            const o = {
                common: {
                    issues: [],
                    contextualErrorMap: r == null ? void 0 : r.errorMap,
                    async: !0
                },
                path: (r == null ? void 0 : r.path) || [],
                schemaErrorMap: this._def.errorMap,
                parent: null,
                data: e,
                parsedType: Yt(e)
            }
              , n = this._parse({
                data: e,
                path: o.path,
                parent: o
            })
              , s = await (dn(n) ? n : Promise.resolve(n));
            return Ci(o, s)
        }
        refine(e, r) {
            const o = n => typeof r == "string" || typeof r > "u" ? {
                message: r
            } : typeof r == "function" ? r(n) : r;
            return this._refinement( (n, s) => {
                const i = e(n)
                  , l = () => s.addIssue({
                    code: M.custom,
                    ...o(n)
                });
                return typeof Promise < "u" && i instanceof Promise ? i.then(d => d ? !0 : (l(),
                !1)) : i ? !0 : (l(),
                !1)
            }
            )
        }
        refinement(e, r) {
            return this._refinement( (o, n) => e(o) ? !0 : (n.addIssue(typeof r == "function" ? r(o, n) : r),
            !1))
        }
        _refinement(e) {
            return new At({
                schema: this,
                typeName: F.ZodEffects,
                effect: {
                    type: "refinement",
                    refinement: e
                }
            })
        }
        superRefine(e) {
            return this._refinement(e)
        }
        constructor(e) {
            this.spa = this.safeParseAsync,
            this._def = e,
            this.parse = this.parse.bind(this),
            this.safeParse = this.safeParse.bind(this),
            this.parseAsync = this.parseAsync.bind(this),
            this.safeParseAsync = this.safeParseAsync.bind(this),
            this.spa = this.spa.bind(this),
            this.refine = this.refine.bind(this),
            this.refinement = this.refinement.bind(this),
            this.superRefine = this.superRefine.bind(this),
            this.optional = this.optional.bind(this),
            this.nullable = this.nullable.bind(this),
            this.nullish = this.nullish.bind(this),
            this.array = this.array.bind(this),
            this.promise = this.promise.bind(this),
            this.or = this.or.bind(this),
            this.and = this.and.bind(this),
            this.transform = this.transform.bind(this),
            this.brand = this.brand.bind(this),
            this.default = this.default.bind(this),
            this.catch = this.catch.bind(this),
            this.describe = this.describe.bind(this),
            this.pipe = this.pipe.bind(this),
            this.readonly = this.readonly.bind(this),
            this.isNullable = this.isNullable.bind(this),
            this.isOptional = this.isOptional.bind(this),
            this["~standard"] = {
                version: 1,
                vendor: "zod",
                validate: r => this["~validate"](r)
            }
        }
        optional() {
            return Rt.create(this, this._def)
        }
        nullable() {
            return ur.create(this, this._def)
        }
        nullish() {
            return this.nullable().optional()
        }
        array() {
            return Tr.create(this)
        }
        promise() {
            return Br.create(this, this._def)
        }
        or(e) {
            return wn.create([this, e], this._def)
        }
        and(e) {
            return bn.create(this, e, this._def)
        }
        transform(e) {
            return new At({
                ...ce(this._def),
                schema: this,
                typeName: F.ZodEffects,
                effect: {
                    type: "transform",
                    transform: e
                }
            })
        }
        default(e) {
            const r = typeof e == "function" ? e : () => e;
            return new Tn({
                ...ce(this._def),
                innerType: this,
                defaultValue: r,
                typeName: F.ZodDefault
            })
        }
        brand() {
            return new Rs({
                typeName: F.ZodBranded,
                type: this,
                ...ce(this._def)
            })
        }
        catch(e) {
            const r = typeof e == "function" ? e : () => e;
            return new Pn({
                ...ce(this._def),
                innerType: this,
                catchValue: r,
                typeName: F.ZodCatch
            })
        }
        describe(e) {
            const r = this.constructor;
            return new r({
                ...this._def,
                description: e
            })
        }
        pipe(e) {
            return Os.create(this, e)
        }
        readonly() {
            return kn.create(this)
        }
        isOptional() {
            return this.safeParse(void 0).success
        }
        isNullable() {
            return this.safeParse(null).success
        }
    }
    ;
    const nm = /^c[^\s-]{8,}$/i
      , om = /^[0-9a-z]+$/
      , sm = /^[0-9A-HJKMNP-TV-Z]{26}$/i
      , am = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i
      , im = /^[a-z0-9_-]{21}$/i
      , lm = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
      , cm = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/
      , dm = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i
      , um = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
    let $s;
    const mm = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/
      , pm = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/
      , hm = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/
      , gm = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/
      , fm = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/
      , ym = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/
      , $i = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))"
      , vm = new RegExp(`^${$i}$`);
    function Ai(t) {
        let e = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
        return t.precision ? e = `${e}\\.\\d{${t.precision}}` : t.precision == null && (e = `${e}(\\.\\d+)?`),
        e
    }
    function wm(t) {
        return new RegExp(`^${Ai(t)}$`)
    }
    function Ri(t) {
        let e = `${$i}T${Ai(t)}`;
        const r = [];
        return r.push(t.local ? "Z?" : "Z"),
        t.offset && r.push("([+-]\\d{2}:?\\d{2})"),
        e = `${e}(${r.join("|")})`,
        new RegExp(`^${e}$`)
    }
    function bm(t, e) {
        return !!((e === "v4" || !e) && mm.test(t) || (e === "v6" || !e) && hm.test(t))
    }
    function Sm(t, e) {
        if (!lm.test(t))
            return !1;
        try {
            const [r] = t.split(".")
              , o = r.replace(/-/g, "+").replace(/_/g, "/").padEnd(r.length + (4 - r.length % 4) % 4, "=")
              , n = JSON.parse(atob(o));
            return !(typeof n != "object" || n === null || !n.typ || !n.alg || e && n.alg !== e)
        } catch {
            return !1
        }
    }
    function Em(t, e) {
        return !!((e === "v4" || !e) && pm.test(t) || (e === "v6" || !e) && gm.test(t))
    }
    let Fr = class eo extends ue {
        _parse(e) {
            if (this._def.coerce && (e.data = String(e.data)),
            this._getType(e) !== G.string) {
                const s = this._getOrReturnCtx(e);
                return B(s, {
                    code: M.invalid_type,
                    expected: G.string,
                    received: s.parsedType
                }),
                oe
            }
            const o = new pt;
            let n;
            for (const s of this._def.checks)
                if (s.kind === "min")
                    e.data.length < s.value && (n = this._getOrReturnCtx(e, n),
                    B(n, {
                        code: M.too_small,
                        minimum: s.value,
                        type: "string",
                        inclusive: !0,
                        exact: !1,
                        message: s.message
                    }),
                    o.dirty());
                else if (s.kind === "max")
                    e.data.length > s.value && (n = this._getOrReturnCtx(e, n),
                    B(n, {
                        code: M.too_big,
                        maximum: s.value,
                        type: "string",
                        inclusive: !0,
                        exact: !1,
                        message: s.message
                    }),
                    o.dirty());
                else if (s.kind === "length") {
                    const i = e.data.length > s.value
                      , l = e.data.length < s.value;
                    (i || l) && (n = this._getOrReturnCtx(e, n),
                    i ? B(n, {
                        code: M.too_big,
                        maximum: s.value,
                        type: "string",
                        inclusive: !0,
                        exact: !0,
                        message: s.message
                    }) : l && B(n, {
                        code: M.too_small,
                        minimum: s.value,
                        type: "string",
                        inclusive: !0,
                        exact: !0,
                        message: s.message
                    }),
                    o.dirty())
                } else if (s.kind === "email")
                    dm.test(e.data) || (n = this._getOrReturnCtx(e, n),
                    B(n, {
                        validation: "email",
                        code: M.invalid_string,
                        message: s.message
                    }),
                    o.dirty());
                else if (s.kind === "emoji")
                    $s || ($s = new RegExp(um,"u")),
                    $s.test(e.data) || (n = this._getOrReturnCtx(e, n),
                    B(n, {
                        validation: "emoji",
                        code: M.invalid_string,
                        message: s.message
                    }),
                    o.dirty());
                else if (s.kind === "uuid")
                    am.test(e.data) || (n = this._getOrReturnCtx(e, n),
                    B(n, {
                        validation: "uuid",
                        code: M.invalid_string,
                        message: s.message
                    }),
                    o.dirty());
                else if (s.kind === "nanoid")
                    im.test(e.data) || (n = this._getOrReturnCtx(e, n),
                    B(n, {
                        validation: "nanoid",
                        code: M.invalid_string,
                        message: s.message
                    }),
                    o.dirty());
                else if (s.kind === "cuid")
                    nm.test(e.data) || (n = this._getOrReturnCtx(e, n),
                    B(n, {
                        validation: "cuid",
                        code: M.invalid_string,
                        message: s.message
                    }),
                    o.dirty());
                else if (s.kind === "cuid2")
                    om.test(e.data) || (n = this._getOrReturnCtx(e, n),
                    B(n, {
                        validation: "cuid2",
                        code: M.invalid_string,
                        message: s.message
                    }),
                    o.dirty());
                else if (s.kind === "ulid")
                    sm.test(e.data) || (n = this._getOrReturnCtx(e, n),
                    B(n, {
                        validation: "ulid",
                        code: M.invalid_string,
                        message: s.message
                    }),
                    o.dirty());
                else if (s.kind === "url")
                    try {
                        new URL(e.data)
                    } catch {
                        n = this._getOrReturnCtx(e, n),
                        B(n, {
                            validation: "url",
                            code: M.invalid_string,
                            message: s.message
                        }),
                        o.dirty()
                    }
                else
                    s.kind === "regex" ? (s.regex.lastIndex = 0,
                    s.regex.test(e.data) || (n = this._getOrReturnCtx(e, n),
                    B(n, {
                        validation: "regex",
                        code: M.invalid_string,
                        message: s.message
                    }),
                    o.dirty())) : s.kind === "trim" ? e.data = e.data.trim() : s.kind === "includes" ? e.data.includes(s.value, s.position) || (n = this._getOrReturnCtx(e, n),
                    B(n, {
                        code: M.invalid_string,
                        validation: {
                            includes: s.value,
                            position: s.position
                        },
                        message: s.message
                    }),
                    o.dirty()) : s.kind === "toLowerCase" ? e.data = e.data.toLowerCase() : s.kind === "toUpperCase" ? e.data = e.data.toUpperCase() : s.kind === "startsWith" ? e.data.startsWith(s.value) || (n = this._getOrReturnCtx(e, n),
                    B(n, {
                        code: M.invalid_string,
                        validation: {
                            startsWith: s.value
                        },
                        message: s.message
                    }),
                    o.dirty()) : s.kind === "endsWith" ? e.data.endsWith(s.value) || (n = this._getOrReturnCtx(e, n),
                    B(n, {
                        code: M.invalid_string,
                        validation: {
                            endsWith: s.value
                        },
                        message: s.message
                    }),
                    o.dirty()) : s.kind === "datetime" ? Ri(s).test(e.data) || (n = this._getOrReturnCtx(e, n),
                    B(n, {
                        code: M.invalid_string,
                        validation: "datetime",
                        message: s.message
                    }),
                    o.dirty()) : s.kind === "date" ? vm.test(e.data) || (n = this._getOrReturnCtx(e, n),
                    B(n, {
                        code: M.invalid_string,
                        validation: "date",
                        message: s.message
                    }),
                    o.dirty()) : s.kind === "time" ? wm(s).test(e.data) || (n = this._getOrReturnCtx(e, n),
                    B(n, {
                        code: M.invalid_string,
                        validation: "time",
                        message: s.message
                    }),
                    o.dirty()) : s.kind === "duration" ? cm.test(e.data) || (n = this._getOrReturnCtx(e, n),
                    B(n, {
                        validation: "duration",
                        code: M.invalid_string,
                        message: s.message
                    }),
                    o.dirty()) : s.kind === "ip" ? bm(e.data, s.version) || (n = this._getOrReturnCtx(e, n),
                    B(n, {
                        validation: "ip",
                        code: M.invalid_string,
                        message: s.message
                    }),
                    o.dirty()) : s.kind === "jwt" ? Sm(e.data, s.alg) || (n = this._getOrReturnCtx(e, n),
                    B(n, {
                        validation: "jwt",
                        code: M.invalid_string,
                        message: s.message
                    }),
                    o.dirty()) : s.kind === "cidr" ? Em(e.data, s.version) || (n = this._getOrReturnCtx(e, n),
                    B(n, {
                        validation: "cidr",
                        code: M.invalid_string,
                        message: s.message
                    }),
                    o.dirty()) : s.kind === "base64" ? fm.test(e.data) || (n = this._getOrReturnCtx(e, n),
                    B(n, {
                        validation: "base64",
                        code: M.invalid_string,
                        message: s.message
                    }),
                    o.dirty()) : s.kind === "base64url" ? ym.test(e.data) || (n = this._getOrReturnCtx(e, n),
                    B(n, {
                        validation: "base64url",
                        code: M.invalid_string,
                        message: s.message
                    }),
                    o.dirty()) : le.assertNever(s);
            return {
                status: o.value,
                value: e.data
            }
        }
        _regex(e, r, o) {
            return this.refinement(n => e.test(n), {
                validation: r,
                code: M.invalid_string,
                ...J.errToObj(o)
            })
        }
        _addCheck(e) {
            return new eo({
                ...this._def,
                checks: [...this._def.checks, e]
            })
        }
        email(e) {
            return this._addCheck({
                kind: "email",
                ...J.errToObj(e)
            })
        }
        url(e) {
            return this._addCheck({
                kind: "url",
                ...J.errToObj(e)
            })
        }
        emoji(e) {
            return this._addCheck({
                kind: "emoji",
                ...J.errToObj(e)
            })
        }
        uuid(e) {
            return this._addCheck({
                kind: "uuid",
                ...J.errToObj(e)
            })
        }
        nanoid(e) {
            return this._addCheck({
                kind: "nanoid",
                ...J.errToObj(e)
            })
        }
        cuid(e) {
            return this._addCheck({
                kind: "cuid",
                ...J.errToObj(e)
            })
        }
        cuid2(e) {
            return this._addCheck({
                kind: "cuid2",
                ...J.errToObj(e)
            })
        }
        ulid(e) {
            return this._addCheck({
                kind: "ulid",
                ...J.errToObj(e)
            })
        }
        base64(e) {
            return this._addCheck({
                kind: "base64",
                ...J.errToObj(e)
            })
        }
        base64url(e) {
            return this._addCheck({
                kind: "base64url",
                ...J.errToObj(e)
            })
        }
        jwt(e) {
            return this._addCheck({
                kind: "jwt",
                ...J.errToObj(e)
            })
        }
        ip(e) {
            return this._addCheck({
                kind: "ip",
                ...J.errToObj(e)
            })
        }
        cidr(e) {
            return this._addCheck({
                kind: "cidr",
                ...J.errToObj(e)
            })
        }
        datetime(e) {
            var r, o;
            return typeof e == "string" ? this._addCheck({
                kind: "datetime",
                precision: null,
                offset: !1,
                local: !1,
                message: e
            }) : this._addCheck({
                kind: "datetime",
                precision: typeof (e == null ? void 0 : e.precision) > "u" ? null : e == null ? void 0 : e.precision,
                offset: (r = e == null ? void 0 : e.offset) !== null && r !== void 0 ? r : !1,
                local: (o = e == null ? void 0 : e.local) !== null && o !== void 0 ? o : !1,
                ...J.errToObj(e == null ? void 0 : e.message)
            })
        }
        date(e) {
            return this._addCheck({
                kind: "date",
                message: e
            })
        }
        time(e) {
            return typeof e == "string" ? this._addCheck({
                kind: "time",
                precision: null,
                message: e
            }) : this._addCheck({
                kind: "time",
                precision: typeof (e == null ? void 0 : e.precision) > "u" ? null : e == null ? void 0 : e.precision,
                ...J.errToObj(e == null ? void 0 : e.message)
            })
        }
        duration(e) {
            return this._addCheck({
                kind: "duration",
                ...J.errToObj(e)
            })
        }
        regex(e, r) {
            return this._addCheck({
                kind: "regex",
                regex: e,
                ...J.errToObj(r)
            })
        }
        includes(e, r) {
            return this._addCheck({
                kind: "includes",
                value: e,
                position: r == null ? void 0 : r.position,
                ...J.errToObj(r == null ? void 0 : r.message)
            })
        }
        startsWith(e, r) {
            return this._addCheck({
                kind: "startsWith",
                value: e,
                ...J.errToObj(r)
            })
        }
        endsWith(e, r) {
            return this._addCheck({
                kind: "endsWith",
                value: e,
                ...J.errToObj(r)
            })
        }
        min(e, r) {
            return this._addCheck({
                kind: "min",
                value: e,
                ...J.errToObj(r)
            })
        }
        max(e, r) {
            return this._addCheck({
                kind: "max",
                value: e,
                ...J.errToObj(r)
            })
        }
        length(e, r) {
            return this._addCheck({
                kind: "length",
                value: e,
                ...J.errToObj(r)
            })
        }
        nonempty(e) {
            return this.min(1, J.errToObj(e))
        }
        trim() {
            return new eo({
                ...this._def,
                checks: [...this._def.checks, {
                    kind: "trim"
                }]
            })
        }
        toLowerCase() {
            return new eo({
                ...this._def,
                checks: [...this._def.checks, {
                    kind: "toLowerCase"
                }]
            })
        }
        toUpperCase() {
            return new eo({
                ...this._def,
                checks: [...this._def.checks, {
                    kind: "toUpperCase"
                }]
            })
        }
        get isDatetime() {
            return !!this._def.checks.find(e => e.kind === "datetime")
        }
        get isDate() {
            return !!this._def.checks.find(e => e.kind === "date")
        }
        get isTime() {
            return !!this._def.checks.find(e => e.kind === "time")
        }
        get isDuration() {
            return !!this._def.checks.find(e => e.kind === "duration")
        }
        get isEmail() {
            return !!this._def.checks.find(e => e.kind === "email")
        }
        get isURL() {
            return !!this._def.checks.find(e => e.kind === "url")
        }
        get isEmoji() {
            return !!this._def.checks.find(e => e.kind === "emoji")
        }
        get isUUID() {
            return !!this._def.checks.find(e => e.kind === "uuid")
        }
        get isNANOID() {
            return !!this._def.checks.find(e => e.kind === "nanoid")
        }
        get isCUID() {
            return !!this._def.checks.find(e => e.kind === "cuid")
        }
        get isCUID2() {
            return !!this._def.checks.find(e => e.kind === "cuid2")
        }
        get isULID() {
            return !!this._def.checks.find(e => e.kind === "ulid")
        }
        get isIP() {
            return !!this._def.checks.find(e => e.kind === "ip")
        }
        get isCIDR() {
            return !!this._def.checks.find(e => e.kind === "cidr")
        }
        get isBase64() {
            return !!this._def.checks.find(e => e.kind === "base64")
        }
        get isBase64url() {
            return !!this._def.checks.find(e => e.kind === "base64url")
        }
        get minLength() {
            let e = null;
            for (const r of this._def.checks)
                r.kind === "min" && (e === null || r.value > e) && (e = r.value);
            return e
        }
        get maxLength() {
            let e = null;
            for (const r of this._def.checks)
                r.kind === "max" && (e === null || r.value < e) && (e = r.value);
            return e
        }
    }
    ;
    Fr.create = t => {
        var e;
        return new Fr({
            checks: [],
            typeName: F.ZodString,
            coerce: (e = t == null ? void 0 : t.coerce) !== null && e !== void 0 ? e : !1,
            ...ce(t)
        })
    }
    ;
    function xm(t, e) {
        const r = (t.toString().split(".")[1] || "").length
          , o = (e.toString().split(".")[1] || "").length
          , n = r > o ? r : o
          , s = parseInt(t.toFixed(n).replace(".", ""))
          , i = parseInt(e.toFixed(n).replace(".", ""));
        return s % i / Math.pow(10, n)
    }
    let pn = class Ei extends ue {
        constructor() {
            super(...arguments),
            this.min = this.gte,
            this.max = this.lte,
            this.step = this.multipleOf
        }
        _parse(e) {
            if (this._def.coerce && (e.data = Number(e.data)),
            this._getType(e) !== G.number) {
                const s = this._getOrReturnCtx(e);
                return B(s, {
                    code: M.invalid_type,
                    expected: G.number,
                    received: s.parsedType
                }),
                oe
            }
            let o;
            const n = new pt;
            for (const s of this._def.checks)
                s.kind === "int" ? le.isInteger(e.data) || (o = this._getOrReturnCtx(e, o),
                B(o, {
                    code: M.invalid_type,
                    expected: "integer",
                    received: "float",
                    message: s.message
                }),
                n.dirty()) : s.kind === "min" ? (s.inclusive ? e.data < s.value : e.data <= s.value) && (o = this._getOrReturnCtx(e, o),
                B(o, {
                    code: M.too_small,
                    minimum: s.value,
                    type: "number",
                    inclusive: s.inclusive,
                    exact: !1,
                    message: s.message
                }),
                n.dirty()) : s.kind === "max" ? (s.inclusive ? e.data > s.value : e.data >= s.value) && (o = this._getOrReturnCtx(e, o),
                B(o, {
                    code: M.too_big,
                    maximum: s.value,
                    type: "number",
                    inclusive: s.inclusive,
                    exact: !1,
                    message: s.message
                }),
                n.dirty()) : s.kind === "multipleOf" ? xm(e.data, s.value) !== 0 && (o = this._getOrReturnCtx(e, o),
                B(o, {
                    code: M.not_multiple_of,
                    multipleOf: s.value,
                    message: s.message
                }),
                n.dirty()) : s.kind === "finite" ? Number.isFinite(e.data) || (o = this._getOrReturnCtx(e, o),
                B(o, {
                    code: M.not_finite,
                    message: s.message
                }),
                n.dirty()) : le.assertNever(s);
            return {
                status: n.value,
                value: e.data
            }
        }
        gte(e, r) {
            return this.setLimit("min", e, !0, J.toString(r))
        }
        gt(e, r) {
            return this.setLimit("min", e, !1, J.toString(r))
        }
        lte(e, r) {
            return this.setLimit("max", e, !0, J.toString(r))
        }
        lt(e, r) {
            return this.setLimit("max", e, !1, J.toString(r))
        }
        setLimit(e, r, o, n) {
            return new Ei({
                ...this._def,
                checks: [...this._def.checks, {
                    kind: e,
                    value: r,
                    inclusive: o,
                    message: J.toString(n)
                }]
            })
        }
        _addCheck(e) {
            return new Ei({
                ...this._def,
                checks: [...this._def.checks, e]
            })
        }
        int(e) {
            return this._addCheck({
                kind: "int",
                message: J.toString(e)
            })
        }
        positive(e) {
            return this._addCheck({
                kind: "min",
                value: 0,
                inclusive: !1,
                message: J.toString(e)
            })
        }
        negative(e) {
            return this._addCheck({
                kind: "max",
                value: 0,
                inclusive: !1,
                message: J.toString(e)
            })
        }
        nonpositive(e) {
            return this._addCheck({
                kind: "max",
                value: 0,
                inclusive: !0,
                message: J.toString(e)
            })
        }
        nonnegative(e) {
            return this._addCheck({
                kind: "min",
                value: 0,
                inclusive: !0,
                message: J.toString(e)
            })
        }
        multipleOf(e, r) {
            return this._addCheck({
                kind: "multipleOf",
                value: e,
                message: J.toString(r)
            })
        }
        finite(e) {
            return this._addCheck({
                kind: "finite",
                message: J.toString(e)
            })
        }
        safe(e) {
            return this._addCheck({
                kind: "min",
                inclusive: !0,
                value: Number.MIN_SAFE_INTEGER,
                message: J.toString(e)
            })._addCheck({
                kind: "max",
                inclusive: !0,
                value: Number.MAX_SAFE_INTEGER,
                message: J.toString(e)
            })
        }
        get minValue() {
            let e = null;
            for (const r of this._def.checks)
                r.kind === "min" && (e === null || r.value > e) && (e = r.value);
            return e
        }
        get maxValue() {
            let e = null;
            for (const r of this._def.checks)
                r.kind === "max" && (e === null || r.value < e) && (e = r.value);
            return e
        }
        get isInt() {
            return !!this._def.checks.find(e => e.kind === "int" || e.kind === "multipleOf" && le.isInteger(e.value))
        }
        get isFinite() {
            let e = null
              , r = null;
            for (const o of this._def.checks) {
                if (o.kind === "finite" || o.kind === "int" || o.kind === "multipleOf")
                    return !0;
                o.kind === "min" ? (r === null || o.value > r) && (r = o.value) : o.kind === "max" && (e === null || o.value < e) && (e = o.value)
            }
            return Number.isFinite(r) && Number.isFinite(e)
        }
    }
    ;
    pn.create = t => new pn({
        checks: [],
        typeName: F.ZodNumber,
        coerce: (t == null ? void 0 : t.coerce) || !1,
        ...ce(t)
    });
    let hn = class xi extends ue {
        constructor() {
            super(...arguments),
            this.min = this.gte,
            this.max = this.lte
        }
        _parse(e) {
            if (this._def.coerce)
                try {
                    e.data = BigInt(e.data)
                } catch {
                    return this._getInvalidInput(e)
                }
            if (this._getType(e) !== G.bigint)
                return this._getInvalidInput(e);
            let o;
            const n = new pt;
            for (const s of this._def.checks)
                s.kind === "min" ? (s.inclusive ? e.data < s.value : e.data <= s.value) && (o = this._getOrReturnCtx(e, o),
                B(o, {
                    code: M.too_small,
                    type: "bigint",
                    minimum: s.value,
                    inclusive: s.inclusive,
                    message: s.message
                }),
                n.dirty()) : s.kind === "max" ? (s.inclusive ? e.data > s.value : e.data >= s.value) && (o = this._getOrReturnCtx(e, o),
                B(o, {
                    code: M.too_big,
                    type: "bigint",
                    maximum: s.value,
                    inclusive: s.inclusive,
                    message: s.message
                }),
                n.dirty()) : s.kind === "multipleOf" ? e.data % s.value !== BigInt(0) && (o = this._getOrReturnCtx(e, o),
                B(o, {
                    code: M.not_multiple_of,
                    multipleOf: s.value,
                    message: s.message
                }),
                n.dirty()) : le.assertNever(s);
            return {
                status: n.value,
                value: e.data
            }
        }
        _getInvalidInput(e) {
            const r = this._getOrReturnCtx(e);
            return B(r, {
                code: M.invalid_type,
                expected: G.bigint,
                received: r.parsedType
            }),
            oe
        }
        gte(e, r) {
            return this.setLimit("min", e, !0, J.toString(r))
        }
        gt(e, r) {
            return this.setLimit("min", e, !1, J.toString(r))
        }
        lte(e, r) {
            return this.setLimit("max", e, !0, J.toString(r))
        }
        lt(e, r) {
            return this.setLimit("max", e, !1, J.toString(r))
        }
        setLimit(e, r, o, n) {
            return new xi({
                ...this._def,
                checks: [...this._def.checks, {
                    kind: e,
                    value: r,
                    inclusive: o,
                    message: J.toString(n)
                }]
            })
        }
        _addCheck(e) {
            return new xi({
                ...this._def,
                checks: [...this._def.checks, e]
            })
        }
        positive(e) {
            return this._addCheck({
                kind: "min",
                value: BigInt(0),
                inclusive: !1,
                message: J.toString(e)
            })
        }
        negative(e) {
            return this._addCheck({
                kind: "max",
                value: BigInt(0),
                inclusive: !1,
                message: J.toString(e)
            })
        }
        nonpositive(e) {
            return this._addCheck({
                kind: "max",
                value: BigInt(0),
                inclusive: !0,
                message: J.toString(e)
            })
        }
        nonnegative(e) {
            return this._addCheck({
                kind: "min",
                value: BigInt(0),
                inclusive: !0,
                message: J.toString(e)
            })
        }
        multipleOf(e, r) {
            return this._addCheck({
                kind: "multipleOf",
                value: e,
                message: J.toString(r)
            })
        }
        get minValue() {
            let e = null;
            for (const r of this._def.checks)
                r.kind === "min" && (e === null || r.value > e) && (e = r.value);
            return e
        }
        get maxValue() {
            let e = null;
            for (const r of this._def.checks)
                r.kind === "max" && (e === null || r.value < e) && (e = r.value);
            return e
        }
    }
    ;
    hn.create = t => {
        var e;
        return new hn({
            checks: [],
            typeName: F.ZodBigInt,
            coerce: (e = t == null ? void 0 : t.coerce) !== null && e !== void 0 ? e : !1,
            ...ce(t)
        })
    }
    ;
    let gn = class extends ue {
        _parse(e) {
            if (this._def.coerce && (e.data = !!e.data),
            this._getType(e) !== G.boolean) {
                const o = this._getOrReturnCtx(e);
                return B(o, {
                    code: M.invalid_type,
                    expected: G.boolean,
                    received: o.parsedType
                }),
                oe
            }
            return at(e.data)
        }
    }
    ;
    gn.create = t => new gn({
        typeName: F.ZodBoolean,
        coerce: (t == null ? void 0 : t.coerce) || !1,
        ...ce(t)
    });
    let fn = class Yu extends ue {
        _parse(e) {
            if (this._def.coerce && (e.data = new Date(e.data)),
            this._getType(e) !== G.date) {
                const s = this._getOrReturnCtx(e);
                return B(s, {
                    code: M.invalid_type,
                    expected: G.date,
                    received: s.parsedType
                }),
                oe
            }
            if (isNaN(e.data.getTime())) {
                const s = this._getOrReturnCtx(e);
                return B(s, {
                    code: M.invalid_date
                }),
                oe
            }
            const o = new pt;
            let n;
            for (const s of this._def.checks)
                s.kind === "min" ? e.data.getTime() < s.value && (n = this._getOrReturnCtx(e, n),
                B(n, {
                    code: M.too_small,
                    message: s.message,
                    inclusive: !0,
                    exact: !1,
                    minimum: s.value,
                    type: "date"
                }),
                o.dirty()) : s.kind === "max" ? e.data.getTime() > s.value && (n = this._getOrReturnCtx(e, n),
                B(n, {
                    code: M.too_big,
                    message: s.message,
                    inclusive: !0,
                    exact: !1,
                    maximum: s.value,
                    type: "date"
                }),
                o.dirty()) : le.assertNever(s);
            return {
                status: o.value,
                value: new Date(e.data.getTime())
            }
        }
        _addCheck(e) {
            return new Yu({
                ...this._def,
                checks: [...this._def.checks, e]
            })
        }
        min(e, r) {
            return this._addCheck({
                kind: "min",
                value: e.getTime(),
                message: J.toString(r)
            })
        }
        max(e, r) {
            return this._addCheck({
                kind: "max",
                value: e.getTime(),
                message: J.toString(r)
            })
        }
        get minDate() {
            let e = null;
            for (const r of this._def.checks)
                r.kind === "min" && (e === null || r.value > e) && (e = r.value);
            return e != null ? new Date(e) : null
        }
        get maxDate() {
            let e = null;
            for (const r of this._def.checks)
                r.kind === "max" && (e === null || r.value < e) && (e = r.value);
            return e != null ? new Date(e) : null
        }
    }
    ;
    fn.create = t => new fn({
        checks: [],
        coerce: (t == null ? void 0 : t.coerce) || !1,
        typeName: F.ZodDate,
        ...ce(t)
    });
    let oo = class extends ue {
        _parse(e) {
            if (this._getType(e) !== G.symbol) {
                const o = this._getOrReturnCtx(e);
                return B(o, {
                    code: M.invalid_type,
                    expected: G.symbol,
                    received: o.parsedType
                }),
                oe
            }
            return at(e.data)
        }
    }
    ;
    oo.create = t => new oo({
        typeName: F.ZodSymbol,
        ...ce(t)
    });
    let yn = class extends ue {
        _parse(e) {
            if (this._getType(e) !== G.undefined) {
                const o = this._getOrReturnCtx(e);
                return B(o, {
                    code: M.invalid_type,
                    expected: G.undefined,
                    received: o.parsedType
                }),
                oe
            }
            return at(e.data)
        }
    }
    ;
    yn.create = t => new yn({
        typeName: F.ZodUndefined,
        ...ce(t)
    });
    let vn = class extends ue {
        _parse(e) {
            if (this._getType(e) !== G.null) {
                const o = this._getOrReturnCtx(e);
                return B(o, {
                    code: M.invalid_type,
                    expected: G.null,
                    received: o.parsedType
                }),
                oe
            }
            return at(e.data)
        }
    }
    ;
    vn.create = t => new vn({
        typeName: F.ZodNull,
        ...ce(t)
    });
    let Wr = class extends ue {
        constructor() {
            super(...arguments),
            this._any = !0
        }
        _parse(e) {
            return at(e.data)
        }
    }
    ;
    Wr.create = t => new Wr({
        typeName: F.ZodAny,
        ...ce(t)
    });
    let _r = class extends ue {
        constructor() {
            super(...arguments),
            this._unknown = !0
        }
        _parse(e) {
            return at(e.data)
        }
    }
    ;
    _r.create = t => new _r({
        typeName: F.ZodUnknown,
        ...ce(t)
    });
    let Kt = class extends ue {
        _parse(e) {
            const r = this._getOrReturnCtx(e);
            return B(r, {
                code: M.invalid_type,
                expected: G.never,
                received: r.parsedType
            }),
            oe
        }
    }
    ;
    Kt.create = t => new Kt({
        typeName: F.ZodNever,
        ...ce(t)
    });
    let so = class extends ue {
        _parse(e) {
            if (this._getType(e) !== G.undefined) {
                const o = this._getOrReturnCtx(e);
                return B(o, {
                    code: M.invalid_type,
                    expected: G.void,
                    received: o.parsedType
                }),
                oe
            }
            return at(e.data)
        }
    }
    ;
    so.create = t => new so({
        typeName: F.ZodVoid,
        ...ce(t)
    });
    let Tr = class ks extends ue {
        _parse(e) {
            const {ctx: r, status: o} = this._processInputParams(e)
              , n = this._def;
            if (r.parsedType !== G.array)
                return B(r, {
                    code: M.invalid_type,
                    expected: G.array,
                    received: r.parsedType
                }),
                oe;
            if (n.exactLength !== null) {
                const i = r.data.length > n.exactLength.value
                  , l = r.data.length < n.exactLength.value;
                (i || l) && (B(r, {
                    code: i ? M.too_big : M.too_small,
                    minimum: l ? n.exactLength.value : void 0,
                    maximum: i ? n.exactLength.value : void 0,
                    type: "array",
                    inclusive: !0,
                    exact: !0,
                    message: n.exactLength.message
                }),
                o.dirty())
            }
            if (n.minLength !== null && r.data.length < n.minLength.value && (B(r, {
                code: M.too_small,
                minimum: n.minLength.value,
                type: "array",
                inclusive: !0,
                exact: !1,
                message: n.minLength.message
            }),
            o.dirty()),
            n.maxLength !== null && r.data.length > n.maxLength.value && (B(r, {
                code: M.too_big,
                maximum: n.maxLength.value,
                type: "array",
                inclusive: !0,
                exact: !1,
                message: n.maxLength.message
            }),
            o.dirty()),
            r.common.async)
                return Promise.all([...r.data].map( (i, l) => n.type._parseAsync(new Mt(r,i,r.path,l)))).then(i => pt.mergeArray(o, i));
            const s = [...r.data].map( (i, l) => n.type._parseSync(new Mt(r,i,r.path,l)));
            return pt.mergeArray(o, s)
        }
        get element() {
            return this._def.type
        }
        min(e, r) {
            return new ks({
                ...this._def,
                minLength: {
                    value: e,
                    message: J.toString(r)
                }
            })
        }
        max(e, r) {
            return new ks({
                ...this._def,
                maxLength: {
                    value: e,
                    message: J.toString(r)
                }
            })
        }
        length(e, r) {
            return new ks({
                ...this._def,
                exactLength: {
                    value: e,
                    message: J.toString(r)
                }
            })
        }
        nonempty(e) {
            return this.min(1, e)
        }
    }
    ;
    Tr.create = (t, e) => new Tr({
        type: t,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: F.ZodArray,
        ...ce(e)
    });
    function qr(t) {
        if (t instanceof bt) {
            const e = {};
            for (const r in t.shape) {
                const o = t.shape[r];
                e[r] = Rt.create(qr(o))
            }
            return new bt({
                ...t._def,
                shape: () => e
            })
        } else
            return t instanceof Tr ? new Tr({
                ...t._def,
                type: qr(t.element)
            }) : t instanceof Rt ? Rt.create(qr(t.unwrap())) : t instanceof ur ? ur.create(qr(t.unwrap())) : t instanceof dr ? dr.create(t.items.map(e => qr(e))) : t
    }
    let bt = class jt extends ue {
        constructor() {
            super(...arguments),
            this._cached = null,
            this.nonstrict = this.passthrough,
            this.augment = this.extend
        }
        _getCached() {
            if (this._cached !== null)
                return this._cached;
            const e = this._def.shape()
              , r = le.objectKeys(e);
            return this._cached = {
                shape: e,
                keys: r
            }
        }
        _parse(e) {
            if (this._getType(e) !== G.object) {
                const u = this._getOrReturnCtx(e);
                return B(u, {
                    code: M.invalid_type,
                    expected: G.object,
                    received: u.parsedType
                }),
                oe
            }
            const {status: o, ctx: n} = this._processInputParams(e)
              , {shape: s, keys: i} = this._getCached()
              , l = [];
            if (!(this._def.catchall instanceof Kt && this._def.unknownKeys === "strip"))
                for (const u in n.data)
                    i.includes(u) || l.push(u);
            const d = [];
            for (const u of i) {
                const g = s[u]
                  , c = n.data[u];
                d.push({
                    key: {
                        status: "valid",
                        value: u
                    },
                    value: g._parse(new Mt(n,c,n.path,u)),
                    alwaysSet: u in n.data
                })
            }
            if (this._def.catchall instanceof Kt) {
                const u = this._def.unknownKeys;
                if (u === "passthrough")
                    for (const g of l)
                        d.push({
                            key: {
                                status: "valid",
                                value: g
                            },
                            value: {
                                status: "valid",
                                value: n.data[g]
                            }
                        });
                else if (u === "strict")
                    l.length > 0 && (B(n, {
                        code: M.unrecognized_keys,
                        keys: l
                    }),
                    o.dirty());
                else if (u !== "strip")
                    throw new Error("Internal ZodObject error: invalid unknownKeys value.")
            } else {
                const u = this._def.catchall;
                for (const g of l) {
                    const c = n.data[g];
                    d.push({
                        key: {
                            status: "valid",
                            value: g
                        },
                        value: u._parse(new Mt(n,c,n.path,g)),
                        alwaysSet: g in n.data
                    })
                }
            }
            return n.common.async ? Promise.resolve().then(async () => {
                const u = [];
                for (const g of d) {
                    const c = await g.key
                      , m = await g.value;
                    u.push({
                        key: c,
                        value: m,
                        alwaysSet: g.alwaysSet
                    })
                }
                return u
            }
            ).then(u => pt.mergeObjectSync(o, u)) : pt.mergeObjectSync(o, d)
        }
        get shape() {
            return this._def.shape()
        }
        strict(e) {
            return J.errToObj,
            new jt({
                ...this._def,
                unknownKeys: "strict",
                ...e !== void 0 ? {
                    errorMap: (r, o) => {
                        var n, s, i, l;
                        const d = (i = (s = (n = this._def).errorMap) === null || s === void 0 ? void 0 : s.call(n, r, o).message) !== null && i !== void 0 ? i : o.defaultError;
                        return r.code === "unrecognized_keys" ? {
                            message: (l = J.errToObj(e).message) !== null && l !== void 0 ? l : d
                        } : {
                            message: d
                        }
                    }
                } : {}
            })
        }
        strip() {
            return new jt({
                ...this._def,
                unknownKeys: "strip"
            })
        }
        passthrough() {
            return new jt({
                ...this._def,
                unknownKeys: "passthrough"
            })
        }
        extend(e) {
            return new jt({
                ...this._def,
                shape: () => ({
                    ...this._def.shape(),
                    ...e
                })
            })
        }
        merge(e) {
            return new jt({
                unknownKeys: e._def.unknownKeys,
                catchall: e._def.catchall,
                shape: () => ({
                    ...this._def.shape(),
                    ...e._def.shape()
                }),
                typeName: F.ZodObject
            })
        }
        setKey(e, r) {
            return this.augment({
                [e]: r
            })
        }
        catchall(e) {
            return new jt({
                ...this._def,
                catchall: e
            })
        }
        pick(e) {
            const r = {};
            return le.objectKeys(e).forEach(o => {
                e[o] && this.shape[o] && (r[o] = this.shape[o])
            }
            ),
            new jt({
                ...this._def,
                shape: () => r
            })
        }
        omit(e) {
            const r = {};
            return le.objectKeys(this.shape).forEach(o => {
                e[o] || (r[o] = this.shape[o])
            }
            ),
            new jt({
                ...this._def,
                shape: () => r
            })
        }
        deepPartial() {
            return qr(this)
        }
        partial(e) {
            const r = {};
            return le.objectKeys(this.shape).forEach(o => {
                const n = this.shape[o];
                e && !e[o] ? r[o] = n : r[o] = n.optional()
            }
            ),
            new jt({
                ...this._def,
                shape: () => r
            })
        }
        required(e) {
            const r = {};
            return le.objectKeys(this.shape).forEach(o => {
                if (e && !e[o])
                    r[o] = this.shape[o];
                else {
                    let s = this.shape[o];
                    for (; s instanceof Rt; )
                        s = s._def.innerType;
                    r[o] = s
                }
            }
            ),
            new jt({
                ...this._def,
                shape: () => r
            })
        }
        keyof() {
            return Ni(le.objectKeys(this.shape))
        }
    }
    ;
    bt.create = (t, e) => new bt({
        shape: () => t,
        unknownKeys: "strip",
        catchall: Kt.create(),
        typeName: F.ZodObject,
        ...ce(e)
    }),
    bt.strictCreate = (t, e) => new bt({
        shape: () => t,
        unknownKeys: "strict",
        catchall: Kt.create(),
        typeName: F.ZodObject,
        ...ce(e)
    }),
    bt.lazycreate = (t, e) => new bt({
        shape: t,
        unknownKeys: "strip",
        catchall: Kt.create(),
        typeName: F.ZodObject,
        ...ce(e)
    });
    let wn = class extends ue {
        _parse(e) {
            const {ctx: r} = this._processInputParams(e)
              , o = this._def.options;
            function n(s) {
                for (const l of s)
                    if (l.result.status === "valid")
                        return l.result;
                for (const l of s)
                    if (l.result.status === "dirty")
                        return r.common.issues.push(...l.ctx.common.issues),
                        l.result;
                const i = s.map(l => new $t(l.ctx.common.issues));
                return B(r, {
                    code: M.invalid_union,
                    unionErrors: i
                }),
                oe
            }
            if (r.common.async)
                return Promise.all(o.map(async s => {
                    const i = {
                        ...r,
                        common: {
                            ...r.common,
                            issues: []
                        },
                        parent: null
                    };
                    return {
                        result: await s._parseAsync({
                            data: r.data,
                            path: r.path,
                            parent: i
                        }),
                        ctx: i
                    }
                }
                )).then(n);
            {
                let s;
                const i = [];
                for (const d of o) {
                    const u = {
                        ...r,
                        common: {
                            ...r.common,
                            issues: []
                        },
                        parent: null
                    }
                      , g = d._parseSync({
                        data: r.data,
                        path: r.path,
                        parent: u
                    });
                    if (g.status === "valid")
                        return g;
                    g.status === "dirty" && !s && (s = {
                        result: g,
                        ctx: u
                    }),
                    u.common.issues.length && i.push(u.common.issues)
                }
                if (s)
                    return r.common.issues.push(...s.ctx.common.issues),
                    s.result;
                const l = i.map(d => new $t(d));
                return B(r, {
                    code: M.invalid_union,
                    unionErrors: l
                }),
                oe
            }
        }
        get options() {
            return this._def.options
        }
    }
    ;
    wn.create = (t, e) => new wn({
        options: t,
        typeName: F.ZodUnion,
        ...ce(e)
    });
    const Qt = t => t instanceof Sn ? Qt(t.schema) : t instanceof At ? Qt(t.innerType()) : t instanceof En ? [t.value] : t instanceof xn ? t.options : t instanceof _n ? le.objectValues(t.enum) : t instanceof Tn ? Qt(t._def.innerType) : t instanceof yn ? [void 0] : t instanceof vn ? [null] : t instanceof Rt ? [void 0, ...Qt(t.unwrap())] : t instanceof ur ? [null, ...Qt(t.unwrap())] : t instanceof Rs || t instanceof kn ? Qt(t.unwrap()) : t instanceof Pn ? Qt(t._def.innerType) : [];
    let Oi = class Ku extends ue {
        _parse(e) {
            const {ctx: r} = this._processInputParams(e);
            if (r.parsedType !== G.object)
                return B(r, {
                    code: M.invalid_type,
                    expected: G.object,
                    received: r.parsedType
                }),
                oe;
            const o = this.discriminator
              , n = r.data[o]
              , s = this.optionsMap.get(n);
            return s ? r.common.async ? s._parseAsync({
                data: r.data,
                path: r.path,
                parent: r
            }) : s._parseSync({
                data: r.data,
                path: r.path,
                parent: r
            }) : (B(r, {
                code: M.invalid_union_discriminator,
                options: Array.from(this.optionsMap.keys()),
                path: [o]
            }),
            oe)
        }
        get discriminator() {
            return this._def.discriminator
        }
        get options() {
            return this._def.options
        }
        get optionsMap() {
            return this._def.optionsMap
        }
        static create(e, r, o) {
            const n = new Map;
            for (const s of r) {
                const i = Qt(s.shape[e]);
                if (!i.length)
                    throw new Error(`A discriminator value for key \`${e}\` could not be extracted from all schema options`);
                for (const l of i) {
                    if (n.has(l))
                        throw new Error(`Discriminator property ${String(e)} has duplicate value ${String(l)}`);
                    n.set(l, s)
                }
            }
            return new Ku({
                typeName: F.ZodDiscriminatedUnion,
                discriminator: e,
                options: r,
                optionsMap: n,
                ...ce(o)
            })
        }
    }
    ;
    function As(t, e) {
        const r = Yt(t)
          , o = Yt(e);
        if (t === e)
            return {
                valid: !0,
                data: t
            };
        if (r === G.object && o === G.object) {
            const n = le.objectKeys(e)
              , s = le.objectKeys(t).filter(l => n.indexOf(l) !== -1)
              , i = {
                ...t,
                ...e
            };
            for (const l of s) {
                const d = As(t[l], e[l]);
                if (!d.valid)
                    return {
                        valid: !1
                    };
                i[l] = d.data
            }
            return {
                valid: !0,
                data: i
            }
        } else if (r === G.array && o === G.array) {
            if (t.length !== e.length)
                return {
                    valid: !1
                };
            const n = [];
            for (let s = 0; s < t.length; s++) {
                const i = t[s]
                  , l = e[s]
                  , d = As(i, l);
                if (!d.valid)
                    return {
                        valid: !1
                    };
                n.push(d.data)
            }
            return {
                valid: !0,
                data: n
            }
        } else
            return r === G.date && o === G.date && +t == +e ? {
                valid: !0,
                data: t
            } : {
                valid: !1
            }
    }
    let bn = class extends ue {
        _parse(e) {
            const {status: r, ctx: o} = this._processInputParams(e)
              , n = (s, i) => {
                if (Is(s) || Is(i))
                    return oe;
                const l = As(s.value, i.value);
                return l.valid ? ((Cs(s) || Cs(i)) && r.dirty(),
                {
                    status: r.value,
                    value: l.data
                }) : (B(o, {
                    code: M.invalid_intersection_types
                }),
                oe)
            }
            ;
            return o.common.async ? Promise.all([this._def.left._parseAsync({
                data: o.data,
                path: o.path,
                parent: o
            }), this._def.right._parseAsync({
                data: o.data,
                path: o.path,
                parent: o
            })]).then( ([s,i]) => n(s, i)) : n(this._def.left._parseSync({
                data: o.data,
                path: o.path,
                parent: o
            }), this._def.right._parseSync({
                data: o.data,
                path: o.path,
                parent: o
            }))
        }
    }
    ;
    bn.create = (t, e, r) => new bn({
        left: t,
        right: e,
        typeName: F.ZodIntersection,
        ...ce(r)
    });
    let dr = class Qu extends ue {
        _parse(e) {
            const {status: r, ctx: o} = this._processInputParams(e);
            if (o.parsedType !== G.array)
                return B(o, {
                    code: M.invalid_type,
                    expected: G.array,
                    received: o.parsedType
                }),
                oe;
            if (o.data.length < this._def.items.length)
                return B(o, {
                    code: M.too_small,
                    minimum: this._def.items.length,
                    inclusive: !0,
                    exact: !1,
                    type: "array"
                }),
                oe;
            !this._def.rest && o.data.length > this._def.items.length && (B(o, {
                code: M.too_big,
                maximum: this._def.items.length,
                inclusive: !0,
                exact: !1,
                type: "array"
            }),
            r.dirty());
            const s = [...o.data].map( (i, l) => {
                const d = this._def.items[l] || this._def.rest;
                return d ? d._parse(new Mt(o,i,o.path,l)) : null
            }
            ).filter(i => !!i);
            return o.common.async ? Promise.all(s).then(i => pt.mergeArray(r, i)) : pt.mergeArray(r, s)
        }
        get items() {
            return this._def.items
        }
        rest(e) {
            return new Qu({
                ...this._def,
                rest: e
            })
        }
    }
    ;
    dr.create = (t, e) => {
        if (!Array.isArray(t))
            throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
        return new dr({
            items: t,
            typeName: F.ZodTuple,
            rest: null,
            ...ce(e)
        })
    }
    ;
    let Di = class _i extends ue {
        get keySchema() {
            return this._def.keyType
        }
        get valueSchema() {
            return this._def.valueType
        }
        _parse(e) {
            const {status: r, ctx: o} = this._processInputParams(e);
            if (o.parsedType !== G.object)
                return B(o, {
                    code: M.invalid_type,
                    expected: G.object,
                    received: o.parsedType
                }),
                oe;
            const n = []
              , s = this._def.keyType
              , i = this._def.valueType;
            for (const l in o.data)
                n.push({
                    key: s._parse(new Mt(o,l,o.path,l)),
                    value: i._parse(new Mt(o,o.data[l],o.path,l)),
                    alwaysSet: l in o.data
                });
            return o.common.async ? pt.mergeObjectAsync(r, n) : pt.mergeObjectSync(r, n)
        }
        get element() {
            return this._def.valueType
        }
        static create(e, r, o) {
            return r instanceof ue ? new _i({
                keyType: e,
                valueType: r,
                typeName: F.ZodRecord,
                ...ce(o)
            }) : new _i({
                keyType: Fr.create(),
                valueType: e,
                typeName: F.ZodRecord,
                ...ce(r)
            })
        }
    }
      , ao = class extends ue {
        get keySchema() {
            return this._def.keyType
        }
        get valueSchema() {
            return this._def.valueType
        }
        _parse(e) {
            const {status: r, ctx: o} = this._processInputParams(e);
            if (o.parsedType !== G.map)
                return B(o, {
                    code: M.invalid_type,
                    expected: G.map,
                    received: o.parsedType
                }),
                oe;
            const n = this._def.keyType
              , s = this._def.valueType
              , i = [...o.data.entries()].map( ([l,d], u) => ({
                key: n._parse(new Mt(o,l,o.path,[u, "key"])),
                value: s._parse(new Mt(o,d,o.path,[u, "value"]))
            }));
            if (o.common.async) {
                const l = new Map;
                return Promise.resolve().then(async () => {
                    for (const d of i) {
                        const u = await d.key
                          , g = await d.value;
                        if (u.status === "aborted" || g.status === "aborted")
                            return oe;
                        (u.status === "dirty" || g.status === "dirty") && r.dirty(),
                        l.set(u.value, g.value)
                    }
                    return {
                        status: r.value,
                        value: l
                    }
                }
                )
            } else {
                const l = new Map;
                for (const d of i) {
                    const u = d.key
                      , g = d.value;
                    if (u.status === "aborted" || g.status === "aborted")
                        return oe;
                    (u.status === "dirty" || g.status === "dirty") && r.dirty(),
                    l.set(u.value, g.value)
                }
                return {
                    status: r.value,
                    value: l
                }
            }
        }
    }
    ;
    ao.create = (t, e, r) => new ao({
        valueType: e,
        keyType: t,
        typeName: F.ZodMap,
        ...ce(r)
    });
    let io = class Ti extends ue {
        _parse(e) {
            const {status: r, ctx: o} = this._processInputParams(e);
            if (o.parsedType !== G.set)
                return B(o, {
                    code: M.invalid_type,
                    expected: G.set,
                    received: o.parsedType
                }),
                oe;
            const n = this._def;
            n.minSize !== null && o.data.size < n.minSize.value && (B(o, {
                code: M.too_small,
                minimum: n.minSize.value,
                type: "set",
                inclusive: !0,
                exact: !1,
                message: n.minSize.message
            }),
            r.dirty()),
            n.maxSize !== null && o.data.size > n.maxSize.value && (B(o, {
                code: M.too_big,
                maximum: n.maxSize.value,
                type: "set",
                inclusive: !0,
                exact: !1,
                message: n.maxSize.message
            }),
            r.dirty());
            const s = this._def.valueType;
            function i(d) {
                const u = new Set;
                for (const g of d) {
                    if (g.status === "aborted")
                        return oe;
                    g.status === "dirty" && r.dirty(),
                    u.add(g.value)
                }
                return {
                    status: r.value,
                    value: u
                }
            }
            const l = [...o.data.values()].map( (d, u) => s._parse(new Mt(o,d,o.path,u)));
            return o.common.async ? Promise.all(l).then(d => i(d)) : i(l)
        }
        min(e, r) {
            return new Ti({
                ...this._def,
                minSize: {
                    value: e,
                    message: J.toString(r)
                }
            })
        }
        max(e, r) {
            return new Ti({
                ...this._def,
                maxSize: {
                    value: e,
                    message: J.toString(r)
                }
            })
        }
        size(e, r) {
            return this.min(e, r).max(e, r)
        }
        nonempty(e) {
            return this.min(1, e)
        }
    }
    ;
    io.create = (t, e) => new io({
        valueType: t,
        minSize: null,
        maxSize: null,
        typeName: F.ZodSet,
        ...ce(e)
    });
    class Gr extends ue {
        constructor() {
            super(...arguments),
            this.validate = this.implement
        }
        _parse(e) {
            const {ctx: r} = this._processInputParams(e);
            if (r.parsedType !== G.function)
                return B(r, {
                    code: M.invalid_type,
                    expected: G.function,
                    received: r.parsedType
                }),
                oe;
            function o(l, d) {
                return ro({
                    data: l,
                    path: r.path,
                    errorMaps: [r.common.contextualErrorMap, r.schemaErrorMap, to(), jr].filter(u => !!u),
                    issueData: {
                        code: M.invalid_arguments,
                        argumentsError: d
                    }
                })
            }
            function n(l, d) {
                return ro({
                    data: l,
                    path: r.path,
                    errorMaps: [r.common.contextualErrorMap, r.schemaErrorMap, to(), jr].filter(u => !!u),
                    issueData: {
                        code: M.invalid_return_type,
                        returnTypeError: d
                    }
                })
            }
            const s = {
                errorMap: r.common.contextualErrorMap
            }
              , i = r.data;
            if (this._def.returns instanceof Br) {
                const l = this;
                return at(async function(...d) {
                    const u = new $t([])
                      , g = await l._def.args.parseAsync(d, s).catch(p => {
                        throw u.addIssue(o(d, p)),
                        u
                    }
                    )
                      , c = await Reflect.apply(i, this, g);
                    return await l._def.returns._def.type.parseAsync(c, s).catch(p => {
                        throw u.addIssue(n(c, p)),
                        u
                    }
                    )
                })
            } else {
                const l = this;
                return at(function(...d) {
                    const u = l._def.args.safeParse(d, s);
                    if (!u.success)
                        throw new $t([o(d, u.error)]);
                    const g = Reflect.apply(i, this, u.data)
                      , c = l._def.returns.safeParse(g, s);
                    if (!c.success)
                        throw new $t([n(g, c.error)]);
                    return c.data
                })
            }
        }
        parameters() {
            return this._def.args
        }
        returnType() {
            return this._def.returns
        }
        args(...e) {
            return new Gr({
                ...this._def,
                args: dr.create(e).rest(_r.create())
            })
        }
        returns(e) {
            return new Gr({
                ...this._def,
                returns: e
            })
        }
        implement(e) {
            return this.parse(e)
        }
        strictImplement(e) {
            return this.parse(e)
        }
        static create(e, r, o) {
            return new Gr({
                args: e || dr.create([]).rest(_r.create()),
                returns: r || _r.create(),
                typeName: F.ZodFunction,
                ...ce(o)
            })
        }
    }
    let Sn = class extends ue {
        get schema() {
            return this._def.getter()
        }
        _parse(e) {
            const {ctx: r} = this._processInputParams(e);
            return this._def.getter()._parse({
                data: r.data,
                path: r.path,
                parent: r
            })
        }
    }
    ;
    Sn.create = (t, e) => new Sn({
        getter: t,
        typeName: F.ZodLazy,
        ...ce(e)
    });
    let En = class extends ue {
        _parse(e) {
            if (e.data !== this._def.value) {
                const r = this._getOrReturnCtx(e);
                return B(r, {
                    received: r.data,
                    code: M.invalid_literal,
                    expected: this._def.value
                }),
                oe
            }
            return {
                status: "valid",
                value: e.data
            }
        }
        get value() {
            return this._def.value
        }
    }
    ;
    En.create = (t, e) => new En({
        value: t,
        typeName: F.ZodLiteral,
        ...ce(e)
    });
    function Ni(t, e) {
        return new xn({
            values: t,
            typeName: F.ZodEnum,
            ...ce(e)
        })
    }
    let xn = class Pi extends ue {
        constructor() {
            super(...arguments),
            un.set(this, void 0)
        }
        _parse(e) {
            if (typeof e.data != "string") {
                const r = this._getOrReturnCtx(e)
                  , o = this._def.values;
                return B(r, {
                    expected: le.joinValues(o),
                    received: r.parsedType,
                    code: M.invalid_type
                }),
                oe
            }
            if (no(this, un, "f") || Ii(this, un, new Set(this._def.values), "f"),
            !no(this, un, "f").has(e.data)) {
                const r = this._getOrReturnCtx(e)
                  , o = this._def.values;
                return B(r, {
                    received: r.data,
                    code: M.invalid_enum_value,
                    options: o
                }),
                oe
            }
            return at(e.data)
        }
        get options() {
            return this._def.values
        }
        get enum() {
            const e = {};
            for (const r of this._def.values)
                e[r] = r;
            return e
        }
        get Values() {
            const e = {};
            for (const r of this._def.values)
                e[r] = r;
            return e
        }
        get Enum() {
            const e = {};
            for (const r of this._def.values)
                e[r] = r;
            return e
        }
        extract(e, r=this._def) {
            return Pi.create(e, {
                ...this._def,
                ...r
            })
        }
        exclude(e, r=this._def) {
            return Pi.create(this.options.filter(o => !e.includes(o)), {
                ...this._def,
                ...r
            })
        }
    }
    ;
    un = new WeakMap,
    xn.create = Ni;
    let _n = class extends ue {
        constructor() {
            super(...arguments),
            mn.set(this, void 0)
        }
        _parse(e) {
            const r = le.getValidEnumValues(this._def.values)
              , o = this._getOrReturnCtx(e);
            if (o.parsedType !== G.string && o.parsedType !== G.number) {
                const n = le.objectValues(r);
                return B(o, {
                    expected: le.joinValues(n),
                    received: o.parsedType,
                    code: M.invalid_type
                }),
                oe
            }
            if (no(this, mn, "f") || Ii(this, mn, new Set(le.getValidEnumValues(this._def.values)), "f"),
            !no(this, mn, "f").has(e.data)) {
                const n = le.objectValues(r);
                return B(o, {
                    received: o.data,
                    code: M.invalid_enum_value,
                    options: n
                }),
                oe
            }
            return at(e.data)
        }
        get enum() {
            return this._def.values
        }
    }
    ;
    mn = new WeakMap,
    _n.create = (t, e) => new _n({
        values: t,
        typeName: F.ZodNativeEnum,
        ...ce(e)
    });
    let Br = class extends ue {
        unwrap() {
            return this._def.type
        }
        _parse(e) {
            const {ctx: r} = this._processInputParams(e);
            if (r.parsedType !== G.promise && r.common.async === !1)
                return B(r, {
                    code: M.invalid_type,
                    expected: G.promise,
                    received: r.parsedType
                }),
                oe;
            const o = r.parsedType === G.promise ? r.data : Promise.resolve(r.data);
            return at(o.then(n => this._def.type.parseAsync(n, {
                path: r.path,
                errorMap: r.common.contextualErrorMap
            })))
        }
    }
    ;
    Br.create = (t, e) => new Br({
        type: t,
        typeName: F.ZodPromise,
        ...ce(e)
    });
    let At = class extends ue {
        innerType() {
            return this._def.schema
        }
        sourceType() {
            return this._def.schema._def.typeName === F.ZodEffects ? this._def.schema.sourceType() : this._def.schema
        }
        _parse(e) {
            const {status: r, ctx: o} = this._processInputParams(e)
              , n = this._def.effect || null
              , s = {
                addIssue: i => {
                    B(o, i),
                    i.fatal ? r.abort() : r.dirty()
                }
                ,
                get path() {
                    return o.path
                }
            };
            if (s.addIssue = s.addIssue.bind(s),
            n.type === "preprocess") {
                const i = n.transform(o.data, s);
                if (o.common.async)
                    return Promise.resolve(i).then(async l => {
                        if (r.value === "aborted")
                            return oe;
                        const d = await this._def.schema._parseAsync({
                            data: l,
                            path: o.path,
                            parent: o
                        });
                        return d.status === "aborted" ? oe : d.status === "dirty" || r.value === "dirty" ? Mr(d.value) : d
                    }
                    );
                {
                    if (r.value === "aborted")
                        return oe;
                    const l = this._def.schema._parseSync({
                        data: i,
                        path: o.path,
                        parent: o
                    });
                    return l.status === "aborted" ? oe : l.status === "dirty" || r.value === "dirty" ? Mr(l.value) : l
                }
            }
            if (n.type === "refinement") {
                const i = l => {
                    const d = n.refinement(l, s);
                    if (o.common.async)
                        return Promise.resolve(d);
                    if (d instanceof Promise)
                        throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                    return l
                }
                ;
                if (o.common.async === !1) {
                    const l = this._def.schema._parseSync({
                        data: o.data,
                        path: o.path,
                        parent: o
                    });
                    return l.status === "aborted" ? oe : (l.status === "dirty" && r.dirty(),
                    i(l.value),
                    {
                        status: r.value,
                        value: l.value
                    })
                } else
                    return this._def.schema._parseAsync({
                        data: o.data,
                        path: o.path,
                        parent: o
                    }).then(l => l.status === "aborted" ? oe : (l.status === "dirty" && r.dirty(),
                    i(l.value).then( () => ({
                        status: r.value,
                        value: l.value
                    }))))
            }
            if (n.type === "transform")
                if (o.common.async === !1) {
                    const i = this._def.schema._parseSync({
                        data: o.data,
                        path: o.path,
                        parent: o
                    });
                    if (!xr(i))
                        return i;
                    const l = n.transform(i.value, s);
                    if (l instanceof Promise)
                        throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
                    return {
                        status: r.value,
                        value: l
                    }
                } else
                    return this._def.schema._parseAsync({
                        data: o.data,
                        path: o.path,
                        parent: o
                    }).then(i => xr(i) ? Promise.resolve(n.transform(i.value, s)).then(l => ({
                        status: r.value,
                        value: l
                    })) : i);
            le.assertNever(n)
        }
    }
    ;
    At.create = (t, e, r) => new At({
        schema: t,
        typeName: F.ZodEffects,
        effect: e,
        ...ce(r)
    }),
    At.createWithPreprocess = (t, e, r) => new At({
        schema: e,
        effect: {
            type: "preprocess",
            transform: t
        },
        typeName: F.ZodEffects,
        ...ce(r)
    });
    let Rt = class extends ue {
        _parse(e) {
            return this._getType(e) === G.undefined ? at(void 0) : this._def.innerType._parse(e)
        }
        unwrap() {
            return this._def.innerType
        }
    }
    ;
    Rt.create = (t, e) => new Rt({
        innerType: t,
        typeName: F.ZodOptional,
        ...ce(e)
    });
    let ur = class extends ue {
        _parse(e) {
            return this._getType(e) === G.null ? at(null) : this._def.innerType._parse(e)
        }
        unwrap() {
            return this._def.innerType
        }
    }
    ;
    ur.create = (t, e) => new ur({
        innerType: t,
        typeName: F.ZodNullable,
        ...ce(e)
    });
    let Tn = class extends ue {
        _parse(e) {
            const {ctx: r} = this._processInputParams(e);
            let o = r.data;
            return r.parsedType === G.undefined && (o = this._def.defaultValue()),
            this._def.innerType._parse({
                data: o,
                path: r.path,
                parent: r
            })
        }
        removeDefault() {
            return this._def.innerType
        }
    }
    ;
    Tn.create = (t, e) => new Tn({
        innerType: t,
        typeName: F.ZodDefault,
        defaultValue: typeof e.default == "function" ? e.default : () => e.default,
        ...ce(e)
    });
    let Pn = class extends ue {
        _parse(e) {
            const {ctx: r} = this._processInputParams(e)
              , o = {
                ...r,
                common: {
                    ...r.common,
                    issues: []
                }
            }
              , n = this._def.innerType._parse({
                data: o.data,
                path: o.path,
                parent: {
                    ...o
                }
            });
            return dn(n) ? n.then(s => ({
                status: "valid",
                value: s.status === "valid" ? s.value : this._def.catchValue({
                    get error() {
                        return new $t(o.common.issues)
                    },
                    input: o.data
                })
            })) : {
                status: "valid",
                value: n.status === "valid" ? n.value : this._def.catchValue({
                    get error() {
                        return new $t(o.common.issues)
                    },
                    input: o.data
                })
            }
        }
        removeCatch() {
            return this._def.innerType
        }
    }
    ;
    Pn.create = (t, e) => new Pn({
        innerType: t,
        typeName: F.ZodCatch,
        catchValue: typeof e.catch == "function" ? e.catch : () => e.catch,
        ...ce(e)
    });
    let lo = class extends ue {
        _parse(e) {
            if (this._getType(e) !== G.nan) {
                const o = this._getOrReturnCtx(e);
                return B(o, {
                    code: M.invalid_type,
                    expected: G.nan,
                    received: o.parsedType
                }),
                oe
            }
            return {
                status: "valid",
                value: e.data
            }
        }
    }
    ;
    lo.create = t => new lo({
        typeName: F.ZodNaN,
        ...ce(t)
    });
    const _m = Symbol("zod_brand");
    let Rs = class extends ue {
        _parse(e) {
            const {ctx: r} = this._processInputParams(e)
              , o = r.data;
            return this._def.type._parse({
                data: o,
                path: r.path,
                parent: r
            })
        }
        unwrap() {
            return this._def.type
        }
    }
      , Os = class Xu extends ue {
        _parse(e) {
            const {status: r, ctx: o} = this._processInputParams(e);
            if (o.common.async)
                return (async () => {
                    const s = await this._def.in._parseAsync({
                        data: o.data,
                        path: o.path,
                        parent: o
                    });
                    return s.status === "aborted" ? oe : s.status === "dirty" ? (r.dirty(),
                    Mr(s.value)) : this._def.out._parseAsync({
                        data: s.value,
                        path: o.path,
                        parent: o
                    })
                }
                )();
            {
                const n = this._def.in._parseSync({
                    data: o.data,
                    path: o.path,
                    parent: o
                });
                return n.status === "aborted" ? oe : n.status === "dirty" ? (r.dirty(),
                {
                    status: "dirty",
                    value: n.value
                }) : this._def.out._parseSync({
                    data: n.value,
                    path: o.path,
                    parent: o
                })
            }
        }
        static create(e, r) {
            return new Xu({
                in: e,
                out: r,
                typeName: F.ZodPipeline
            })
        }
    }
      , kn = class extends ue {
        _parse(e) {
            const r = this._def.innerType._parse(e)
              , o = n => (xr(n) && (n.value = Object.freeze(n.value)),
            n);
            return dn(r) ? r.then(n => o(n)) : o(r)
        }
        unwrap() {
            return this._def.innerType
        }
    }
    ;
    kn.create = (t, e) => new kn({
        innerType: t,
        typeName: F.ZodReadonly,
        ...ce(e)
    });
    function Li(t, e) {
        const r = typeof t == "function" ? t(e) : typeof t == "string" ? {
            message: t
        } : t;
        return typeof r == "string" ? {
            message: r
        } : r
    }
    function Ui(t, e={}, r) {
        return t ? Wr.create().superRefine( (o, n) => {
            var s, i;
            const l = t(o);
            if (l instanceof Promise)
                return l.then(d => {
                    var u, g;
                    if (!d) {
                        const c = Li(e, o)
                          , m = (g = (u = c.fatal) !== null && u !== void 0 ? u : r) !== null && g !== void 0 ? g : !0;
                        n.addIssue({
                            code: "custom",
                            ...c,
                            fatal: m
                        })
                    }
                }
                );
            if (!l) {
                const d = Li(e, o)
                  , u = (i = (s = d.fatal) !== null && s !== void 0 ? s : r) !== null && i !== void 0 ? i : !0;
                n.addIssue({
                    code: "custom",
                    ...d,
                    fatal: u
                })
            }
        }
        ) : Wr.create()
    }
    const Tm = {
        object: bt.lazycreate
    };
    var F;
    (function(t) {
        t.ZodString = "ZodString",
        t.ZodNumber = "ZodNumber",
        t.ZodNaN = "ZodNaN",
        t.ZodBigInt = "ZodBigInt",
        t.ZodBoolean = "ZodBoolean",
        t.ZodDate = "ZodDate",
        t.ZodSymbol = "ZodSymbol",
        t.ZodUndefined = "ZodUndefined",
        t.ZodNull = "ZodNull",
        t.ZodAny = "ZodAny",
        t.ZodUnknown = "ZodUnknown",
        t.ZodNever = "ZodNever",
        t.ZodVoid = "ZodVoid",
        t.ZodArray = "ZodArray",
        t.ZodObject = "ZodObject",
        t.ZodUnion = "ZodUnion",
        t.ZodDiscriminatedUnion = "ZodDiscriminatedUnion",
        t.ZodIntersection = "ZodIntersection",
        t.ZodTuple = "ZodTuple",
        t.ZodRecord = "ZodRecord",
        t.ZodMap = "ZodMap",
        t.ZodSet = "ZodSet",
        t.ZodFunction = "ZodFunction",
        t.ZodLazy = "ZodLazy",
        t.ZodLiteral = "ZodLiteral",
        t.ZodEnum = "ZodEnum",
        t.ZodEffects = "ZodEffects",
        t.ZodNativeEnum = "ZodNativeEnum",
        t.ZodOptional = "ZodOptional",
        t.ZodNullable = "ZodNullable",
        t.ZodDefault = "ZodDefault",
        t.ZodCatch = "ZodCatch",
        t.ZodPromise = "ZodPromise",
        t.ZodBranded = "ZodBranded",
        t.ZodPipeline = "ZodPipeline",
        t.ZodReadonly = "ZodReadonly"
    }
    )(F || (F = {}));
    const Pm = (t, e={
        message: `Input not instance of ${t.name}`
    }) => Ui(r => r instanceof t, e)
      , ji = Fr.create
      , Mi = pn.create
      , km = lo.create
      , Im = hn.create
      , Fi = gn.create
      , Cm = fn.create
      , $m = oo.create
      , Am = yn.create
      , Rm = vn.create
      , Om = Wr.create
      , Dm = _r.create
      , Nm = Kt.create
      , Lm = so.create
      , Um = Tr.create
      , jm = bt.create
      , Mm = bt.strictCreate
      , Fm = wn.create
      , Wm = Oi.create
      , qm = bn.create
      , Gm = dr.create
      , Bm = Di.create
      , zm = ao.create
      , Zm = io.create
      , Hm = Gr.create
      , Vm = Sn.create
      , Jm = En.create
      , Ym = xn.create
      , Km = _n.create
      , Qm = Br.create
      , Wi = At.create
      , Xm = Rt.create
      , ep = ur.create
      , tp = At.createWithPreprocess
      , rp = Os.create;
    var a = Object.freeze({
        __proto__: null,
        defaultErrorMap: jr,
        setErrorMap: tm,
        getErrorMap: to,
        makeIssue: ro,
        EMPTY_PATH: rm,
        addIssueToContext: B,
        ParseStatus: pt,
        INVALID: oe,
        DIRTY: Mr,
        OK: at,
        isAborted: Is,
        isDirty: Cs,
        isValid: xr,
        isAsync: dn,
        get util() {
            return le
        },
        get objectUtil() {
            return Ct
        },
        ZodParsedType: G,
        getParsedType: Yt,
        ZodType: ue,
        datetimeRegex: Ri,
        ZodString: Fr,
        ZodNumber: pn,
        ZodBigInt: hn,
        ZodBoolean: gn,
        ZodDate: fn,
        ZodSymbol: oo,
        ZodUndefined: yn,
        ZodNull: vn,
        ZodAny: Wr,
        ZodUnknown: _r,
        ZodNever: Kt,
        ZodVoid: so,
        ZodArray: Tr,
        ZodObject: bt,
        ZodUnion: wn,
        ZodDiscriminatedUnion: Oi,
        ZodIntersection: bn,
        ZodTuple: dr,
        ZodRecord: Di,
        ZodMap: ao,
        ZodSet: io,
        ZodFunction: Gr,
        ZodLazy: Sn,
        ZodLiteral: En,
        ZodEnum: xn,
        ZodNativeEnum: _n,
        ZodPromise: Br,
        ZodEffects: At,
        ZodTransformer: At,
        ZodOptional: Rt,
        ZodNullable: ur,
        ZodDefault: Tn,
        ZodCatch: Pn,
        ZodNaN: lo,
        BRAND: _m,
        ZodBranded: Rs,
        ZodPipeline: Os,
        ZodReadonly: kn,
        custom: Ui,
        Schema: ue,
        ZodSchema: ue,
        late: Tm,
        get ZodFirstPartyTypeKind() {
            return F
        },
        coerce: {
            string: t => Fr.create({
                ...t,
                coerce: !0
            }),
            number: t => pn.create({
                ...t,
                coerce: !0
            }),
            boolean: t => gn.create({
                ...t,
                coerce: !0
            }),
            bigint: t => hn.create({
                ...t,
                coerce: !0
            }),
            date: t => fn.create({
                ...t,
                coerce: !0
            })
        },
        any: Om,
        array: Um,
        bigint: Im,
        boolean: Fi,
        date: Cm,
        discriminatedUnion: Wm,
        effect: Wi,
        enum: Ym,
        function: Hm,
        instanceof: Pm,
        intersection: qm,
        lazy: Vm,
        literal: Jm,
        map: zm,
        nan: km,
        nativeEnum: Km,
        never: Nm,
        null: Rm,
        nullable: ep,
        number: Mi,
        object: jm,
        oboolean: () => Fi().optional(),
        onumber: () => Mi().optional(),
        optional: Xm,
        ostring: () => ji().optional(),
        pipeline: rp,
        preprocess: tp,
        promise: Qm,
        record: Bm,
        set: Zm,
        strictObject: Mm,
        string: ji,
        symbol: $m,
        transformer: Wi,
        tuple: Gm,
        undefined: Am,
        union: Fm,
        unknown: Dm,
        void: Lm,
        NEVER: oe,
        ZodIssueCode: M,
        quotelessJson: em,
        ZodError: $t
    });
    const Ds = "2025-06-18"
      , np = "2025-03-26"
      , qi = [Ds, "2025-03-26", "2024-11-05", "2024-10-07"]
      , In = "2.0"
      , Ns = a.union([a.string(), a.number().int()])
      , Ls = a.string()
      , op = a.object({
        progressToken: a.optional(Ns)
    }).passthrough()
      , St = a.object({
        _meta: a.optional(op)
    }).passthrough()
      , it = a.object({
        method: a.string(),
        params: a.optional(St)
    })
      , Cn = a.object({
        _meta: a.optional(a.object({}).passthrough())
    }).passthrough()
      , Ot = a.object({
        method: a.string(),
        params: a.optional(Cn)
    })
      , yt = a.object({
        _meta: a.optional(a.object({}).passthrough())
    }).passthrough()
      , $n = a.union([a.string(), a.number().int()])
      , Us = a.object({
        jsonrpc: a.literal(In),
        id: $n
    }).merge(it).strict()
      , Gi = t => Us.safeParse(t).success
      , js = a.object({
        jsonrpc: a.literal(In)
    }).merge(Ot).strict()
      , Bi = t => js.safeParse(t).success
      , Ms = a.object({
        jsonrpc: a.literal(In),
        id: $n,
        result: yt
    }).strict()
      , Fs = t => Ms.safeParse(t).success;
    var Re;
    (function(t) {
        t[t.ConnectionClosed = -32e3] = "ConnectionClosed",
        t[t.RequestTimeout = -32001] = "RequestTimeout",
        t[t.ParseError = -32700] = "ParseError",
        t[t.InvalidRequest = -32600] = "InvalidRequest",
        t[t.MethodNotFound = -32601] = "MethodNotFound",
        t[t.InvalidParams = -32602] = "InvalidParams",
        t[t.InternalError = -32603] = "InternalError"
    }
    )(Re || (Re = {}));
    const Ws = a.object({
        jsonrpc: a.literal(In),
        id: $n,
        error: a.object({
            code: a.number().int(),
            message: a.string(),
            data: a.optional(a.unknown())
        })
    }).strict()
      , zi = t => Ws.safeParse(t).success
      , Zi = a.union([Us, js, Ms, Ws])
      , co = yt.strict()
      , uo = Ot.extend({
        method: a.literal("notifications/cancelled"),
        params: Cn.extend({
            requestId: $n,
            reason: a.string().optional()
        })
    })
      , zr = a.object({
        name: a.string(),
        title: a.optional(a.string())
    }).passthrough()
      , qs = zr.extend({
        version: a.string()
    })
      , Hi = a.object({
        experimental: a.optional(a.object({}).passthrough()),
        sampling: a.optional(a.object({}).passthrough()),
        elicitation: a.optional(a.object({}).passthrough()),
        roots: a.optional(a.object({
            listChanged: a.optional(a.boolean())
        }).passthrough())
    }).passthrough()
      , mo = it.extend({
        method: a.literal("initialize"),
        params: St.extend({
            protocolVersion: a.string(),
            capabilities: Hi,
            clientInfo: qs
        })
    })
      , sp = t => mo.safeParse(t).success
      , Vi = a.object({
        experimental: a.optional(a.object({}).passthrough()),
        logging: a.optional(a.object({}).passthrough()),
        completions: a.optional(a.object({}).passthrough()),
        prompts: a.optional(a.object({
            listChanged: a.optional(a.boolean())
        }).passthrough()),
        resources: a.optional(a.object({
            subscribe: a.optional(a.boolean()),
            listChanged: a.optional(a.boolean())
        }).passthrough()),
        tools: a.optional(a.object({
            listChanged: a.optional(a.boolean())
        }).passthrough())
    }).passthrough()
      , Ji = yt.extend({
        protocolVersion: a.string(),
        capabilities: Vi,
        serverInfo: qs,
        instructions: a.optional(a.string())
    })
      , po = Ot.extend({
        method: a.literal("notifications/initialized")
    })
      , ap = t => po.safeParse(t).success
      , ho = it.extend({
        method: a.literal("ping")
    })
      , Yi = a.object({
        progress: a.number(),
        total: a.optional(a.number()),
        message: a.optional(a.string())
    }).passthrough()
      , go = Ot.extend({
        method: a.literal("notifications/progress"),
        params: Cn.merge(Yi).extend({
            progressToken: Ns
        })
    })
      , An = it.extend({
        params: St.extend({
            cursor: a.optional(Ls)
        }).optional()
    })
      , Rn = yt.extend({
        nextCursor: a.optional(Ls)
    })
      , Gs = a.object({
        uri: a.string(),
        mimeType: a.optional(a.string()),
        _meta: a.optional(a.object({}).passthrough())
    }).passthrough()
      , Bs = Gs.extend({
        text: a.string()
    })
      , zs = a.string().refine(t => {
        try {
            return atob(t),
            !0
        } catch {
            return !1
        }
    }
    , {
        message: "Invalid Base64 string"
    })
      , Zs = Gs.extend({
        blob: zs
    })
      , Hs = zr.extend({
        uri: a.string(),
        description: a.optional(a.string()),
        mimeType: a.optional(a.string()),
        _meta: a.optional(a.object({}).passthrough())
    })
      , Ki = zr.extend({
        uriTemplate: a.string(),
        description: a.optional(a.string()),
        mimeType: a.optional(a.string()),
        _meta: a.optional(a.object({}).passthrough())
    })
      , fo = An.extend({
        method: a.literal("resources/list")
    })
      , Qi = Rn.extend({
        resources: a.array(Hs)
    })
      , yo = An.extend({
        method: a.literal("resources/templates/list")
    })
      , Xi = Rn.extend({
        resourceTemplates: a.array(Ki)
    })
      , vo = it.extend({
        method: a.literal("resources/read"),
        params: St.extend({
            uri: a.string()
        })
    })
      , el = yt.extend({
        contents: a.array(a.union([Bs, Zs]))
    })
      , tl = Ot.extend({
        method: a.literal("notifications/resources/list_changed")
    })
      , Vs = it.extend({
        method: a.literal("resources/subscribe"),
        params: St.extend({
            uri: a.string()
        })
    })
      , Js = it.extend({
        method: a.literal("resources/unsubscribe"),
        params: St.extend({
            uri: a.string()
        })
    })
      , rl = Ot.extend({
        method: a.literal("notifications/resources/updated"),
        params: Cn.extend({
            uri: a.string()
        })
    })
      , nl = a.object({
        name: a.string(),
        description: a.optional(a.string()),
        required: a.optional(a.boolean())
    }).passthrough()
      , ol = zr.extend({
        description: a.optional(a.string()),
        arguments: a.optional(a.array(nl)),
        _meta: a.optional(a.object({}).passthrough())
    })
      , wo = An.extend({
        method: a.literal("prompts/list")
    })
      , sl = Rn.extend({
        prompts: a.array(ol)
    })
      , bo = it.extend({
        method: a.literal("prompts/get"),
        params: St.extend({
            name: a.string(),
            arguments: a.optional(a.record(a.string()))
        })
    })
      , So = a.object({
        type: a.literal("text"),
        text: a.string(),
        _meta: a.optional(a.object({}).passthrough())
    }).passthrough()
      , Eo = a.object({
        type: a.literal("image"),
        data: zs,
        mimeType: a.string(),
        _meta: a.optional(a.object({}).passthrough())
    }).passthrough()
      , xo = a.object({
        type: a.literal("audio"),
        data: zs,
        mimeType: a.string(),
        _meta: a.optional(a.object({}).passthrough())
    }).passthrough()
      , al = a.object({
        type: a.literal("resource"),
        resource: a.union([Bs, Zs]),
        _meta: a.optional(a.object({}).passthrough())
    }).passthrough()
      , il = Hs.extend({
        type: a.literal("resource_link")
    })
      , Ys = a.union([So, Eo, xo, il, al])
      , ll = a.object({
        role: a.enum(["user", "assistant"]),
        content: Ys
    }).passthrough()
      , cl = yt.extend({
        description: a.optional(a.string()),
        messages: a.array(ll)
    })
      , dl = Ot.extend({
        method: a.literal("notifications/prompts/list_changed")
    })
      , ul = a.object({
        title: a.optional(a.string()),
        readOnlyHint: a.optional(a.boolean()),
        destructiveHint: a.optional(a.boolean()),
        idempotentHint: a.optional(a.boolean()),
        openWorldHint: a.optional(a.boolean())
    }).passthrough()
      , ml = zr.extend({
        description: a.optional(a.string()),
        inputSchema: a.object({
            type: a.literal("object"),
            properties: a.optional(a.object({}).passthrough()),
            required: a.optional(a.array(a.string()))
        }).passthrough(),
        outputSchema: a.optional(a.object({
            type: a.literal("object"),
            properties: a.optional(a.object({}).passthrough()),
            required: a.optional(a.array(a.string()))
        }).passthrough()),
        annotations: a.optional(ul),
        _meta: a.optional(a.object({}).passthrough())
    })
      , _o = An.extend({
        method: a.literal("tools/list")
    })
      , pl = Rn.extend({
        tools: a.array(ml)
    })
      , Ks = yt.extend({
        content: a.array(Ys).default([]),
        structuredContent: a.object({}).passthrough().optional(),
        isError: a.optional(a.boolean())
    })
      , ip = Ks.or(yt.extend({
        toolResult: a.unknown()
    }))
      , To = it.extend({
        method: a.literal("tools/call"),
        params: St.extend({
            name: a.string(),
            arguments: a.optional(a.record(a.unknown()))
        })
    })
      , hl = Ot.extend({
        method: a.literal("notifications/tools/list_changed")
    })
      , Qs = a.enum(["debug", "info", "notice", "warning", "error", "critical", "alert", "emergency"])
      , gl = it.extend({
        method: a.literal("logging/setLevel"),
        params: St.extend({
            level: Qs
        })
    })
      , fl = Ot.extend({
        method: a.literal("notifications/message"),
        params: Cn.extend({
            level: Qs,
            logger: a.optional(a.string()),
            data: a.unknown()
        })
    })
      , yl = a.object({
        name: a.string().optional()
    }).passthrough()
      , vl = a.object({
        hints: a.optional(a.array(yl)),
        costPriority: a.optional(a.number().min(0).max(1)),
        speedPriority: a.optional(a.number().min(0).max(1)),
        intelligencePriority: a.optional(a.number().min(0).max(1))
    }).passthrough()
      , Pr = a.object({
        role: a.enum(["user", "assistant"]),
        content: a.union([So, Eo, xo])
    }).passthrough()
      , wl = it.extend({
        method: a.literal("sampling/createMessage"),
        params: St.extend({
            messages: a.array(Pr),
            systemPrompt: a.optional(a.string()),
            includeContext: a.optional(a.enum(["none", "thisServer", "allServers"])),
            temperature: a.optional(a.number()),
            maxTokens: a.number().int(),
            stopSequences: a.optional(a.array(a.string())),
            metadata: a.optional(a.object({}).passthrough()),
            modelPreferences: a.optional(vl)
        })
    })
      , Xs = yt.extend({
        model: a.string(),
        stopReason: a.optional(a.enum(["endTurn", "stopSequence", "maxTokens"]).or(a.string())),
        role: a.enum(["user", "assistant"]),
        content: a.discriminatedUnion("type", [So, Eo, xo])
    })
      , bl = a.object({
        type: a.literal("boolean"),
        title: a.optional(a.string()),
        description: a.optional(a.string()),
        default: a.optional(a.boolean())
    }).passthrough()
      , Sl = a.object({
        type: a.literal("string"),
        title: a.optional(a.string()),
        description: a.optional(a.string()),
        minLength: a.optional(a.number()),
        maxLength: a.optional(a.number()),
        format: a.optional(a.enum(["email", "uri", "date", "date-time"]))
    }).passthrough()
      , El = a.object({
        type: a.enum(["number", "integer"]),
        title: a.optional(a.string()),
        description: a.optional(a.string()),
        minimum: a.optional(a.number()),
        maximum: a.optional(a.number())
    }).passthrough()
      , xl = a.object({
        type: a.literal("string"),
        title: a.optional(a.string()),
        description: a.optional(a.string()),
        enum: a.array(a.string()),
        enumNames: a.optional(a.array(a.string()))
    }).passthrough()
      , _l = a.union([bl, Sl, El, xl])
      , Tl = it.extend({
        method: a.literal("elicitation/create"),
        params: St.extend({
            message: a.string(),
            requestedSchema: a.object({
                type: a.literal("object"),
                properties: a.record(a.string(), _l),
                required: a.optional(a.array(a.string()))
            }).passthrough()
        })
    })
      , ea = yt.extend({
        action: a.enum(["accept", "decline", "cancel"]),
        content: a.optional(a.record(a.string(), a.unknown()))
    })
      , ta = a.object({
        type: a.literal("ref/resource"),
        uri: a.string()
    }).passthrough()
      , lp = ta
      , Pl = a.object({
        type: a.literal("ref/prompt"),
        name: a.string()
    }).passthrough()
      , Po = it.extend({
        method: a.literal("completion/complete"),
        params: St.extend({
            ref: a.union([Pl, ta]),
            argument: a.object({
                name: a.string(),
                value: a.string()
            }).passthrough(),
            context: a.optional(a.object({
                arguments: a.optional(a.record(a.string(), a.string()))
            }))
        })
    })
      , kl = yt.extend({
        completion: a.object({
            values: a.array(a.string()).max(100),
            total: a.optional(a.number().int()),
            hasMore: a.optional(a.boolean())
        }).passthrough()
    })
      , Il = a.object({
        uri: a.string().startsWith("file://"),
        name: a.optional(a.string()),
        _meta: a.optional(a.object({}).passthrough())
    }).passthrough()
      , Cl = it.extend({
        method: a.literal("roots/list")
    })
      , ra = yt.extend({
        roots: a.array(Il)
    })
      , $l = Ot.extend({
        method: a.literal("notifications/roots/list_changed")
    })
      , cp = a.union([ho, mo, Po, gl, bo, wo, fo, yo, vo, Vs, Js, To, _o])
      , dp = a.union([uo, go, po, $l])
      , up = a.union([co, Xs, ea, ra])
      , mp = a.union([ho, wl, Tl, Cl])
      , pp = a.union([uo, go, fl, rl, tl, hl, dl])
      , hp = a.union([co, Ji, kl, cl, sl, Qi, Xi, el, Ks, pl]);
    class Le extends Error {
        constructor(e, r, o) {
            super(`MCP error ${e}: ${r}`),
            this.code = e,
            this.data = o,
            this.name = "McpError"
        }
    }
    const Al = Object.freeze(Object.defineProperty({
        __proto__: null,
        AudioContentSchema: xo,
        BaseMetadataSchema: zr,
        BlobResourceContentsSchema: Zs,
        BooleanSchemaSchema: bl,
        CallToolRequestSchema: To,
        CallToolResultSchema: Ks,
        CancelledNotificationSchema: uo,
        ClientCapabilitiesSchema: Hi,
        ClientNotificationSchema: dp,
        ClientRequestSchema: cp,
        ClientResultSchema: up,
        CompatibilityCallToolResultSchema: ip,
        CompleteRequestSchema: Po,
        CompleteResultSchema: kl,
        ContentBlockSchema: Ys,
        CreateMessageRequestSchema: wl,
        CreateMessageResultSchema: Xs,
        CursorSchema: Ls,
        DEFAULT_NEGOTIATED_PROTOCOL_VERSION: np,
        ElicitRequestSchema: Tl,
        ElicitResultSchema: ea,
        EmbeddedResourceSchema: al,
        EmptyResultSchema: co,
        EnumSchemaSchema: xl,
        get ErrorCode() {
            return Re
        },
        GetPromptRequestSchema: bo,
        GetPromptResultSchema: cl,
        ImageContentSchema: Eo,
        ImplementationSchema: qs,
        InitializeRequestSchema: mo,
        InitializeResultSchema: Ji,
        InitializedNotificationSchema: po,
        JSONRPCErrorSchema: Ws,
        JSONRPCMessageSchema: Zi,
        JSONRPCNotificationSchema: js,
        JSONRPCRequestSchema: Us,
        JSONRPCResponseSchema: Ms,
        JSONRPC_VERSION: In,
        LATEST_PROTOCOL_VERSION: Ds,
        ListPromptsRequestSchema: wo,
        ListPromptsResultSchema: sl,
        ListResourceTemplatesRequestSchema: yo,
        ListResourceTemplatesResultSchema: Xi,
        ListResourcesRequestSchema: fo,
        ListResourcesResultSchema: Qi,
        ListRootsRequestSchema: Cl,
        ListRootsResultSchema: ra,
        ListToolsRequestSchema: _o,
        ListToolsResultSchema: pl,
        LoggingLevelSchema: Qs,
        LoggingMessageNotificationSchema: fl,
        McpError: Le,
        ModelHintSchema: yl,
        ModelPreferencesSchema: vl,
        NotificationSchema: Ot,
        NumberSchemaSchema: El,
        PaginatedRequestSchema: An,
        PaginatedResultSchema: Rn,
        PingRequestSchema: ho,
        PrimitiveSchemaDefinitionSchema: _l,
        ProgressNotificationSchema: go,
        ProgressSchema: Yi,
        ProgressTokenSchema: Ns,
        PromptArgumentSchema: nl,
        PromptListChangedNotificationSchema: dl,
        PromptMessageSchema: ll,
        PromptReferenceSchema: Pl,
        PromptSchema: ol,
        ReadResourceRequestSchema: vo,
        ReadResourceResultSchema: el,
        RequestIdSchema: $n,
        RequestSchema: it,
        ResourceContentsSchema: Gs,
        ResourceLinkSchema: il,
        ResourceListChangedNotificationSchema: tl,
        ResourceReferenceSchema: lp,
        ResourceSchema: Hs,
        ResourceTemplateReferenceSchema: ta,
        ResourceTemplateSchema: Ki,
        ResourceUpdatedNotificationSchema: rl,
        ResultSchema: yt,
        RootSchema: Il,
        RootsListChangedNotificationSchema: $l,
        SUPPORTED_PROTOCOL_VERSIONS: qi,
        SamplingMessageSchema: Pr,
        ServerCapabilitiesSchema: Vi,
        ServerNotificationSchema: pp,
        ServerRequestSchema: mp,
        ServerResultSchema: hp,
        SetLevelRequestSchema: gl,
        StringSchemaSchema: Sl,
        SubscribeRequestSchema: Vs,
        TextContentSchema: So,
        TextResourceContentsSchema: Bs,
        ToolAnnotationsSchema: ul,
        ToolListChangedNotificationSchema: hl,
        ToolSchema: ml,
        UnsubscribeRequestSchema: Js,
        isInitializeRequest: sp,
        isInitializedNotification: ap,
        isJSONRPCError: zi,
        isJSONRPCNotification: Bi,
        isJSONRPCRequest: Gi,
        isJSONRPCResponse: Fs
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , gp = 6e4;
    class fp {
        constructor(e) {
            this._options = e,
            this._requestMessageId = 0,
            this._requestHandlers = new Map,
            this._requestHandlerAbortControllers = new Map,
            this._notificationHandlers = new Map,
            this._responseHandlers = new Map,
            this._progressHandlers = new Map,
            this._timeoutInfo = new Map,
            this._pendingDebouncedNotifications = new Set,
            this.setNotificationHandler(uo, r => {
                const o = this._requestHandlerAbortControllers.get(r.params.requestId);
                o == null || o.abort(r.params.reason)
            }
            ),
            this.setNotificationHandler(go, r => {
                this._onprogress(r)
            }
            ),
            this.setRequestHandler(ho, r => ({}))
        }
        _setupTimeout(e, r, o, n, s=!1) {
            this._timeoutInfo.set(e, {
                timeoutId: setTimeout(n, r),
                startTime: Date.now(),
                timeout: r,
                maxTotalTimeout: o,
                resetTimeoutOnProgress: s,
                onTimeout: n
            })
        }
        _resetTimeout(e) {
            const r = this._timeoutInfo.get(e);
            if (!r)
                return !1;
            const o = Date.now() - r.startTime;
            if (r.maxTotalTimeout && o >= r.maxTotalTimeout)
                throw this._timeoutInfo.delete(e),
                new Le(Re.RequestTimeout,"Maximum total timeout exceeded",{
                    maxTotalTimeout: r.maxTotalTimeout,
                    totalElapsed: o
                });
            return clearTimeout(r.timeoutId),
            r.timeoutId = setTimeout(r.onTimeout, r.timeout),
            !0
        }
        _cleanupTimeout(e) {
            const r = this._timeoutInfo.get(e);
            r && (clearTimeout(r.timeoutId),
            this._timeoutInfo.delete(e))
        }
        async connect(e) {
            var r, o, n;
            this._transport = e;
            const s = (r = this.transport) === null || r === void 0 ? void 0 : r.onclose;
            this._transport.onclose = () => {
                s == null || s(),
                this._onclose()
            }
            ;
            const i = (o = this.transport) === null || o === void 0 ? void 0 : o.onerror;
            this._transport.onerror = d => {
                i == null || i(d),
                this._onerror(d)
            }
            ;
            const l = (n = this._transport) === null || n === void 0 ? void 0 : n.onmessage;
            this._transport.onmessage = (d, u) => {
                l == null || l(d, u),
                Fs(d) || zi(d) ? this._onresponse(d) : Gi(d) ? this._onrequest(d, u) : Bi(d) ? this._onnotification(d) : this._onerror(new Error(`Unknown message type: ${JSON.stringify(d)}`))
            }
            ,
            await this._transport.start()
        }
        _onclose() {
            var e;
            const r = this._responseHandlers;
            this._responseHandlers = new Map,
            this._progressHandlers.clear(),
            this._pendingDebouncedNotifications.clear(),
            this._transport = void 0,
            (e = this.onclose) === null || e === void 0 || e.call(this);
            const o = new Le(Re.ConnectionClosed,"Connection closed");
            for (const n of r.values())
                n(o)
        }
        _onerror(e) {
            var r;
            (r = this.onerror) === null || r === void 0 || r.call(this, e)
        }
        _onnotification(e) {
            var r;
            const o = (r = this._notificationHandlers.get(e.method)) !== null && r !== void 0 ? r : this.fallbackNotificationHandler;
            o !== void 0 && Promise.resolve().then( () => o(e)).catch(n => this._onerror(new Error(`Uncaught error in notification handler: ${n}`)))
        }
        _onrequest(e, r) {
            var o, n;
            const s = (o = this._requestHandlers.get(e.method)) !== null && o !== void 0 ? o : this.fallbackRequestHandler
              , i = this._transport;
            if (s === void 0) {
                i == null || i.send({
                    jsonrpc: "2.0",
                    id: e.id,
                    error: {
                        code: Re.MethodNotFound,
                        message: "Method not found"
                    }
                }).catch(u => this._onerror(new Error(`Failed to send an error response: ${u}`)));
                return
            }
            const l = new AbortController;
            this._requestHandlerAbortControllers.set(e.id, l);
            const d = {
                signal: l.signal,
                sessionId: i == null ? void 0 : i.sessionId,
                _meta: (n = e.params) === null || n === void 0 ? void 0 : n._meta,
                sendNotification: u => this.notification(u, {
                    relatedRequestId: e.id
                }),
                sendRequest: (u, g, c) => this.request(u, g, {
                    ...c,
                    relatedRequestId: e.id
                }),
                authInfo: r == null ? void 0 : r.authInfo,
                requestId: e.id,
                requestInfo: r == null ? void 0 : r.requestInfo
            };
            Promise.resolve().then( () => s(e, d)).then(u => {
                if (!l.signal.aborted)
                    return i == null ? void 0 : i.send({
                        result: u,
                        jsonrpc: "2.0",
                        id: e.id
                    })
            }
            , u => {
                var g;
                if (!l.signal.aborted)
                    return i == null ? void 0 : i.send({
                        jsonrpc: "2.0",
                        id: e.id,
                        error: {
                            code: Number.isSafeInteger(u.code) ? u.code : Re.InternalError,
                            message: (g = u.message) !== null && g !== void 0 ? g : "Internal error"
                        }
                    })
            }
            ).catch(u => this._onerror(new Error(`Failed to send response: ${u}`))).finally( () => {
                this._requestHandlerAbortControllers.delete(e.id)
            }
            )
        }
        _onprogress(e) {
            const {progressToken: r, ...o} = e.params
              , n = Number(r)
              , s = this._progressHandlers.get(n);
            if (!s) {
                this._onerror(new Error(`Received a progress notification for an unknown token: ${JSON.stringify(e)}`));
                return
            }
            const i = this._responseHandlers.get(n)
              , l = this._timeoutInfo.get(n);
            if (l && i && l.resetTimeoutOnProgress)
                try {
                    this._resetTimeout(n)
                } catch (d) {
                    i(d);
                    return
                }
            s(o)
        }
        _onresponse(e) {
            const r = Number(e.id)
              , o = this._responseHandlers.get(r);
            if (o === void 0) {
                this._onerror(new Error(`Received a response for an unknown message ID: ${JSON.stringify(e)}`));
                return
            }
            if (this._responseHandlers.delete(r),
            this._progressHandlers.delete(r),
            this._cleanupTimeout(r),
            Fs(e))
                o(e);
            else {
                const n = new Le(e.error.code,e.error.message,e.error.data);
                o(n)
            }
        }
        get transport() {
            return this._transport
        }
        async close() {
            var e;
            await ((e = this._transport) === null || e === void 0 ? void 0 : e.close())
        }
        request(e, r, o) {
            const {relatedRequestId: n, resumptionToken: s, onresumptiontoken: i} = o ?? {};
            return new Promise( (l, d) => {
                var u, g, c, m, p, h;
                if (!this._transport) {
                    d(new Error("Not connected"));
                    return
                }
                ((u = this._options) === null || u === void 0 ? void 0 : u.enforceStrictCapabilities) === !0 && this.assertCapabilityForMethod(e.method),
                (g = o == null ? void 0 : o.signal) === null || g === void 0 || g.throwIfAborted();
                const f = this._requestMessageId++
                  , y = {
                    ...e,
                    jsonrpc: "2.0",
                    id: f
                };
                o != null && o.onprogress && (this._progressHandlers.set(f, o.onprogress),
                y.params = {
                    ...e.params,
                    _meta: {
                        ...((c = e.params) === null || c === void 0 ? void 0 : c._meta) || {},
                        progressToken: f
                    }
                });
                const b = S => {
                    var w;
                    this._responseHandlers.delete(f),
                    this._progressHandlers.delete(f),
                    this._cleanupTimeout(f),
                    (w = this._transport) === null || w === void 0 || w.send({
                        jsonrpc: "2.0",
                        method: "notifications/cancelled",
                        params: {
                            requestId: f,
                            reason: String(S)
                        }
                    }, {
                        relatedRequestId: n,
                        resumptionToken: s,
                        onresumptiontoken: i
                    }).catch(_ => this._onerror(new Error(`Failed to send cancellation: ${_}`))),
                    d(S)
                }
                ;
                this._responseHandlers.set(f, S => {
                    var w;
                    if (!(!((w = o == null ? void 0 : o.signal) === null || w === void 0) && w.aborted)) {
                        if (S instanceof Error)
                            return d(S);
                        try {
                            const _ = r.parse(S.result);
                            l(_)
                        } catch (_) {
                            d(_)
                        }
                    }
                }
                ),
                (m = o == null ? void 0 : o.signal) === null || m === void 0 || m.addEventListener("abort", () => {
                    var S;
                    b((S = o == null ? void 0 : o.signal) === null || S === void 0 ? void 0 : S.reason)
                }
                );
                const x = (p = o == null ? void 0 : o.timeout) !== null && p !== void 0 ? p : gp
                  , v = () => b(new Le(Re.RequestTimeout,"Request timed out",{
                    timeout: x
                }));
                this._setupTimeout(f, x, o == null ? void 0 : o.maxTotalTimeout, v, (h = o == null ? void 0 : o.resetTimeoutOnProgress) !== null && h !== void 0 ? h : !1),
                this._transport.send(y, {
                    relatedRequestId: n,
                    resumptionToken: s,
                    onresumptiontoken: i
                }).catch(S => {
                    this._cleanupTimeout(f),
                    d(S)
                }
                )
            }
            )
        }
        async notification(e, r) {
            var o, n;
            if (!this._transport)
                throw new Error("Not connected");
            if (this.assertNotificationCapability(e.method),
            ((n = (o = this._options) === null || o === void 0 ? void 0 : o.debouncedNotificationMethods) !== null && n !== void 0 ? n : []).includes(e.method) && !e.params && !(r != null && r.relatedRequestId)) {
                if (this._pendingDebouncedNotifications.has(e.method))
                    return;
                this._pendingDebouncedNotifications.add(e.method),
                Promise.resolve().then( () => {
                    var d;
                    if (this._pendingDebouncedNotifications.delete(e.method),
                    !this._transport)
                        return;
                    const u = {
                        ...e,
                        jsonrpc: "2.0"
                    };
                    (d = this._transport) === null || d === void 0 || d.send(u, r).catch(g => this._onerror(g))
                }
                );
                return
            }
            const l = {
                ...e,
                jsonrpc: "2.0"
            };
            await this._transport.send(l, r)
        }
        setRequestHandler(e, r) {
            const o = e.shape.method.value;
            this.assertRequestHandlerCapability(o),
            this._requestHandlers.set(o, (n, s) => Promise.resolve(r(e.parse(n), s)))
        }
        removeRequestHandler(e) {
            this._requestHandlers.delete(e)
        }
        assertCanSetRequestHandler(e) {
            if (this._requestHandlers.has(e))
                throw new Error(`A request handler for ${e} already exists, which would be overridden`)
        }
        setNotificationHandler(e, r) {
            this._notificationHandlers.set(e.shape.method.value, o => Promise.resolve(r(e.parse(o))))
        }
        removeNotificationHandler(e) {
            this._notificationHandlers.delete(e)
        }
    }
    function yp(t, e) {
        return Object.entries(e).reduce( (r, [o,n]) => (n && typeof n == "object" ? r[o] = r[o] ? {
            ...r[o],
            ...n
        } : n : r[o] = n,
        r), {
            ...t
        })
    }
    var vp = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
    function wp(t) {
        return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t
    }
    var na = {
        exports: {}
    };
    /** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
    (function(t, e) {
        (function(r, o) {
            o(e)
        }
        )(vp, function(r) {
            function o() {
                for (var T = arguments.length, E = Array(T), P = 0; P < T; P++)
                    E[P] = arguments[P];
                if (E.length > 1) {
                    E[0] = E[0].slice(0, -1);
                    for (var D = E.length - 1, O = 1; O < D; ++O)
                        E[O] = E[O].slice(1, -1);
                    return E[D] = E[D].slice(1),
                    E.join("")
                } else
                    return E[0]
            }
            function n(T) {
                return "(?:" + T + ")"
            }
            function s(T) {
                return T === void 0 ? "undefined" : T === null ? "null" : Object.prototype.toString.call(T).split(" ").pop().split("]").shift().toLowerCase()
            }
            function i(T) {
                return T.toUpperCase()
            }
            function l(T) {
                return T != null ? T instanceof Array ? T : typeof T.length != "number" || T.split || T.setInterval || T.call ? [T] : Array.prototype.slice.call(T) : []
            }
            function d(T, E) {
                var P = T;
                if (E)
                    for (var D in E)
                        P[D] = E[D];
                return P
            }
            function u(T) {
                var E = "[A-Za-z]"
                  , P = "[0-9]"
                  , D = o(P, "[A-Fa-f]")
                  , O = n(n("%[EFef]" + D + "%" + D + D + "%" + D + D) + "|" + n("%[89A-Fa-f]" + D + "%" + D + D) + "|" + n("%" + D + D))
                  , K = "[\\:\\/\\?\\#\\[\\]\\@]"
                  , X = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]"
                  , fe = o(K, X)
                  , $e = T ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]"
                  , ze = T ? "[\\uE000-\\uF8FF]" : "[]"
                  , he = o(E, P, "[\\-\\.\\_\\~]", $e);
                n(E + o(E, P, "[\\+\\-\\.]") + "*"),
                n(n(O + "|" + o(he, X, "[\\:]")) + "*");
                var Pe = n(n("25[0-5]") + "|" + n("2[0-4]" + P) + "|" + n("1" + P + P) + "|" + n("0?[1-9]" + P) + "|0?0?" + P)
                  , Ze = n(Pe + "\\." + Pe + "\\." + Pe + "\\." + Pe)
                  , ie = n(D + "{1,4}")
                  , De = n(n(ie + "\\:" + ie) + "|" + Ze)
                  , Je = n(n(ie + "\\:") + "{6}" + De)
                  , Ne = n("\\:\\:" + n(ie + "\\:") + "{5}" + De)
                  , Er = n(n(ie) + "?\\:\\:" + n(ie + "\\:") + "{4}" + De)
                  , Ht = n(n(n(ie + "\\:") + "{0,1}" + ie) + "?\\:\\:" + n(ie + "\\:") + "{3}" + De)
                  , Vt = n(n(n(ie + "\\:") + "{0,2}" + ie) + "?\\:\\:" + n(ie + "\\:") + "{2}" + De)
                  , cn = n(n(n(ie + "\\:") + "{0,3}" + ie) + "?\\:\\:" + ie + "\\:" + De)
                  , Lr = n(n(n(ie + "\\:") + "{0,4}" + ie) + "?\\:\\:" + De)
                  , It = n(n(n(ie + "\\:") + "{0,5}" + ie) + "?\\:\\:" + ie)
                  , Jt = n(n(n(ie + "\\:") + "{0,6}" + ie) + "?\\:\\:")
                  , Ur = n([Je, Ne, Er, Ht, Vt, cn, Lr, It, Jt].join("|"))
                  , cr = n(n(he + "|" + O) + "+");
                n("[vV]" + D + "+\\." + o(he, X, "[\\:]") + "+"),
                n(n(O + "|" + o(he, X)) + "*");
                var Qn = n(O + "|" + o(he, X, "[\\:\\@]"));
                return n(n(O + "|" + o(he, X, "[\\@]")) + "+"),
                n(n(Qn + "|" + o("[\\/\\?]", ze)) + "*"),
                {
                    NOT_SCHEME: new RegExp(o("[^]", E, P, "[\\+\\-\\.]"),"g"),
                    NOT_USERINFO: new RegExp(o("[^\\%\\:]", he, X),"g"),
                    NOT_HOST: new RegExp(o("[^\\%\\[\\]\\:]", he, X),"g"),
                    NOT_PATH: new RegExp(o("[^\\%\\/\\:\\@]", he, X),"g"),
                    NOT_PATH_NOSCHEME: new RegExp(o("[^\\%\\/\\@]", he, X),"g"),
                    NOT_QUERY: new RegExp(o("[^\\%]", he, X, "[\\:\\@\\/\\?]", ze),"g"),
                    NOT_FRAGMENT: new RegExp(o("[^\\%]", he, X, "[\\:\\@\\/\\?]"),"g"),
                    ESCAPE: new RegExp(o("[^]", he, X),"g"),
                    UNRESERVED: new RegExp(he,"g"),
                    OTHER_CHARS: new RegExp(o("[^\\%]", he, fe),"g"),
                    PCT_ENCODED: new RegExp(O,"g"),
                    IPV4ADDRESS: new RegExp("^(" + Ze + ")$"),
                    IPV6ADDRESS: new RegExp("^\\[?(" + Ur + ")" + n(n("\\%25|\\%(?!" + D + "{2})") + "(" + cr + ")") + "?\\]?$")
                }
            }
            var g = u(!1)
              , c = u(!0)
              , m = function() {
                function T(E, P) {
                    var D = []
                      , O = !0
                      , K = !1
                      , X = void 0;
                    try {
                        for (var fe = E[Symbol.iterator](), $e; !(O = ($e = fe.next()).done) && (D.push($e.value),
                        !(P && D.length === P)); O = !0)
                            ;
                    } catch (ze) {
                        K = !0,
                        X = ze
                    } finally {
                        try {
                            !O && fe.return && fe.return()
                        } finally {
                            if (K)
                                throw X
                        }
                    }
                    return D
                }
                return function(E, P) {
                    if (Array.isArray(E))
                        return E;
                    if (Symbol.iterator in Object(E))
                        return T(E, P);
                    throw new TypeError("Invalid attempt to destructure non-iterable instance")
                }
            }()
              , p = function(T) {
                if (Array.isArray(T)) {
                    for (var E = 0, P = Array(T.length); E < T.length; E++)
                        P[E] = T[E];
                    return P
                } else
                    return Array.from(T)
            }
              , h = 2147483647
              , f = 36
              , y = 1
              , b = 26
              , x = 38
              , v = 700
              , S = 72
              , w = 128
              , _ = "-"
              , I = /^xn--/
              , k = /[^\0-\x7E]/
              , C = /[\x2E\u3002\uFF0E\uFF61]/g
              , L = {
                overflow: "Overflow: input needs wider integers to process",
                "not-basic": "Illegal input >= 0x80 (not a basic code point)",
                "invalid-input": "Invalid input"
            }
              , N = f - y
              , A = Math.floor
              , $ = String.fromCharCode;
            function R(T) {
                throw new RangeError(L[T])
            }
            function q(T, E) {
                for (var P = [], D = T.length; D--; )
                    P[D] = E(T[D]);
                return P
            }
            function ee(T, E) {
                var P = T.split("@")
                  , D = "";
                P.length > 1 && (D = P[0] + "@",
                T = P[1]),
                T = T.replace(C, ".");
                var O = T.split(".")
                  , K = q(O, E).join(".");
                return D + K
            }
            function ne(T) {
                for (var E = [], P = 0, D = T.length; P < D; ) {
                    var O = T.charCodeAt(P++);
                    if (O >= 55296 && O <= 56319 && P < D) {
                        var K = T.charCodeAt(P++);
                        (K & 64512) == 56320 ? E.push(((O & 1023) << 10) + (K & 1023) + 65536) : (E.push(O),
                        P--)
                    } else
                        E.push(O)
                }
                return E
            }
            var te = function(E) {
                return String.fromCodePoint.apply(String, p(E))
            }
              , re = function(E) {
                return E - 48 < 10 ? E - 22 : E - 65 < 26 ? E - 65 : E - 97 < 26 ? E - 97 : f
            }
              , Q = function(E, P) {
                return E + 22 + 75 * (E < 26) - ((P != 0) << 5)
            }
              , Ie = function(E, P, D) {
                var O = 0;
                for (E = D ? A(E / v) : E >> 1,
                E += A(E / P); E > N * b >> 1; O += f)
                    E = A(E / N);
                return A(O + (N + 1) * E / (E + x))
            }
              , Fe = function(E) {
                var P = []
                  , D = E.length
                  , O = 0
                  , K = w
                  , X = S
                  , fe = E.lastIndexOf(_);
                fe < 0 && (fe = 0);
                for (var $e = 0; $e < fe; ++$e)
                    E.charCodeAt($e) >= 128 && R("not-basic"),
                    P.push(E.charCodeAt($e));
                for (var ze = fe > 0 ? fe + 1 : 0; ze < D; ) {
                    for (var he = O, Pe = 1, Ze = f; ; Ze += f) {
                        ze >= D && R("invalid-input");
                        var ie = re(E.charCodeAt(ze++));
                        (ie >= f || ie > A((h - O) / Pe)) && R("overflow"),
                        O += ie * Pe;
                        var De = Ze <= X ? y : Ze >= X + b ? b : Ze - X;
                        if (ie < De)
                            break;
                        var Je = f - De;
                        Pe > A(h / Je) && R("overflow"),
                        Pe *= Je
                    }
                    var Ne = P.length + 1;
                    X = Ie(O - he, Ne, he == 0),
                    A(O / Ne) > h - K && R("overflow"),
                    K += A(O / Ne),
                    O %= Ne,
                    P.splice(O++, 0, K)
                }
                return String.fromCodePoint.apply(String, P)
            }
              , We = function(E) {
                var P = [];
                E = ne(E);
                var D = E.length
                  , O = w
                  , K = 0
                  , X = S
                  , fe = !0
                  , $e = !1
                  , ze = void 0;
                try {
                    for (var he = E[Symbol.iterator](), Pe; !(fe = (Pe = he.next()).done); fe = !0) {
                        var Ze = Pe.value;
                        Ze < 128 && P.push($(Ze))
                    }
                } catch (Xn) {
                    $e = !0,
                    ze = Xn
                } finally {
                    try {
                        !fe && he.return && he.return()
                    } finally {
                        if ($e)
                            throw ze
                    }
                }
                var ie = P.length
                  , De = ie;
                for (ie && P.push(_); De < D; ) {
                    var Je = h
                      , Ne = !0
                      , Er = !1
                      , Ht = void 0;
                    try {
                        for (var Vt = E[Symbol.iterator](), cn; !(Ne = (cn = Vt.next()).done); Ne = !0) {
                            var Lr = cn.value;
                            Lr >= O && Lr < Je && (Je = Lr)
                        }
                    } catch (Xn) {
                        Er = !0,
                        Ht = Xn
                    } finally {
                        try {
                            !Ne && Vt.return && Vt.return()
                        } finally {
                            if (Er)
                                throw Ht
                        }
                    }
                    var It = De + 1;
                    Je - O > A((h - K) / It) && R("overflow"),
                    K += (Je - O) * It,
                    O = Je;
                    var Jt = !0
                      , Ur = !1
                      , cr = void 0;
                    try {
                        for (var Qn = E[Symbol.iterator](), Bu; !(Jt = (Bu = Qn.next()).done); Jt = !0) {
                            var zu = Bu.value;
                            if (zu < O && ++K > h && R("overflow"),
                            zu == O) {
                                for (var _s = K, Ts = f; ; Ts += f) {
                                    var Ps = Ts <= X ? y : Ts >= X + b ? b : Ts - X;
                                    if (_s < Ps)
                                        break;
                                    var Zu = _s - Ps
                                      , Hu = f - Ps;
                                    P.push($(Q(Ps + Zu % Hu, 0))),
                                    _s = A(Zu / Hu)
                                }
                                P.push($(Q(_s, 0))),
                                X = Ie(K, It, De == ie),
                                K = 0,
                                ++De
                            }
                        }
                    } catch (Xn) {
                        Ur = !0,
                        cr = Xn
                    } finally {
                        try {
                            !Jt && Qn.return && Qn.return()
                        } finally {
                            if (Ur)
                                throw cr
                        }
                    }
                    ++K,
                    ++O
                }
                return P.join("")
            }
              , ve = function(E) {
                return ee(E, function(P) {
                    return I.test(P) ? Fe(P.slice(4).toLowerCase()) : P
                })
            }
              , qe = function(E) {
                return ee(E, function(P) {
                    return k.test(P) ? "xn--" + We(P) : P
                })
            }
              , Ke = {
                version: "2.1.0",
                ucs2: {
                    decode: ne,
                    encode: te
                },
                decode: Fe,
                encode: We,
                toASCII: qe,
                toUnicode: ve
            }
              , Te = {};
            function Ve(T) {
                var E = T.charCodeAt(0)
                  , P = void 0;
                return E < 16 ? P = "%0" + E.toString(16).toUpperCase() : E < 128 ? P = "%" + E.toString(16).toUpperCase() : E < 2048 ? P = "%" + (E >> 6 | 192).toString(16).toUpperCase() + "%" + (E & 63 | 128).toString(16).toUpperCase() : P = "%" + (E >> 12 | 224).toString(16).toUpperCase() + "%" + (E >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (E & 63 | 128).toString(16).toUpperCase(),
                P
            }
            function rt(T) {
                for (var E = "", P = 0, D = T.length; P < D; ) {
                    var O = parseInt(T.substr(P + 1, 2), 16);
                    if (O < 128)
                        E += String.fromCharCode(O),
                        P += 3;
                    else if (O >= 194 && O < 224) {
                        if (D - P >= 6) {
                            var K = parseInt(T.substr(P + 4, 2), 16);
                            E += String.fromCharCode((O & 31) << 6 | K & 63)
                        } else
                            E += T.substr(P, 6);
                        P += 6
                    } else if (O >= 224) {
                        if (D - P >= 9) {
                            var X = parseInt(T.substr(P + 4, 2), 16)
                              , fe = parseInt(T.substr(P + 7, 2), 16);
                            E += String.fromCharCode((O & 15) << 12 | (X & 63) << 6 | fe & 63)
                        } else
                            E += T.substr(P, 9);
                        P += 9
                    } else
                        E += T.substr(P, 3),
                        P += 3
                }
                return E
            }
            function Ge(T, E) {
                function P(D) {
                    var O = rt(D);
                    return O.match(E.UNRESERVED) ? O : D
                }
                return T.scheme && (T.scheme = String(T.scheme).replace(E.PCT_ENCODED, P).toLowerCase().replace(E.NOT_SCHEME, "")),
                T.userinfo !== void 0 && (T.userinfo = String(T.userinfo).replace(E.PCT_ENCODED, P).replace(E.NOT_USERINFO, Ve).replace(E.PCT_ENCODED, i)),
                T.host !== void 0 && (T.host = String(T.host).replace(E.PCT_ENCODED, P).toLowerCase().replace(E.NOT_HOST, Ve).replace(E.PCT_ENCODED, i)),
                T.path !== void 0 && (T.path = String(T.path).replace(E.PCT_ENCODED, P).replace(T.scheme ? E.NOT_PATH : E.NOT_PATH_NOSCHEME, Ve).replace(E.PCT_ENCODED, i)),
                T.query !== void 0 && (T.query = String(T.query).replace(E.PCT_ENCODED, P).replace(E.NOT_QUERY, Ve).replace(E.PCT_ENCODED, i)),
                T.fragment !== void 0 && (T.fragment = String(T.fragment).replace(E.PCT_ENCODED, P).replace(E.NOT_FRAGMENT, Ve).replace(E.PCT_ENCODED, i)),
                T
            }
            function Ce(T) {
                return T.replace(/^0*(.*)/, "$1") || "0"
            }
            function Ut(T, E) {
                var P = T.match(E.IPV4ADDRESS) || []
                  , D = m(P, 2)
                  , O = D[1];
                return O ? O.split(".").map(Ce).join(".") : T
            }
            function Qe(T, E) {
                var P = T.match(E.IPV6ADDRESS) || []
                  , D = m(P, 3)
                  , O = D[1]
                  , K = D[2];
                if (O) {
                    for (var X = O.toLowerCase().split("::").reverse(), fe = m(X, 2), $e = fe[0], ze = fe[1], he = ze ? ze.split(":").map(Ce) : [], Pe = $e.split(":").map(Ce), Ze = E.IPV4ADDRESS.test(Pe[Pe.length - 1]), ie = Ze ? 7 : 8, De = Pe.length - ie, Je = Array(ie), Ne = 0; Ne < ie; ++Ne)
                        Je[Ne] = he[Ne] || Pe[De + Ne] || "";
                    Ze && (Je[ie - 1] = Ut(Je[ie - 1], E));
                    var Er = Je.reduce(function(It, Jt, Ur) {
                        if (!Jt || Jt === "0") {
                            var cr = It[It.length - 1];
                            cr && cr.index + cr.length === Ur ? cr.length++ : It.push({
                                index: Ur,
                                length: 1
                            })
                        }
                        return It
                    }, [])
                      , Ht = Er.sort(function(It, Jt) {
                        return Jt.length - It.length
                    })[0]
                      , Vt = void 0;
                    if (Ht && Ht.length > 1) {
                        var cn = Je.slice(0, Ht.index)
                          , Lr = Je.slice(Ht.index + Ht.length);
                        Vt = cn.join(":") + "::" + Lr.join(":")
                    } else
                        Vt = Je.join(":");
                    return K && (Vt += "%" + K),
                    Vt
                } else
                    return T
            }
            var Oe = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i
              , br = "".match(/(){0}/)[1] === void 0;
            function st(T) {
                var E = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
                  , P = {}
                  , D = E.iri !== !1 ? c : g;
                E.reference === "suffix" && (T = (E.scheme ? E.scheme + ":" : "") + "//" + T);
                var O = T.match(Oe);
                if (O) {
                    br ? (P.scheme = O[1],
                    P.userinfo = O[3],
                    P.host = O[4],
                    P.port = parseInt(O[5], 10),
                    P.path = O[6] || "",
                    P.query = O[7],
                    P.fragment = O[8],
                    isNaN(P.port) && (P.port = O[5])) : (P.scheme = O[1] || void 0,
                    P.userinfo = T.indexOf("@") !== -1 ? O[3] : void 0,
                    P.host = T.indexOf("//") !== -1 ? O[4] : void 0,
                    P.port = parseInt(O[5], 10),
                    P.path = O[6] || "",
                    P.query = T.indexOf("?") !== -1 ? O[7] : void 0,
                    P.fragment = T.indexOf("#") !== -1 ? O[8] : void 0,
                    isNaN(P.port) && (P.port = T.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? O[4] : void 0)),
                    P.host && (P.host = Qe(Ut(P.host, D), D)),
                    P.scheme === void 0 && P.userinfo === void 0 && P.host === void 0 && P.port === void 0 && !P.path && P.query === void 0 ? P.reference = "same-document" : P.scheme === void 0 ? P.reference = "relative" : P.fragment === void 0 ? P.reference = "absolute" : P.reference = "uri",
                    E.reference && E.reference !== "suffix" && E.reference !== P.reference && (P.error = P.error || "URI is not a " + E.reference + " reference.");
                    var K = Te[(E.scheme || P.scheme || "").toLowerCase()];
                    if (!E.unicodeSupport && (!K || !K.unicodeSupport)) {
                        if (P.host && (E.domainHost || K && K.domainHost))
                            try {
                                P.host = Ke.toASCII(P.host.replace(D.PCT_ENCODED, rt).toLowerCase())
                            } catch (X) {
                                P.error = P.error || "Host's domain name can not be converted to ASCII via punycode: " + X
                            }
                        Ge(P, g)
                    } else
                        Ge(P, D);
                    K && K.parse && K.parse(P, E)
                } else
                    P.error = P.error || "URI can not be parsed.";
                return P
            }
            function an(T, E) {
                var P = E.iri !== !1 ? c : g
                  , D = [];
                return T.userinfo !== void 0 && (D.push(T.userinfo),
                D.push("@")),
                T.host !== void 0 && D.push(Qe(Ut(String(T.host), P), P).replace(P.IPV6ADDRESS, function(O, K, X) {
                    return "[" + K + (X ? "%25" + X : "") + "]"
                })),
                (typeof T.port == "number" || typeof T.port == "string") && (D.push(":"),
                D.push(String(T.port))),
                D.length ? D.join("") : void 0
            }
            var Nr = /^\.\.?\//
              , nt = /^\/\.(\/|$)/
              , Sr = /^\/\.\.(\/|$)/
              , Jn = /^\/?(?:.|\n)*?(?=\/|$)/;
            function Xe(T) {
                for (var E = []; T.length; )
                    if (T.match(Nr))
                        T = T.replace(Nr, "");
                    else if (T.match(nt))
                        T = T.replace(nt, "/");
                    else if (T.match(Sr))
                        T = T.replace(Sr, "/"),
                        E.pop();
                    else if (T === "." || T === "..")
                        T = "";
                    else {
                        var P = T.match(Jn);
                        if (P) {
                            var D = P[0];
                            T = T.slice(D.length),
                            E.push(D)
                        } else
                            throw new Error("Unexpected dot segment condition")
                    }
                return E.join("")
            }
            function et(T) {
                var E = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
                  , P = E.iri ? c : g
                  , D = []
                  , O = Te[(E.scheme || T.scheme || "").toLowerCase()];
                if (O && O.serialize && O.serialize(T, E),
                T.host && !P.IPV6ADDRESS.test(T.host)) {
                    if (E.domainHost || O && O.domainHost)
                        try {
                            T.host = E.iri ? Ke.toUnicode(T.host) : Ke.toASCII(T.host.replace(P.PCT_ENCODED, rt).toLowerCase())
                        } catch (fe) {
                            T.error = T.error || "Host's domain name can not be converted to " + (E.iri ? "Unicode" : "ASCII") + " via punycode: " + fe
                        }
                }
                Ge(T, P),
                E.reference !== "suffix" && T.scheme && (D.push(T.scheme),
                D.push(":"));
                var K = an(T, E);
                if (K !== void 0 && (E.reference !== "suffix" && D.push("//"),
                D.push(K),
                T.path && T.path.charAt(0) !== "/" && D.push("/")),
                T.path !== void 0) {
                    var X = T.path;
                    !E.absolutePath && (!O || !O.absolutePath) && (X = Xe(X)),
                    K === void 0 && (X = X.replace(/^\/\//, "/%2F")),
                    D.push(X)
                }
                return T.query !== void 0 && (D.push("?"),
                D.push(T.query)),
                T.fragment !== void 0 && (D.push("#"),
                D.push(T.fragment)),
                D.join("")
            }
            function ft(T, E) {
                var P = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}
                  , D = arguments[3]
                  , O = {};
                return D || (T = st(et(T, P), P),
                E = st(et(E, P), P)),
                P = P || {},
                !P.tolerant && E.scheme ? (O.scheme = E.scheme,
                O.userinfo = E.userinfo,
                O.host = E.host,
                O.port = E.port,
                O.path = Xe(E.path || ""),
                O.query = E.query) : (E.userinfo !== void 0 || E.host !== void 0 || E.port !== void 0 ? (O.userinfo = E.userinfo,
                O.host = E.host,
                O.port = E.port,
                O.path = Xe(E.path || ""),
                O.query = E.query) : (E.path ? (E.path.charAt(0) === "/" ? O.path = Xe(E.path) : ((T.userinfo !== void 0 || T.host !== void 0 || T.port !== void 0) && !T.path ? O.path = "/" + E.path : T.path ? O.path = T.path.slice(0, T.path.lastIndexOf("/") + 1) + E.path : O.path = E.path,
                O.path = Xe(O.path)),
                O.query = E.query) : (O.path = T.path,
                E.query !== void 0 ? O.query = E.query : O.query = T.query),
                O.userinfo = T.userinfo,
                O.host = T.host,
                O.port = T.port),
                O.scheme = T.scheme),
                O.fragment = E.fragment,
                O
            }
            function xs(T, E, P) {
                var D = d({
                    scheme: "null"
                }, P);
                return et(ft(st(T, D), st(E, D), D, !0), D)
            }
            function wi(T, E) {
                return typeof T == "string" ? T = et(st(T, E), E) : s(T) === "object" && (T = st(et(T, E), E)),
                T
            }
            function bi(T, E, P) {
                return typeof T == "string" ? T = et(st(T, P), P) : s(T) === "object" && (T = et(T, P)),
                typeof E == "string" ? E = et(st(E, P), P) : s(E) === "object" && (E = et(E, P)),
                T === E
            }
            function Ax(T, E) {
                return T && T.toString().replace(!E || !E.iri ? g.ESCAPE : c.ESCAPE, Ve)
            }
            function lr(T, E) {
                return T && T.toString().replace(!E || !E.iri ? g.PCT_ENCODED : c.PCT_ENCODED, rt)
            }
            var Yn = {
                scheme: "http",
                domainHost: !0,
                parse: function(E, P) {
                    return E.host || (E.error = E.error || "HTTP URIs must have a host."),
                    E
                },
                serialize: function(E, P) {
                    var D = String(E.scheme).toLowerCase() === "https";
                    return (E.port === (D ? 443 : 80) || E.port === "") && (E.port = void 0),
                    E.path || (E.path = "/"),
                    E
                }
            }
              , Lu = {
                scheme: "https",
                domainHost: Yn.domainHost,
                parse: Yn.parse,
                serialize: Yn.serialize
            };
            function Uu(T) {
                return typeof T.secure == "boolean" ? T.secure : String(T.scheme).toLowerCase() === "wss"
            }
            var Kn = {
                scheme: "ws",
                domainHost: !0,
                parse: function(E, P) {
                    var D = E;
                    return D.secure = Uu(D),
                    D.resourceName = (D.path || "/") + (D.query ? "?" + D.query : ""),
                    D.path = void 0,
                    D.query = void 0,
                    D
                },
                serialize: function(E, P) {
                    if ((E.port === (Uu(E) ? 443 : 80) || E.port === "") && (E.port = void 0),
                    typeof E.secure == "boolean" && (E.scheme = E.secure ? "wss" : "ws",
                    E.secure = void 0),
                    E.resourceName) {
                        var D = E.resourceName.split("?")
                          , O = m(D, 2)
                          , K = O[0]
                          , X = O[1];
                        E.path = K && K !== "/" ? K : void 0,
                        E.query = X,
                        E.resourceName = void 0
                    }
                    return E.fragment = void 0,
                    E
                }
            }
              , ju = {
                scheme: "wss",
                domainHost: Kn.domainHost,
                parse: Kn.parse,
                serialize: Kn.serialize
            }
              , Rx = {}
              , Mu = "[A-Za-z0-9\\-\\.\\_\\~\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]"
              , Zt = "[0-9A-Fa-f]"
              , Ox = n(n("%[EFef]" + Zt + "%" + Zt + Zt + "%" + Zt + Zt) + "|" + n("%[89A-Fa-f]" + Zt + "%" + Zt + Zt) + "|" + n("%" + Zt + Zt))
              , Dx = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]"
              , Nx = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]"
              , Lx = o(Nx, '[\\"\\\\]')
              , Ux = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]"
              , jx = new RegExp(Mu,"g")
              , ln = new RegExp(Ox,"g")
              , Mx = new RegExp(o("[^]", Dx, "[\\.]", '[\\"]', Lx),"g")
              , Fu = new RegExp(o("[^]", Mu, Ux),"g")
              , Fx = Fu;
            function Si(T) {
                var E = rt(T);
                return E.match(jx) ? E : T
            }
            var Wu = {
                scheme: "mailto",
                parse: function(E, P) {
                    var D = E
                      , O = D.to = D.path ? D.path.split(",") : [];
                    if (D.path = void 0,
                    D.query) {
                        for (var K = !1, X = {}, fe = D.query.split("&"), $e = 0, ze = fe.length; $e < ze; ++$e) {
                            var he = fe[$e].split("=");
                            switch (he[0]) {
                            case "to":
                                for (var Pe = he[1].split(","), Ze = 0, ie = Pe.length; Ze < ie; ++Ze)
                                    O.push(Pe[Ze]);
                                break;
                            case "subject":
                                D.subject = lr(he[1], P);
                                break;
                            case "body":
                                D.body = lr(he[1], P);
                                break;
                            default:
                                K = !0,
                                X[lr(he[0], P)] = lr(he[1], P);
                                break
                            }
                        }
                        K && (D.headers = X)
                    }
                    D.query = void 0;
                    for (var De = 0, Je = O.length; De < Je; ++De) {
                        var Ne = O[De].split("@");
                        if (Ne[0] = lr(Ne[0]),
                        P.unicodeSupport)
                            Ne[1] = lr(Ne[1], P).toLowerCase();
                        else
                            try {
                                Ne[1] = Ke.toASCII(lr(Ne[1], P).toLowerCase())
                            } catch (Er) {
                                D.error = D.error || "Email address's domain name can not be converted to ASCII via punycode: " + Er
                            }
                        O[De] = Ne.join("@")
                    }
                    return D
                },
                serialize: function(E, P) {
                    var D = E
                      , O = l(E.to);
                    if (O) {
                        for (var K = 0, X = O.length; K < X; ++K) {
                            var fe = String(O[K])
                              , $e = fe.lastIndexOf("@")
                              , ze = fe.slice(0, $e).replace(ln, Si).replace(ln, i).replace(Mx, Ve)
                              , he = fe.slice($e + 1);
                            try {
                                he = P.iri ? Ke.toUnicode(he) : Ke.toASCII(lr(he, P).toLowerCase())
                            } catch (De) {
                                D.error = D.error || "Email address's domain name can not be converted to " + (P.iri ? "Unicode" : "ASCII") + " via punycode: " + De
                            }
                            O[K] = ze + "@" + he
                        }
                        D.path = O.join(",")
                    }
                    var Pe = E.headers = E.headers || {};
                    E.subject && (Pe.subject = E.subject),
                    E.body && (Pe.body = E.body);
                    var Ze = [];
                    for (var ie in Pe)
                        Pe[ie] !== Rx[ie] && Ze.push(ie.replace(ln, Si).replace(ln, i).replace(Fu, Ve) + "=" + Pe[ie].replace(ln, Si).replace(ln, i).replace(Fx, Ve));
                    return Ze.length && (D.query = Ze.join("&")),
                    D
                }
            }
              , Wx = /^([^\:]+)\:(.*)/
              , qu = {
                scheme: "urn",
                parse: function(E, P) {
                    var D = E.path && E.path.match(Wx)
                      , O = E;
                    if (D) {
                        var K = P.scheme || O.scheme || "urn"
                          , X = D[1].toLowerCase()
                          , fe = D[2]
                          , $e = K + ":" + (P.nid || X)
                          , ze = Te[$e];
                        O.nid = X,
                        O.nss = fe,
                        O.path = void 0,
                        ze && (O = ze.parse(O, P))
                    } else
                        O.error = O.error || "URN can not be parsed.";
                    return O
                },
                serialize: function(E, P) {
                    var D = P.scheme || E.scheme || "urn"
                      , O = E.nid
                      , K = D + ":" + (P.nid || O)
                      , X = Te[K];
                    X && (E = X.serialize(E, P));
                    var fe = E
                      , $e = E.nss;
                    return fe.path = (O || P.nid) + ":" + $e,
                    fe
                }
            }
              , qx = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/
              , Gu = {
                scheme: "urn:uuid",
                parse: function(E, P) {
                    var D = E;
                    return D.uuid = D.nss,
                    D.nss = void 0,
                    !P.tolerant && (!D.uuid || !D.uuid.match(qx)) && (D.error = D.error || "UUID is not valid."),
                    D
                },
                serialize: function(E, P) {
                    var D = E;
                    return D.nss = (E.uuid || "").toLowerCase(),
                    D
                }
            };
            Te[Yn.scheme] = Yn,
            Te[Lu.scheme] = Lu,
            Te[Kn.scheme] = Kn,
            Te[ju.scheme] = ju,
            Te[Wu.scheme] = Wu,
            Te[qu.scheme] = qu,
            Te[Gu.scheme] = Gu,
            r.SCHEMES = Te,
            r.pctEncChar = Ve,
            r.pctDecChars = rt,
            r.parse = st,
            r.removeDotSegments = Xe,
            r.serialize = et,
            r.resolveComponents = ft,
            r.resolve = xs,
            r.normalize = wi,
            r.equal = bi,
            r.escapeComponent = Ax,
            r.unescapeComponent = lr,
            Object.defineProperty(r, "__esModule", {
                value: !0
            })
        })
    }
    )(na, na.exports);
    var bp = na.exports
      , oa = function t(e, r) {
        if (e === r)
            return !0;
        if (e && r && typeof e == "object" && typeof r == "object") {
            if (e.constructor !== r.constructor)
                return !1;
            var o, n, s;
            if (Array.isArray(e)) {
                if (o = e.length,
                o != r.length)
                    return !1;
                for (n = o; n-- !== 0; )
                    if (!t(e[n], r[n]))
                        return !1;
                return !0
            }
            if (e.constructor === RegExp)
                return e.source === r.source && e.flags === r.flags;
            if (e.valueOf !== Object.prototype.valueOf)
                return e.valueOf() === r.valueOf();
            if (e.toString !== Object.prototype.toString)
                return e.toString() === r.toString();
            if (s = Object.keys(e),
            o = s.length,
            o !== Object.keys(r).length)
                return !1;
            for (n = o; n-- !== 0; )
                if (!Object.prototype.hasOwnProperty.call(r, s[n]))
                    return !1;
            for (n = o; n-- !== 0; ) {
                var i = s[n];
                if (!t(e[i], r[i]))
                    return !1
            }
            return !0
        }
        return e !== e && r !== r
    }
      , Sp = function(e) {
        for (var r = 0, o = e.length, n = 0, s; n < o; )
            r++,
            s = e.charCodeAt(n++),
            s >= 55296 && s <= 56319 && n < o && (s = e.charCodeAt(n),
            (s & 64512) == 56320 && n++);
        return r
    }
      , Zr = {
        copy: Ep,
        checkDataType: sa,
        checkDataTypes: xp,
        coerceToTypes: _p,
        toHash: aa,
        getProperty: ia,
        escapeQuotes: la,
        equal: oa,
        ucs2length: Sp,
        varOccurences: kp,
        varReplace: Ip,
        schemaHasRules: Cp,
        schemaHasRulesExcept: $p,
        schemaUnknownRules: Ap,
        toQuotedString: ca,
        getPathExpr: Rp,
        getPath: Op,
        getData: Lp,
        unescapeFragment: Up,
        unescapeJsonPointer: ua,
        escapeFragment: jp,
        escapeJsonPointer: da
    };
    function Ep(t, e) {
        e = e || {};
        for (var r in t)
            e[r] = t[r];
        return e
    }
    function sa(t, e, r, o) {
        var n = o ? " !== " : " === "
          , s = o ? " || " : " && "
          , i = o ? "!" : ""
          , l = o ? "" : "!";
        switch (t) {
        case "null":
            return e + n + "null";
        case "array":
            return i + "Array.isArray(" + e + ")";
        case "object":
            return "(" + i + e + s + "typeof " + e + n + '"object"' + s + l + "Array.isArray(" + e + "))";
        case "integer":
            return "(typeof " + e + n + '"number"' + s + l + "(" + e + " % 1)" + s + e + n + e + (r ? s + i + "isFinite(" + e + ")" : "") + ")";
        case "number":
            return "(typeof " + e + n + '"' + t + '"' + (r ? s + i + "isFinite(" + e + ")" : "") + ")";
        default:
            return "typeof " + e + n + '"' + t + '"'
        }
    }
    function xp(t, e, r) {
        switch (t.length) {
        case 1:
            return sa(t[0], e, r, !0);
        default:
            var o = ""
              , n = aa(t);
            n.array && n.object && (o = n.null ? "(" : "(!" + e + " || ",
            o += "typeof " + e + ' !== "object")',
            delete n.null,
            delete n.array,
            delete n.object),
            n.number && delete n.integer;
            for (var s in n)
                o += (o ? " && " : "") + sa(s, e, r, !0);
            return o
        }
    }
    var Rl = aa(["string", "number", "integer", "boolean", "null"]);
    function _p(t, e) {
        if (Array.isArray(e)) {
            for (var r = [], o = 0; o < e.length; o++) {
                var n = e[o];
                (Rl[n] || t === "array" && n === "array") && (r[r.length] = n)
            }
            if (r.length)
                return r
        } else {
            if (Rl[e])
                return [e];
            if (t === "array" && e === "array")
                return ["array"]
        }
    }
    function aa(t) {
        for (var e = {}, r = 0; r < t.length; r++)
            e[t[r]] = !0;
        return e
    }
    var Tp = /^[a-z$_][a-z$_0-9]*$/i
      , Pp = /'|\\/g;
    function ia(t) {
        return typeof t == "number" ? "[" + t + "]" : Tp.test(t) ? "." + t : "['" + la(t) + "']"
    }
    function la(t) {
        return t.replace(Pp, "\\$&").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\f/g, "\\f").replace(/\t/g, "\\t")
    }
    function kp(t, e) {
        e += "[^0-9]";
        var r = t.match(new RegExp(e,"g"));
        return r ? r.length : 0
    }
    function Ip(t, e, r) {
        return e += "([^0-9])",
        r = r.replace(/\$/g, "$$$$"),
        t.replace(new RegExp(e,"g"), r + "$1")
    }
    function Cp(t, e) {
        if (typeof t == "boolean")
            return !t;
        for (var r in t)
            if (e[r])
                return !0
    }
    function $p(t, e, r) {
        if (typeof t == "boolean")
            return !t && r != "not";
        for (var o in t)
            if (o != r && e[o])
                return !0
    }
    function Ap(t, e) {
        if (typeof t != "boolean") {
            for (var r in t)
                if (!e[r])
                    return r
        }
    }
    function ca(t) {
        return "'" + la(t) + "'"
    }
    function Rp(t, e, r, o) {
        var n = r ? "'/' + " + e + (o ? "" : ".replace(/~/g, '~0').replace(/\\//g, '~1')") : o ? "'[' + " + e + " + ']'" : "'[\\'' + " + e + " + '\\']'";
        return Ol(t, n)
    }
    function Op(t, e, r) {
        var o = ca(r ? "/" + da(e) : ia(e));
        return Ol(t, o)
    }
    var Dp = /^\/(?:[^~]|~0|~1)*$/
      , Np = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function Lp(t, e, r) {
        var o, n, s, i;
        if (t === "")
            return "rootData";
        if (t[0] == "/") {
            if (!Dp.test(t))
                throw new Error("Invalid JSON-pointer: " + t);
            n = t,
            s = "rootData"
        } else {
            if (i = t.match(Np),
            !i)
                throw new Error("Invalid JSON-pointer: " + t);
            if (o = +i[1],
            n = i[2],
            n == "#") {
                if (o >= e)
                    throw new Error("Cannot access property/index " + o + " levels up, current level is " + e);
                return r[e - o]
            }
            if (o > e)
                throw new Error("Cannot access data " + o + " levels up, current level is " + e);
            if (s = "data" + (e - o || ""),
            !n)
                return s
        }
        for (var l = s, d = n.split("/"), u = 0; u < d.length; u++) {
            var g = d[u];
            g && (s += ia(ua(g)),
            l += " && " + s)
        }
        return l
    }
    function Ol(t, e) {
        return t == '""' ? e : (t + " + " + e).replace(/([^\\])' \+ '/g, "$1")
    }
    function Up(t) {
        return ua(decodeURIComponent(t))
    }
    function jp(t) {
        return encodeURIComponent(da(t))
    }
    function da(t) {
        return t.replace(/~/g, "~0").replace(/\//g, "~1")
    }
    function ua(t) {
        return t.replace(/~1/g, "/").replace(/~0/g, "~")
    }
    var Mp = Zr
      , Dl = Fp;
    function Fp(t) {
        Mp.copy(t, this)
    }
    var Nl = {
        exports: {}
    }
      , mr = Nl.exports = function(t, e, r) {
        typeof e == "function" && (r = e,
        e = {}),
        r = e.cb || r;
        var o = typeof r == "function" ? r : r.pre || function() {}
          , n = r.post || function() {}
        ;
        ko(e, o, n, t, "", t)
    }
    ;
    mr.keywords = {
        additionalItems: !0,
        items: !0,
        contains: !0,
        additionalProperties: !0,
        propertyNames: !0,
        not: !0
    },
    mr.arrayKeywords = {
        items: !0,
        allOf: !0,
        anyOf: !0,
        oneOf: !0
    },
    mr.propsKeywords = {
        definitions: !0,
        properties: !0,
        patternProperties: !0,
        dependencies: !0
    },
    mr.skipKeywords = {
        default: !0,
        enum: !0,
        const: !0,
        required: !0,
        maximum: !0,
        minimum: !0,
        exclusiveMaximum: !0,
        exclusiveMinimum: !0,
        multipleOf: !0,
        maxLength: !0,
        minLength: !0,
        pattern: !0,
        format: !0,
        maxItems: !0,
        minItems: !0,
        uniqueItems: !0,
        maxProperties: !0,
        minProperties: !0
    };
    function ko(t, e, r, o, n, s, i, l, d, u) {
        if (o && typeof o == "object" && !Array.isArray(o)) {
            e(o, n, s, i, l, d, u);
            for (var g in o) {
                var c = o[g];
                if (Array.isArray(c)) {
                    if (g in mr.arrayKeywords)
                        for (var m = 0; m < c.length; m++)
                            ko(t, e, r, c[m], n + "/" + g + "/" + m, s, n, g, o, m)
                } else if (g in mr.propsKeywords) {
                    if (c && typeof c == "object")
                        for (var p in c)
                            ko(t, e, r, c[p], n + "/" + g + "/" + Wp(p), s, n, g, o, p)
                } else
                    (g in mr.keywords || t.allKeys && !(g in mr.skipKeywords)) && ko(t, e, r, c, n + "/" + g, s, n, g, o)
            }
            r(o, n, s, i, l, d, u)
        }
    }
    function Wp(t) {
        return t.replace(/~/g, "~0").replace(/\//g, "~1")
    }
    var qp = Nl.exports
      , On = bp
      , Ll = oa
      , Io = Zr
      , Co = Dl
      , Gp = qp
      , ma = pr;
    pr.normalizeId = hr,
    pr.fullPath = Ao,
    pr.url = Ro,
    pr.ids = Vp,
    pr.inlineRef = pa,
    pr.schema = $o;
    function pr(t, e, r) {
        var o = this._refs[r];
        if (typeof o == "string")
            if (this._refs[o])
                o = this._refs[o];
            else
                return pr.call(this, t, e, o);
        if (o = o || this._schemas[r],
        o instanceof Co)
            return pa(o.schema, this._opts.inlineRefs) ? o.schema : o.validate || this._compile(o);
        var n = $o.call(this, e, r), s, i, l;
        return n && (s = n.schema,
        e = n.root,
        l = n.baseId),
        s instanceof Co ? i = s.validate || t.call(this, s.schema, e, void 0, l) : s !== void 0 && (i = pa(s, this._opts.inlineRefs) ? s : t.call(this, s, e, void 0, l)),
        i
    }
    function $o(t, e) {
        var r = On.parse(e)
          , o = jl(r)
          , n = Ao(this._getId(t.schema));
        if (Object.keys(t.schema).length === 0 || o !== n) {
            var s = hr(o)
              , i = this._refs[s];
            if (typeof i == "string")
                return Bp.call(this, t, i, r);
            if (i instanceof Co)
                i.validate || this._compile(i),
                t = i;
            else if (i = this._schemas[s],
            i instanceof Co) {
                if (i.validate || this._compile(i),
                s == hr(e))
                    return {
                        schema: i,
                        root: t,
                        baseId: n
                    };
                t = i
            } else
                return;
            if (!t.schema)
                return;
            n = Ao(this._getId(t.schema))
        }
        return Ul.call(this, r, n, t.schema, t)
    }
    function Bp(t, e, r) {
        var o = $o.call(this, t, e);
        if (o) {
            var n = o.schema
              , s = o.baseId;
            t = o.root;
            var i = this._getId(n);
            return i && (s = Ro(s, i)),
            Ul.call(this, r, s, n, t)
        }
    }
    var zp = Io.toHash(["properties", "patternProperties", "enum", "dependencies", "definitions"]);
    function Ul(t, e, r, o) {
        if (t.fragment = t.fragment || "",
        t.fragment.slice(0, 1) == "/") {
            for (var n = t.fragment.split("/"), s = 1; s < n.length; s++) {
                var i = n[s];
                if (i) {
                    if (i = Io.unescapeFragment(i),
                    r = r[i],
                    r === void 0)
                        break;
                    var l;
                    if (!zp[i] && (l = this._getId(r),
                    l && (e = Ro(e, l)),
                    r.$ref)) {
                        var d = Ro(e, r.$ref)
                          , u = $o.call(this, o, d);
                        u && (r = u.schema,
                        o = u.root,
                        e = u.baseId)
                    }
                }
            }
            if (r !== void 0 && r !== o.schema)
                return {
                    schema: r,
                    root: o,
                    baseId: e
                }
        }
    }
    var Zp = Io.toHash(["type", "format", "pattern", "maxLength", "minLength", "maxProperties", "minProperties", "maxItems", "minItems", "maximum", "minimum", "uniqueItems", "multipleOf", "required", "enum"]);
    function pa(t, e) {
        if (e === !1)
            return !1;
        if (e === void 0 || e === !0)
            return ha(t);
        if (e)
            return ga(t) <= e
    }
    function ha(t) {
        var e;
        if (Array.isArray(t)) {
            for (var r = 0; r < t.length; r++)
                if (e = t[r],
                typeof e == "object" && !ha(e))
                    return !1
        } else
            for (var o in t)
                if (o == "$ref" || (e = t[o],
                typeof e == "object" && !ha(e)))
                    return !1;
        return !0
    }
    function ga(t) {
        var e = 0, r;
        if (Array.isArray(t)) {
            for (var o = 0; o < t.length; o++)
                if (r = t[o],
                typeof r == "object" && (e += ga(r)),
                e == 1 / 0)
                    return 1 / 0
        } else
            for (var n in t) {
                if (n == "$ref")
                    return 1 / 0;
                if (Zp[n])
                    e++;
                else if (r = t[n],
                typeof r == "object" && (e += ga(r) + 1),
                e == 1 / 0)
                    return 1 / 0
            }
        return e
    }
    function Ao(t, e) {
        e !== !1 && (t = hr(t));
        var r = On.parse(t);
        return jl(r)
    }
    function jl(t) {
        return On.serialize(t).split("#")[0] + "#"
    }
    var Hp = /#\/?$/;
    function hr(t) {
        return t ? t.replace(Hp, "") : ""
    }
    function Ro(t, e) {
        return e = hr(e),
        On.resolve(t, e)
    }
    function Vp(t) {
        var e = hr(this._getId(t))
          , r = {
            "": e
        }
          , o = {
            "": Ao(e, !1)
        }
          , n = {}
          , s = this;
        return Gp(t, {
            allKeys: !0
        }, function(i, l, d, u, g, c, m) {
            if (l !== "") {
                var p = s._getId(i)
                  , h = r[u]
                  , f = o[u] + "/" + g;
                if (m !== void 0 && (f += "/" + (typeof m == "number" ? m : Io.escapeFragment(m))),
                typeof p == "string") {
                    p = h = hr(h ? On.resolve(h, p) : p);
                    var y = s._refs[p];
                    if (typeof y == "string" && (y = s._refs[y]),
                    y && y.schema) {
                        if (!Ll(i, y.schema))
                            throw new Error('id "' + p + '" resolves to more than one schema')
                    } else if (p != hr(f))
                        if (p[0] == "#") {
                            if (n[p] && !Ll(i, n[p]))
                                throw new Error('id "' + p + '" resolves to more than one schema');
                            n[p] = i
                        } else
                            s._refs[p] = f
                }
                r[l] = h,
                o[l] = f
            }
        }),
        n
    }
    var fa = ma
      , ya = {
        Validation: Ml(Jp),
        MissingRef: Ml(va)
    };
    function Jp(t) {
        this.message = "validation failed",
        this.errors = t,
        this.ajv = this.validation = !0
    }
    va.message = function(t, e) {
        return "can't resolve reference " + e + " from id " + t
    }
    ;
    function va(t, e, r) {
        this.message = r || va.message(t, e),
        this.missingRef = fa.url(t, e),
        this.missingSchema = fa.normalizeId(fa.fullPath(this.missingRef))
    }
    function Ml(t) {
        return t.prototype = Object.create(Error.prototype),
        t.prototype.constructor = t,
        t
    }
    var Fl = function(t, e) {
        e || (e = {}),
        typeof e == "function" && (e = {
            cmp: e
        });
        var r = typeof e.cycles == "boolean" ? e.cycles : !1
          , o = e.cmp && function(s) {
            return function(i) {
                return function(l, d) {
                    var u = {
                        key: l,
                        value: i[l]
                    }
                      , g = {
                        key: d,
                        value: i[d]
                    };
                    return s(u, g)
                }
            }
        }(e.cmp)
          , n = [];
        return function s(i) {
            if (i && i.toJSON && typeof i.toJSON == "function" && (i = i.toJSON()),
            i !== void 0) {
                if (typeof i == "number")
                    return isFinite(i) ? "" + i : "null";
                if (typeof i != "object")
                    return JSON.stringify(i);
                var l, d;
                if (Array.isArray(i)) {
                    for (d = "[",
                    l = 0; l < i.length; l++)
                        l && (d += ","),
                        d += s(i[l]) || "null";
                    return d + "]"
                }
                if (i === null)
                    return "null";
                if (n.indexOf(i) !== -1) {
                    if (r)
                        return JSON.stringify("__cycle__");
                    throw new TypeError("Converting circular structure to JSON")
                }
                var u = n.push(i) - 1
                  , g = Object.keys(i).sort(o && o(i));
                for (d = "",
                l = 0; l < g.length; l++) {
                    var c = g[l]
                      , m = s(i[c]);
                    m && (d && (d += ","),
                    d += JSON.stringify(c) + ":" + m)
                }
                return n.splice(u, 1),
                "{" + d + "}"
            }
        }(t)
    }
      , Wl = function(e, r, o) {
        var n = ""
          , s = e.schema.$async === !0
          , i = e.util.schemaHasRulesExcept(e.schema, e.RULES.all, "$ref")
          , l = e.self._getId(e.schema);
        if (e.opts.strictKeywords) {
            var d = e.util.schemaUnknownRules(e.schema, e.RULES.keywords);
            if (d) {
                var u = "unknown keyword: " + d;
                if (e.opts.strictKeywords === "log")
                    e.logger.warn(u);
                else
                    throw new Error(u)
            }
        }
        if (e.isTop && (n += " var validate = ",
        s && (e.async = !0,
        n += "async "),
        n += "function(data, dataPath, parentData, parentDataProperty, rootData) { 'use strict'; ",
        l && (e.opts.sourceCode || e.opts.processCode) && (n += " " + ("/*# sourceURL=" + l + " */") + " ")),
        typeof e.schema == "boolean" || !(i || e.schema.$ref)) {
            var r = "false schema", g = e.level, c = e.dataLevel, m = e.schema[r], p = e.schemaPath + e.util.getProperty(r), h = e.errSchemaPath + "/" + r, w = !e.opts.allErrors, k, f = "data" + (c || ""), S = "valid" + g;
            if (e.schema === !1) {
                e.isTop ? w = !0 : n += " var " + S + " = false; ";
                var y = y || [];
                y.push(n),
                n = "",
                e.createErrors !== !1 ? (n += " { keyword: '" + (k || "false schema") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(h) + " , params: {} ",
                e.opts.messages !== !1 && (n += " , message: 'boolean schema is false' "),
                e.opts.verbose && (n += " , schema: false , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "),
                n += " } ") : n += " {} ";
                var b = n;
                n = y.pop(),
                !e.compositeRule && w ? e.async ? n += " throw new ValidationError([" + b + "]); " : n += " validate.errors = [" + b + "]; return false; " : n += " var err = " + b + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "
            } else
                e.isTop ? s ? n += " return data; " : n += " validate.errors = null; return true; " : n += " var " + S + " = true; ";
            return e.isTop && (n += " }; return validate; "),
            n
        }
        if (e.isTop) {
            var x = e.isTop
              , g = e.level = 0
              , c = e.dataLevel = 0
              , f = "data";
            if (e.rootId = e.resolve.fullPath(e.self._getId(e.root.schema)),
            e.baseId = e.baseId || e.rootId,
            delete e.isTop,
            e.dataPathArr = [""],
            e.schema.default !== void 0 && e.opts.useDefaults && e.opts.strictDefaults) {
                var v = "default is ignored in the schema root";
                if (e.opts.strictDefaults === "log")
                    e.logger.warn(v);
                else
                    throw new Error(v)
            }
            n += " var vErrors = null; ",
            n += " var errors = 0;     ",
            n += " if (rootData === undefined) rootData = data; "
        } else {
            var g = e.level
              , c = e.dataLevel
              , f = "data" + (c || "");
            if (l && (e.baseId = e.resolve.url(e.baseId, l)),
            s && !e.async)
                throw new Error("async schema in sync schema");
            n += " var errs_" + g + " = errors;"
        }
        var S = "valid" + g, w = !e.opts.allErrors, _ = "", I = "", k, C = e.schema.type, L = Array.isArray(C);
        if (C && e.opts.nullable && e.schema.nullable === !0 && (L ? C.indexOf("null") == -1 && (C = C.concat("null")) : C != "null" && (C = [C, "null"],
        L = !0)),
        L && C.length == 1 && (C = C[0],
        L = !1),
        e.schema.$ref && i) {
            if (e.opts.extendRefs == "fail")
                throw new Error('$ref: validation keywords used in schema at path "' + e.errSchemaPath + '" (see option extendRefs)');
            e.opts.extendRefs !== !0 && (i = !1,
            e.logger.warn('$ref: keywords ignored in schema at path "' + e.errSchemaPath + '"'))
        }
        if (e.schema.$comment && e.opts.$comment && (n += " " + e.RULES.all.$comment.code(e, "$comment")),
        C) {
            if (e.opts.coerceTypes)
                var N = e.util.coerceToTypes(e.opts.coerceTypes, C);
            var A = e.RULES.types[C];
            if (N || L || A === !0 || A && !nt(A)) {
                var p = e.schemaPath + ".type"
                  , h = e.errSchemaPath + "/type"
                  , p = e.schemaPath + ".type"
                  , h = e.errSchemaPath + "/type"
                  , $ = L ? "checkDataTypes" : "checkDataType";
                if (n += " if (" + e.util[$](C, f, e.opts.strictNumbers, !0) + ") { ",
                N) {
                    var R = "dataType" + g
                      , q = "coerced" + g;
                    n += " var " + R + " = typeof " + f + "; var " + q + " = undefined; ",
                    e.opts.coerceTypes == "array" && (n += " if (" + R + " == 'object' && Array.isArray(" + f + ") && " + f + ".length == 1) { " + f + " = " + f + "[0]; " + R + " = typeof " + f + "; if (" + e.util.checkDataType(e.schema.type, f, e.opts.strictNumbers) + ") " + q + " = " + f + "; } "),
                    n += " if (" + q + " !== undefined) ; ";
                    var ee = N;
                    if (ee)
                        for (var ne, te = -1, re = ee.length - 1; te < re; )
                            ne = ee[te += 1],
                            ne == "string" ? n += " else if (" + R + " == 'number' || " + R + " == 'boolean') " + q + " = '' + " + f + "; else if (" + f + " === null) " + q + " = ''; " : ne == "number" || ne == "integer" ? (n += " else if (" + R + " == 'boolean' || " + f + " === null || (" + R + " == 'string' && " + f + " && " + f + " == +" + f + " ",
                            ne == "integer" && (n += " && !(" + f + " % 1)"),
                            n += ")) " + q + " = +" + f + "; ") : ne == "boolean" ? n += " else if (" + f + " === 'false' || " + f + " === 0 || " + f + " === null) " + q + " = false; else if (" + f + " === 'true' || " + f + " === 1) " + q + " = true; " : ne == "null" ? n += " else if (" + f + " === '' || " + f + " === 0 || " + f + " === false) " + q + " = null; " : e.opts.coerceTypes == "array" && ne == "array" && (n += " else if (" + R + " == 'string' || " + R + " == 'number' || " + R + " == 'boolean' || " + f + " == null) " + q + " = [" + f + "]; ");
                    n += " else {   ";
                    var y = y || [];
                    y.push(n),
                    n = "",
                    e.createErrors !== !1 ? (n += " { keyword: '" + (k || "type") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(h) + " , params: { type: '",
                    L ? n += "" + C.join(",") : n += "" + C,
                    n += "' } ",
                    e.opts.messages !== !1 && (n += " , message: 'should be ",
                    L ? n += "" + C.join(",") : n += "" + C,
                    n += "' "),
                    e.opts.verbose && (n += " , schema: validate.schema" + p + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "),
                    n += " } ") : n += " {} ";
                    var b = n;
                    n = y.pop(),
                    !e.compositeRule && w ? e.async ? n += " throw new ValidationError([" + b + "]); " : n += " validate.errors = [" + b + "]; return false; " : n += " var err = " + b + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",
                    n += " } if (" + q + " !== undefined) {  ";
                    var Q = c ? "data" + (c - 1 || "") : "parentData"
                      , Ie = c ? e.dataPathArr[c] : "parentDataProperty";
                    n += " " + f + " = " + q + "; ",
                    c || (n += "if (" + Q + " !== undefined)"),
                    n += " " + Q + "[" + Ie + "] = " + q + "; } "
                } else {
                    var y = y || [];
                    y.push(n),
                    n = "",
                    e.createErrors !== !1 ? (n += " { keyword: '" + (k || "type") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(h) + " , params: { type: '",
                    L ? n += "" + C.join(",") : n += "" + C,
                    n += "' } ",
                    e.opts.messages !== !1 && (n += " , message: 'should be ",
                    L ? n += "" + C.join(",") : n += "" + C,
                    n += "' "),
                    e.opts.verbose && (n += " , schema: validate.schema" + p + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "),
                    n += " } ") : n += " {} ";
                    var b = n;
                    n = y.pop(),
                    !e.compositeRule && w ? e.async ? n += " throw new ValidationError([" + b + "]); " : n += " validate.errors = [" + b + "]; return false; " : n += " var err = " + b + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "
                }
                n += " } "
            }
        }
        if (e.schema.$ref && !i)
            n += " " + e.RULES.all.$ref.code(e, "$ref") + " ",
            w && (n += " } if (errors === ",
            x ? n += "0" : n += "errs_" + g,
            n += ") { ",
            I += "}");
        else {
            var Fe = e.RULES;
            if (Fe) {
                for (var A, We = -1, ve = Fe.length - 1; We < ve; )
                    if (A = Fe[We += 1],
                    nt(A)) {
                        if (A.type && (n += " if (" + e.util.checkDataType(A.type, f, e.opts.strictNumbers) + ") { "),
                        e.opts.useDefaults) {
                            if (A.type == "object" && e.schema.properties) {
                                var m = e.schema.properties
                                  , qe = Object.keys(m)
                                  , Ke = qe;
                                if (Ke)
                                    for (var Te, Ve = -1, rt = Ke.length - 1; Ve < rt; ) {
                                        Te = Ke[Ve += 1];
                                        var Ge = m[Te];
                                        if (Ge.default !== void 0) {
                                            var Ce = f + e.util.getProperty(Te);
                                            if (e.compositeRule) {
                                                if (e.opts.strictDefaults) {
                                                    var v = "default is ignored for: " + Ce;
                                                    if (e.opts.strictDefaults === "log")
                                                        e.logger.warn(v);
                                                    else
                                                        throw new Error(v)
                                                }
                                            } else
                                                n += " if (" + Ce + " === undefined ",
                                                e.opts.useDefaults == "empty" && (n += " || " + Ce + " === null || " + Ce + " === '' "),
                                                n += " ) " + Ce + " = ",
                                                e.opts.useDefaults == "shared" ? n += " " + e.useDefault(Ge.default) + " " : n += " " + JSON.stringify(Ge.default) + " ",
                                                n += "; "
                                        }
                                    }
                            } else if (A.type == "array" && Array.isArray(e.schema.items)) {
                                var Ut = e.schema.items;
                                if (Ut) {
                                    for (var Ge, te = -1, Qe = Ut.length - 1; te < Qe; )
                                        if (Ge = Ut[te += 1],
                                        Ge.default !== void 0) {
                                            var Ce = f + "[" + te + "]";
                                            if (e.compositeRule) {
                                                if (e.opts.strictDefaults) {
                                                    var v = "default is ignored for: " + Ce;
                                                    if (e.opts.strictDefaults === "log")
                                                        e.logger.warn(v);
                                                    else
                                                        throw new Error(v)
                                                }
                                            } else
                                                n += " if (" + Ce + " === undefined ",
                                                e.opts.useDefaults == "empty" && (n += " || " + Ce + " === null || " + Ce + " === '' "),
                                                n += " ) " + Ce + " = ",
                                                e.opts.useDefaults == "shared" ? n += " " + e.useDefault(Ge.default) + " " : n += " " + JSON.stringify(Ge.default) + " ",
                                                n += "; "
                                        }
                                }
                            }
                        }
                        var Oe = A.rules;
                        if (Oe) {
                            for (var br, st = -1, an = Oe.length - 1; st < an; )
                                if (br = Oe[st += 1],
                                Sr(br)) {
                                    var Nr = br.code(e, br.keyword, A.type);
                                    Nr && (n += " " + Nr + " ",
                                    w && (_ += "}"))
                                }
                        }
                        if (w && (n += " " + _ + " ",
                        _ = ""),
                        A.type && (n += " } ",
                        C && C === A.type && !N)) {
                            n += " else { ";
                            var p = e.schemaPath + ".type"
                              , h = e.errSchemaPath + "/type"
                              , y = y || [];
                            y.push(n),
                            n = "",
                            e.createErrors !== !1 ? (n += " { keyword: '" + (k || "type") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(h) + " , params: { type: '",
                            L ? n += "" + C.join(",") : n += "" + C,
                            n += "' } ",
                            e.opts.messages !== !1 && (n += " , message: 'should be ",
                            L ? n += "" + C.join(",") : n += "" + C,
                            n += "' "),
                            e.opts.verbose && (n += " , schema: validate.schema" + p + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "),
                            n += " } ") : n += " {} ";
                            var b = n;
                            n = y.pop(),
                            !e.compositeRule && w ? e.async ? n += " throw new ValidationError([" + b + "]); " : n += " validate.errors = [" + b + "]; return false; " : n += " var err = " + b + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",
                            n += " } "
                        }
                        w && (n += " if (errors === ",
                        x ? n += "0" : n += "errs_" + g,
                        n += ") { ",
                        I += "}")
                    }
            }
        }
        w && (n += " " + I + " "),
        x ? (s ? (n += " if (errors === 0) return data;           ",
        n += " else throw new ValidationError(vErrors); ") : (n += " validate.errors = vErrors; ",
        n += " return errors === 0;       "),
        n += " }; return validate;") : n += " var " + S + " = errors === errs_" + g + ";";
        function nt(Xe) {
            for (var et = Xe.rules, ft = 0; ft < et.length; ft++)
                if (Sr(et[ft]))
                    return !0
        }
        function Sr(Xe) {
            return e.schema[Xe.keyword] !== void 0 || Xe.implements && Jn(Xe)
        }
        function Jn(Xe) {
            for (var et = Xe.implements, ft = 0; ft < et.length; ft++)
                if (e.schema[et[ft]] !== void 0)
                    return !0
        }
        return n
    }
      , Oo = ma
      , Do = Zr
      , ql = ya
      , Yp = Fl
      , Gl = Wl
      , Kp = Do.ucs2length
      , Qp = oa
      , Xp = ql.Validation
      , eh = wa;
    function wa(t, e, r, o) {
        var n = this
          , s = this._opts
          , i = [void 0]
          , l = {}
          , d = []
          , u = {}
          , g = []
          , c = {}
          , m = [];
        e = e || {
            schema: t,
            refVal: i,
            refs: l
        };
        var p = th.call(this, t, e, o)
          , h = this._compilations[p.index];
        if (p.compiling)
            return h.callValidate = v;
        var f = this._formats
          , y = this.RULES;
        try {
            var b = S(t, e, r, o);
            h.validate = b;
            var x = h.callValidate;
            return x && (x.schema = b.schema,
            x.errors = null,
            x.refs = b.refs,
            x.refVal = b.refVal,
            x.root = b.root,
            x.$async = b.$async,
            s.sourceCode && (x.source = b.source)),
            b
        } finally {
            rh.call(this, t, e, o)
        }
        function v() {
            var $ = h.validate
              , R = $.apply(this, arguments);
            return v.errors = $.errors,
            R
        }
        function S($, R, q, ee) {
            var ne = !R || R && R.schema == $;
            if (R.schema != e.schema)
                return wa.call(n, $, R, q, ee);
            var te = $.$async === !0
              , re = Gl({
                isTop: !0,
                schema: $,
                isRoot: ne,
                baseId: ee,
                root: R,
                schemaPath: "",
                errSchemaPath: "#",
                errorPath: '""',
                MissingRefError: ql.MissingRef,
                RULES: y,
                validate: Gl,
                util: Do,
                resolve: Oo,
                resolveRef: w,
                usePattern: L,
                useDefault: N,
                useCustomRule: A,
                opts: s,
                formats: f,
                logger: n.logger,
                self: n
            });
            re = No(i, sh) + No(d, nh) + No(g, oh) + No(m, ah) + re,
            s.processCode && (re = s.processCode(re, $));
            var Q;
            try {
                var Ie = new Function("self","RULES","formats","root","refVal","defaults","customRules","equal","ucs2length","ValidationError",re);
                Q = Ie(n, y, f, e, i, g, m, Qp, Kp, Xp),
                i[0] = Q
            } catch (Fe) {
                throw n.logger.error("Error compiling schema, function code:", re),
                Fe
            }
            return Q.schema = $,
            Q.errors = null,
            Q.refs = l,
            Q.refVal = i,
            Q.root = ne ? Q : R,
            te && (Q.$async = !0),
            s.sourceCode === !0 && (Q.source = {
                code: re,
                patterns: d,
                defaults: g
            }),
            Q
        }
        function w($, R, q) {
            R = Oo.url($, R);
            var ee = l[R], ne, te;
            if (ee !== void 0)
                return ne = i[ee],
                te = "refVal[" + ee + "]",
                C(ne, te);
            if (!q && e.refs) {
                var re = e.refs[R];
                if (re !== void 0)
                    return ne = e.refVal[re],
                    te = _(R, ne),
                    C(ne, te)
            }
            te = _(R);
            var Q = Oo.call(n, S, e, R);
            if (Q === void 0) {
                var Ie = r && r[R];
                Ie && (Q = Oo.inlineRef(Ie, s.inlineRefs) ? Ie : wa.call(n, Ie, e, r, $))
            }
            if (Q === void 0)
                I(R);
            else
                return k(R, Q),
                C(Q, te)
        }
        function _($, R) {
            var q = i.length;
            return i[q] = R,
            l[$] = q,
            "refVal" + q
        }
        function I($) {
            delete l[$]
        }
        function k($, R) {
            var q = l[$];
            i[q] = R
        }
        function C($, R) {
            return typeof $ == "object" || typeof $ == "boolean" ? {
                code: R,
                schema: $,
                inline: !0
            } : {
                code: R,
                $async: $ && !!$.$async
            }
        }
        function L($) {
            var R = u[$];
            return R === void 0 && (R = u[$] = d.length,
            d[R] = $),
            "pattern" + R
        }
        function N($) {
            switch (typeof $) {
            case "boolean":
            case "number":
                return "" + $;
            case "string":
                return Do.toQuotedString($);
            case "object":
                if ($ === null)
                    return "null";
                var R = Yp($)
                  , q = c[R];
                return q === void 0 && (q = c[R] = g.length,
                g[q] = $),
                "default" + q
            }
        }
        function A($, R, q, ee) {
            if (n._opts.validateSchema !== !1) {
                var ne = $.definition.dependencies;
                if (ne && !ne.every(function(Ke) {
                    return Object.prototype.hasOwnProperty.call(q, Ke)
                }))
                    throw new Error("parent schema must have all required keywords: " + ne.join(","));
                var te = $.definition.validateSchema;
                if (te) {
                    var re = te(R);
                    if (!re) {
                        var Q = "keyword schema is invalid: " + n.errorsText(te.errors);
                        if (n._opts.validateSchema == "log")
                            n.logger.error(Q);
                        else
                            throw new Error(Q)
                    }
                }
            }
            var Ie = $.definition.compile, Fe = $.definition.inline, We = $.definition.macro, ve;
            if (Ie)
                ve = Ie.call(n, R, q, ee);
            else if (We)
                ve = We.call(n, R, q, ee),
                s.validateSchema !== !1 && n.validateSchema(ve, !0);
            else if (Fe)
                ve = Fe.call(n, ee, $.keyword, R, q);
            else if (ve = $.definition.validate,
            !ve)
                return;
            if (ve === void 0)
                throw new Error('custom keyword "' + $.keyword + '"failed to compile');
            var qe = m.length;
            return m[qe] = ve,
            {
                code: "customRule" + qe,
                validate: ve
            }
        }
    }
    function th(t, e, r) {
        var o = Bl.call(this, t, e, r);
        return o >= 0 ? {
            index: o,
            compiling: !0
        } : (o = this._compilations.length,
        this._compilations[o] = {
            schema: t,
            root: e,
            baseId: r
        },
        {
            index: o,
            compiling: !1
        })
    }
    function rh(t, e, r) {
        var o = Bl.call(this, t, e, r);
        o >= 0 && this._compilations.splice(o, 1)
    }
    function Bl(t, e, r) {
        for (var o = 0; o < this._compilations.length; o++) {
            var n = this._compilations[o];
            if (n.schema == t && n.root == e && n.baseId == r)
                return o
        }
        return -1
    }
    function nh(t, e) {
        return "var pattern" + t + " = new RegExp(" + Do.toQuotedString(e[t]) + ");"
    }
    function oh(t) {
        return "var default" + t + " = defaults[" + t + "];"
    }
    function sh(t, e) {
        return e[t] === void 0 ? "" : "var refVal" + t + " = refVal[" + t + "];"
    }
    function ah(t) {
        return "var customRule" + t + " = customRules[" + t + "];"
    }
    function No(t, e) {
        if (!t.length)
            return "";
        for (var r = "", o = 0; o < t.length; o++)
            r += e(o, t);
        return r
    }
    var zl = {
        exports: {}
    }
      , Lo = zl.exports = function() {
        this._cache = {}
    }
    ;
    Lo.prototype.put = function(e, r) {
        this._cache[e] = r
    }
    ,
    Lo.prototype.get = function(e) {
        return this._cache[e]
    }
    ,
    Lo.prototype.del = function(e) {
        delete this._cache[e]
    }
    ,
    Lo.prototype.clear = function() {
        this._cache = {}
    }
    ;
    var ih = zl.exports
      , lh = Zr
      , ch = /^(\d\d\d\d)-(\d\d)-(\d\d)$/
      , dh = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
      , uh = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i
      , Zl = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i
      , mh = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i
      , ph = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i
      , Hl = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i
      , Vl = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i
      , Jl = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i
      , Yl = /^(?:\/(?:[^~/]|~0|~1)*)*$/
      , Kl = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i
      , Ql = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/
      , hh = Uo;
    function Uo(t) {
        return t = t == "full" ? "full" : "fast",
        lh.copy(Uo[t])
    }
    Uo.fast = {
        date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
        time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
        "date-time": /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
        uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
        "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
        "uri-template": Hl,
        url: Vl,
        email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
        hostname: Zl,
        ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
        ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
        regex: tc,
        uuid: Jl,
        "json-pointer": Yl,
        "json-pointer-uri-fragment": Kl,
        "relative-json-pointer": Ql
    },
    Uo.full = {
        date: Xl,
        time: ec,
        "date-time": yh,
        uri: wh,
        "uri-reference": ph,
        "uri-template": Hl,
        url: Vl,
        email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
        hostname: Zl,
        ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
        ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
        regex: tc,
        uuid: Jl,
        "json-pointer": Yl,
        "json-pointer-uri-fragment": Kl,
        "relative-json-pointer": Ql
    };
    function gh(t) {
        return t % 4 === 0 && (t % 100 !== 0 || t % 400 === 0)
    }
    function Xl(t) {
        var e = t.match(ch);
        if (!e)
            return !1;
        var r = +e[1]
          , o = +e[2]
          , n = +e[3];
        return o >= 1 && o <= 12 && n >= 1 && n <= (o == 2 && gh(r) ? 29 : dh[o])
    }
    function ec(t, e) {
        var r = t.match(uh);
        if (!r)
            return !1;
        var o = r[1]
          , n = r[2]
          , s = r[3]
          , i = r[5];
        return (o <= 23 && n <= 59 && s <= 59 || o == 23 && n == 59 && s == 60) && (!e || i)
    }
    var fh = /t|\s/i;
    function yh(t) {
        var e = t.split(fh);
        return e.length == 2 && Xl(e[0]) && ec(e[1], !0)
    }
    var vh = /\/|:/;
    function wh(t) {
        return vh.test(t) && mh.test(t)
    }
    var bh = /[^\\]\\Z/;
    function tc(t) {
        if (bh.test(t))
            return !1;
        try {
            return new RegExp(t),
            !0
        } catch {
            return !1
        }
    }
    var Sh = function(e, r, o) {
        var n = " ", s = e.level, i = e.dataLevel, l = e.schema[r], d = e.errSchemaPath + "/" + r, u = !e.opts.allErrors, g = "data" + (i || ""), c = "valid" + s, m, p;
        if (l == "#" || l == "#/")
            e.isRoot ? (m = e.async,
            p = "validate") : (m = e.root.schema.$async === !0,
            p = "root.refVal[0]");
        else {
            var h = e.resolveRef(e.baseId, l, e.isRoot);
            if (h === void 0) {
                var f = e.MissingRefError.message(e.baseId, l);
                if (e.opts.missingRefs == "fail") {
                    e.logger.error(f);
                    var y = y || [];
                    y.push(n),
                    n = "",
                    e.createErrors !== !1 ? (n += " { keyword: '$ref' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(d) + " , params: { ref: '" + e.util.escapeQuotes(l) + "' } ",
                    e.opts.messages !== !1 && (n += " , message: 'can\\'t resolve reference " + e.util.escapeQuotes(l) + "' "),
                    e.opts.verbose && (n += " , schema: " + e.util.toQuotedString(l) + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + g + " "),
                    n += " } ") : n += " {} ";
                    var b = n;
                    n = y.pop(),
                    !e.compositeRule && u ? e.async ? n += " throw new ValidationError([" + b + "]); " : n += " validate.errors = [" + b + "]; return false; " : n += " var err = " + b + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",
                    u && (n += " if (false) { ")
                } else if (e.opts.missingRefs == "ignore")
                    e.logger.warn(f),
                    u && (n += " if (true) { ");
                else
                    throw new e.MissingRefError(e.baseId,l,f)
            } else if (h.inline) {
                var x = e.util.copy(e);
                x.level++;
                var v = "valid" + x.level;
                x.schema = h.schema,
                x.schemaPath = "",
                x.errSchemaPath = l;
                var S = e.validate(x).replace(/validate\.schema/g, h.code);
                n += " " + S + " ",
                u && (n += " if (" + v + ") { ")
            } else
                m = h.$async === !0 || e.async && h.$async !== !1,
                p = h.code
        }
        if (p) {
            var y = y || [];
            y.push(n),
            n = "",
            e.opts.passContext ? n += " " + p + ".call(this, " : n += " " + p + "( ",
            n += " " + g + ", (dataPath || '')",
            e.errorPath != '""' && (n += " + " + e.errorPath);
            var w = i ? "data" + (i - 1 || "") : "parentData"
              , _ = i ? e.dataPathArr[i] : "parentDataProperty";
            n += " , " + w + " , " + _ + ", rootData)  ";
            var I = n;
            if (n = y.pop(),
            m) {
                if (!e.async)
                    throw new Error("async schema referenced by sync schema");
                u && (n += " var " + c + "; "),
                n += " try { await " + I + "; ",
                u && (n += " " + c + " = true; "),
                n += " } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ",
                u && (n += " " + c + " = false; "),
                n += " } ",
                u && (n += " if (" + c + ") { ")
            } else
                n += " if (!" + I + ") { if (vErrors === null) vErrors = " + p + ".errors; else vErrors = vErrors.concat(" + p + ".errors); errors = vErrors.length; } ",
                u && (n += " else { ")
        }
        return n
    }
      , Eh = function(e, r, o) {
        var n = " "
          , s = e.schema[r]
          , i = e.schemaPath + e.util.getProperty(r)
          , l = e.errSchemaPath + "/" + r
          , d = !e.opts.allErrors
          , u = e.util.copy(e)
          , g = "";
        u.level++;
        var c = "valid" + u.level
          , m = u.baseId
          , p = !0
          , h = s;
        if (h)
            for (var f, y = -1, b = h.length - 1; y < b; )
                f = h[y += 1],
                (e.opts.strictKeywords ? typeof f == "object" && Object.keys(f).length > 0 || f === !1 : e.util.schemaHasRules(f, e.RULES.all)) && (p = !1,
                u.schema = f,
                u.schemaPath = i + "[" + y + "]",
                u.errSchemaPath = l + "/" + y,
                n += "  " + e.validate(u) + " ",
                u.baseId = m,
                d && (n += " if (" + c + ") { ",
                g += "}"));
        return d && (p ? n += " if (true) { " : n += " " + g.slice(0, -1) + " "),
        n
    }
      , xh = function(e, r, o) {
        var n = " "
          , s = e.level
          , i = e.dataLevel
          , l = e.schema[r]
          , d = e.schemaPath + e.util.getProperty(r)
          , u = e.errSchemaPath + "/" + r
          , g = !e.opts.allErrors
          , c = "data" + (i || "")
          , m = "valid" + s
          , p = "errs__" + s
          , h = e.util.copy(e)
          , f = "";
        h.level++;
        var y = "valid" + h.level
          , b = l.every(function(k) {
            return e.opts.strictKeywords ? typeof k == "object" && Object.keys(k).length > 0 || k === !1 : e.util.schemaHasRules(k, e.RULES.all)
        });
        if (b) {
            var x = h.baseId;
            n += " var " + p + " = errors; var " + m + " = false;  ";
            var v = e.compositeRule;
            e.compositeRule = h.compositeRule = !0;
            var S = l;
            if (S)
                for (var w, _ = -1, I = S.length - 1; _ < I; )
                    w = S[_ += 1],
                    h.schema = w,
                    h.schemaPath = d + "[" + _ + "]",
                    h.errSchemaPath = u + "/" + _,
                    n += "  " + e.validate(h) + " ",
                    h.baseId = x,
                    n += " " + m + " = " + m + " || " + y + "; if (!" + m + ") { ",
                    f += "}";
            e.compositeRule = h.compositeRule = v,
            n += " " + f + " if (!" + m + ") {   var err =   ",
            e.createErrors !== !1 ? (n += " { keyword: 'anyOf' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: {} ",
            e.opts.messages !== !1 && (n += " , message: 'should match some schema in anyOf' "),
            e.opts.verbose && (n += " , schema: validate.schema" + d + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + c + " "),
            n += " } ") : n += " {} ",
            n += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",
            !e.compositeRule && g && (e.async ? n += " throw new ValidationError(vErrors); " : n += " validate.errors = vErrors; return false; "),
            n += " } else {  errors = " + p + "; if (vErrors !== null) { if (" + p + ") vErrors.length = " + p + "; else vErrors = null; } ",
            e.opts.allErrors && (n += " } ")
        } else
            g && (n += " if (true) { ");
        return n
    }
      , _h = function(e, r, o) {
        var n = " "
          , s = e.schema[r]
          , i = e.errSchemaPath + "/" + r;
        e.opts.allErrors;
        var l = e.util.toQuotedString(s);
        return e.opts.$comment === !0 ? n += " console.log(" + l + ");" : typeof e.opts.$comment == "function" && (n += " self._opts.$comment(" + l + ", " + e.util.toQuotedString(i) + ", validate.root.schema);"),
        n
    }
      , Th = function(e, r, o) {
        var n = " "
          , s = e.level
          , i = e.dataLevel
          , l = e.schema[r]
          , d = e.schemaPath + e.util.getProperty(r)
          , u = e.errSchemaPath + "/" + r
          , g = !e.opts.allErrors
          , c = "data" + (i || "")
          , m = "valid" + s
          , p = e.opts.$data && l && l.$data;
        p && (n += " var schema" + s + " = " + e.util.getData(l.$data, i, e.dataPathArr) + "; "),
        p || (n += " var schema" + s + " = validate.schema" + d + ";"),
        n += "var " + m + " = equal(" + c + ", schema" + s + "); if (!" + m + ") {   ";
        var h = h || [];
        h.push(n),
        n = "",
        e.createErrors !== !1 ? (n += " { keyword: 'const' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { allowedValue: schema" + s + " } ",
        e.opts.messages !== !1 && (n += " , message: 'should be equal to constant' "),
        e.opts.verbose && (n += " , schema: validate.schema" + d + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + c + " "),
        n += " } ") : n += " {} ";
        var f = n;
        return n = h.pop(),
        !e.compositeRule && g ? e.async ? n += " throw new ValidationError([" + f + "]); " : n += " validate.errors = [" + f + "]; return false; " : n += " var err = " + f + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",
        n += " }",
        g && (n += " else { "),
        n
    }
      , Ph = function(e, r, o) {
        var n = " "
          , s = e.level
          , i = e.dataLevel
          , l = e.schema[r]
          , d = e.schemaPath + e.util.getProperty(r)
          , u = e.errSchemaPath + "/" + r
          , g = !e.opts.allErrors
          , c = "data" + (i || "")
          , m = "valid" + s
          , p = "errs__" + s
          , h = e.util.copy(e)
          , f = "";
        h.level++;
        var y = "valid" + h.level
          , b = "i" + s
          , x = h.dataLevel = e.dataLevel + 1
          , v = "data" + x
          , S = e.baseId
          , w = e.opts.strictKeywords ? typeof l == "object" && Object.keys(l).length > 0 || l === !1 : e.util.schemaHasRules(l, e.RULES.all);
        if (n += "var " + p + " = errors;var " + m + ";",
        w) {
            var _ = e.compositeRule;
            e.compositeRule = h.compositeRule = !0,
            h.schema = l,
            h.schemaPath = d,
            h.errSchemaPath = u,
            n += " var " + y + " = false; for (var " + b + " = 0; " + b + " < " + c + ".length; " + b + "++) { ",
            h.errorPath = e.util.getPathExpr(e.errorPath, b, e.opts.jsonPointers, !0);
            var I = c + "[" + b + "]";
            h.dataPathArr[x] = b;
            var k = e.validate(h);
            h.baseId = S,
            e.util.varOccurences(k, v) < 2 ? n += " " + e.util.varReplace(k, v, I) + " " : n += " var " + v + " = " + I + "; " + k + " ",
            n += " if (" + y + ") break; }  ",
            e.compositeRule = h.compositeRule = _,
            n += " " + f + " if (!" + y + ") {"
        } else
            n += " if (" + c + ".length == 0) {";
        var C = C || [];
        C.push(n),
        n = "",
        e.createErrors !== !1 ? (n += " { keyword: 'contains' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: {} ",
        e.opts.messages !== !1 && (n += " , message: 'should contain a valid item' "),
        e.opts.verbose && (n += " , schema: validate.schema" + d + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + c + " "),
        n += " } ") : n += " {} ";
        var L = n;
        return n = C.pop(),
        !e.compositeRule && g ? e.async ? n += " throw new ValidationError([" + L + "]); " : n += " validate.errors = [" + L + "]; return false; " : n += " var err = " + L + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",
        n += " } else { ",
        w && (n += "  errors = " + p + "; if (vErrors !== null) { if (" + p + ") vErrors.length = " + p + "; else vErrors = null; } "),
        e.opts.allErrors && (n += " } "),
        n
    }
      , kh = function(e, r, o) {
        var n = " "
          , s = e.level
          , i = e.dataLevel
          , l = e.schema[r]
          , d = e.schemaPath + e.util.getProperty(r)
          , u = e.errSchemaPath + "/" + r
          , g = !e.opts.allErrors
          , c = "data" + (i || "")
          , m = "errs__" + s
          , p = e.util.copy(e)
          , h = "";
        p.level++;
        var f = "valid" + p.level
          , y = {}
          , b = {}
          , x = e.opts.ownProperties;
        for (_ in l)
            if (_ != "__proto__") {
                var v = l[_]
                  , S = Array.isArray(v) ? b : y;
                S[_] = v
            }
        n += "var " + m + " = errors;";
        var w = e.errorPath;
        n += "var missing" + s + ";";
        for (var _ in b)
            if (S = b[_],
            S.length) {
                if (n += " if ( " + c + e.util.getProperty(_) + " !== undefined ",
                x && (n += " && Object.prototype.hasOwnProperty.call(" + c + ", '" + e.util.escapeQuotes(_) + "') "),
                g) {
                    n += " && ( ";
                    var I = S;
                    if (I)
                        for (var k, C = -1, L = I.length - 1; C < L; ) {
                            k = I[C += 1],
                            C && (n += " || ");
                            var N = e.util.getProperty(k)
                              , A = c + N;
                            n += " ( ( " + A + " === undefined ",
                            x && (n += " || ! Object.prototype.hasOwnProperty.call(" + c + ", '" + e.util.escapeQuotes(k) + "') "),
                            n += ") && (missing" + s + " = " + e.util.toQuotedString(e.opts.jsonPointers ? k : N) + ") ) "
                        }
                    n += ")) {  ";
                    var $ = "missing" + s
                      , R = "' + " + $ + " + '";
                    e.opts._errorDataPathProperty && (e.errorPath = e.opts.jsonPointers ? e.util.getPathExpr(w, $, !0) : w + " + " + $);
                    var q = q || [];
                    q.push(n),
                    n = "",
                    e.createErrors !== !1 ? (n += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { property: '" + e.util.escapeQuotes(_) + "', missingProperty: '" + R + "', depsCount: " + S.length + ", deps: '" + e.util.escapeQuotes(S.length == 1 ? S[0] : S.join(", ")) + "' } ",
                    e.opts.messages !== !1 && (n += " , message: 'should have ",
                    S.length == 1 ? n += "property " + e.util.escapeQuotes(S[0]) : n += "properties " + e.util.escapeQuotes(S.join(", ")),
                    n += " when property " + e.util.escapeQuotes(_) + " is present' "),
                    e.opts.verbose && (n += " , schema: validate.schema" + d + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + c + " "),
                    n += " } ") : n += " {} ";
                    var ee = n;
                    n = q.pop(),
                    !e.compositeRule && g ? e.async ? n += " throw new ValidationError([" + ee + "]); " : n += " validate.errors = [" + ee + "]; return false; " : n += " var err = " + ee + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "
                } else {
                    n += " ) { ";
                    var ne = S;
                    if (ne)
                        for (var k, te = -1, re = ne.length - 1; te < re; ) {
                            k = ne[te += 1];
                            var N = e.util.getProperty(k)
                              , R = e.util.escapeQuotes(k)
                              , A = c + N;
                            e.opts._errorDataPathProperty && (e.errorPath = e.util.getPath(w, k, e.opts.jsonPointers)),
                            n += " if ( " + A + " === undefined ",
                            x && (n += " || ! Object.prototype.hasOwnProperty.call(" + c + ", '" + e.util.escapeQuotes(k) + "') "),
                            n += ") {  var err =   ",
                            e.createErrors !== !1 ? (n += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { property: '" + e.util.escapeQuotes(_) + "', missingProperty: '" + R + "', depsCount: " + S.length + ", deps: '" + e.util.escapeQuotes(S.length == 1 ? S[0] : S.join(", ")) + "' } ",
                            e.opts.messages !== !1 && (n += " , message: 'should have ",
                            S.length == 1 ? n += "property " + e.util.escapeQuotes(S[0]) : n += "properties " + e.util.escapeQuotes(S.join(", ")),
                            n += " when property " + e.util.escapeQuotes(_) + " is present' "),
                            e.opts.verbose && (n += " , schema: validate.schema" + d + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + c + " "),
                            n += " } ") : n += " {} ",
                            n += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } "
                        }
                }
                n += " }   ",
                g && (h += "}",
                n += " else { ")
            }
        e.errorPath = w;
        var Q = p.baseId;
        for (var _ in y) {
            var v = y[_];
            (e.opts.strictKeywords ? typeof v == "object" && Object.keys(v).length > 0 || v === !1 : e.util.schemaHasRules(v, e.RULES.all)) && (n += " " + f + " = true; if ( " + c + e.util.getProperty(_) + " !== undefined ",
            x && (n += " && Object.prototype.hasOwnProperty.call(" + c + ", '" + e.util.escapeQuotes(_) + "') "),
            n += ") { ",
            p.schema = v,
            p.schemaPath = d + e.util.getProperty(_),
            p.errSchemaPath = u + "/" + e.util.escapeFragment(_),
            n += "  " + e.validate(p) + " ",
            p.baseId = Q,
            n += " }  ",
            g && (n += " if (" + f + ") { ",
            h += "}"))
        }
        return g && (n += "   " + h + " if (" + m + " == errors) {"),
        n
    }
      , Ih = function(e, r, o) {
        var n = " "
          , s = e.level
          , i = e.dataLevel
          , l = e.schema[r]
          , d = e.schemaPath + e.util.getProperty(r)
          , u = e.errSchemaPath + "/" + r
          , g = !e.opts.allErrors
          , c = "data" + (i || "")
          , m = "valid" + s
          , p = e.opts.$data && l && l.$data;
        p && (n += " var schema" + s + " = " + e.util.getData(l.$data, i, e.dataPathArr) + "; ");
        var h = "i" + s
          , f = "schema" + s;
        p || (n += " var " + f + " = validate.schema" + d + ";"),
        n += "var " + m + ";",
        p && (n += " if (schema" + s + " === undefined) " + m + " = true; else if (!Array.isArray(schema" + s + ")) " + m + " = false; else {"),
        n += "" + m + " = false;for (var " + h + "=0; " + h + "<" + f + ".length; " + h + "++) if (equal(" + c + ", " + f + "[" + h + "])) { " + m + " = true; break; }",
        p && (n += "  }  "),
        n += " if (!" + m + ") {   ";
        var y = y || [];
        y.push(n),
        n = "",
        e.createErrors !== !1 ? (n += " { keyword: 'enum' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { allowedValues: schema" + s + " } ",
        e.opts.messages !== !1 && (n += " , message: 'should be equal to one of the allowed values' "),
        e.opts.verbose && (n += " , schema: validate.schema" + d + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + c + " "),
        n += " } ") : n += " {} ";
        var b = n;
        return n = y.pop(),
        !e.compositeRule && g ? e.async ? n += " throw new ValidationError([" + b + "]); " : n += " validate.errors = [" + b + "]; return false; " : n += " var err = " + b + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",
        n += " }",
        g && (n += " else { "),
        n
    }
      , Ch = function(e, r, o) {
        var n = " "
          , s = e.level
          , i = e.dataLevel
          , l = e.schema[r]
          , d = e.schemaPath + e.util.getProperty(r)
          , u = e.errSchemaPath + "/" + r
          , g = !e.opts.allErrors
          , c = "data" + (i || "");
        if (e.opts.format === !1)
            return g && (n += " if (true) { "),
            n;
        var m = e.opts.$data && l && l.$data, p;
        m ? (n += " var schema" + s + " = " + e.util.getData(l.$data, i, e.dataPathArr) + "; ",
        p = "schema" + s) : p = l;
        var h = e.opts.unknownFormats
          , f = Array.isArray(h);
        if (m) {
            var y = "format" + s
              , b = "isObject" + s
              , x = "formatType" + s;
            n += " var " + y + " = formats[" + p + "]; var " + b + " = typeof " + y + " == 'object' && !(" + y + " instanceof RegExp) && " + y + ".validate; var " + x + " = " + b + " && " + y + ".type || 'string'; if (" + b + ") { ",
            e.async && (n += " var async" + s + " = " + y + ".async; "),
            n += " " + y + " = " + y + ".validate; } if (  ",
            m && (n += " (" + p + " !== undefined && typeof " + p + " != 'string') || "),
            n += " (",
            h != "ignore" && (n += " (" + p + " && !" + y + " ",
            f && (n += " && self._opts.unknownFormats.indexOf(" + p + ") == -1 "),
            n += ") || "),
            n += " (" + y + " && " + x + " == '" + o + "' && !(typeof " + y + " == 'function' ? ",
            e.async ? n += " (async" + s + " ? await " + y + "(" + c + ") : " + y + "(" + c + ")) " : n += " " + y + "(" + c + ") ",
            n += " : " + y + ".test(" + c + "))))) {"
        } else {
            var y = e.formats[l];
            if (!y) {
                if (h == "ignore")
                    return e.logger.warn('unknown format "' + l + '" ignored in schema at path "' + e.errSchemaPath + '"'),
                    g && (n += " if (true) { "),
                    n;
                if (f && h.indexOf(l) >= 0)
                    return g && (n += " if (true) { "),
                    n;
                throw new Error('unknown format "' + l + '" is used in schema at path "' + e.errSchemaPath + '"')
            }
            var b = typeof y == "object" && !(y instanceof RegExp) && y.validate
              , x = b && y.type || "string";
            if (b) {
                var v = y.async === !0;
                y = y.validate
            }
            if (x != o)
                return g && (n += " if (true) { "),
                n;
            if (v) {
                if (!e.async)
                    throw new Error("async format in sync schema");
                var S = "formats" + e.util.getProperty(l) + ".validate";
                n += " if (!(await " + S + "(" + c + "))) { "
            } else {
                n += " if (! ";
                var S = "formats" + e.util.getProperty(l);
                b && (S += ".validate"),
                typeof y == "function" ? n += " " + S + "(" + c + ") " : n += " " + S + ".test(" + c + ") ",
                n += ") { "
            }
        }
        var w = w || [];
        w.push(n),
        n = "",
        e.createErrors !== !1 ? (n += " { keyword: 'format' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { format:  ",
        m ? n += "" + p : n += "" + e.util.toQuotedString(l),
        n += "  } ",
        e.opts.messages !== !1 && (n += ` , message: 'should match format "`,
        m ? n += "' + " + p + " + '" : n += "" + e.util.escapeQuotes(l),
        n += `"' `),
        e.opts.verbose && (n += " , schema:  ",
        m ? n += "validate.schema" + d : n += "" + e.util.toQuotedString(l),
        n += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + c + " "),
        n += " } ") : n += " {} ";
        var _ = n;
        return n = w.pop(),
        !e.compositeRule && g ? e.async ? n += " throw new ValidationError([" + _ + "]); " : n += " validate.errors = [" + _ + "]; return false; " : n += " var err = " + _ + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",
        n += " } ",
        g && (n += " else { "),
        n
    }
      , $h = function(e, r, o) {
        var n = " "
          , s = e.level
          , i = e.dataLevel
          , l = e.schema[r]
          , d = e.schemaPath + e.util.getProperty(r)
          , u = e.errSchemaPath + "/" + r
          , g = !e.opts.allErrors
          , c = "data" + (i || "")
          , m = "valid" + s
          , p = "errs__" + s
          , h = e.util.copy(e);
        h.level++;
        var f = "valid" + h.level
          , y = e.schema.then
          , b = e.schema.else
          , x = y !== void 0 && (e.opts.strictKeywords ? typeof y == "object" && Object.keys(y).length > 0 || y === !1 : e.util.schemaHasRules(y, e.RULES.all))
          , v = b !== void 0 && (e.opts.strictKeywords ? typeof b == "object" && Object.keys(b).length > 0 || b === !1 : e.util.schemaHasRules(b, e.RULES.all))
          , S = h.baseId;
        if (x || v) {
            var w;
            h.createErrors = !1,
            h.schema = l,
            h.schemaPath = d,
            h.errSchemaPath = u,
            n += " var " + p + " = errors; var " + m + " = true;  ";
            var _ = e.compositeRule;
            e.compositeRule = h.compositeRule = !0,
            n += "  " + e.validate(h) + " ",
            h.baseId = S,
            h.createErrors = !0,
            n += "  errors = " + p + "; if (vErrors !== null) { if (" + p + ") vErrors.length = " + p + "; else vErrors = null; }  ",
            e.compositeRule = h.compositeRule = _,
            x ? (n += " if (" + f + ") {  ",
            h.schema = e.schema.then,
            h.schemaPath = e.schemaPath + ".then",
            h.errSchemaPath = e.errSchemaPath + "/then",
            n += "  " + e.validate(h) + " ",
            h.baseId = S,
            n += " " + m + " = " + f + "; ",
            x && v ? (w = "ifClause" + s,
            n += " var " + w + " = 'then'; ") : w = "'then'",
            n += " } ",
            v && (n += " else { ")) : n += " if (!" + f + ") { ",
            v && (h.schema = e.schema.else,
            h.schemaPath = e.schemaPath + ".else",
            h.errSchemaPath = e.errSchemaPath + "/else",
            n += "  " + e.validate(h) + " ",
            h.baseId = S,
            n += " " + m + " = " + f + "; ",
            x && v ? (w = "ifClause" + s,
            n += " var " + w + " = 'else'; ") : w = "'else'",
            n += " } "),
            n += " if (!" + m + ") {   var err =   ",
            e.createErrors !== !1 ? (n += " { keyword: 'if' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { failingKeyword: " + w + " } ",
            e.opts.messages !== !1 && (n += ` , message: 'should match "' + ` + w + ` + '" schema' `),
            e.opts.verbose && (n += " , schema: validate.schema" + d + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + c + " "),
            n += " } ") : n += " {} ",
            n += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",
            !e.compositeRule && g && (e.async ? n += " throw new ValidationError(vErrors); " : n += " validate.errors = vErrors; return false; "),
            n += " }   ",
            g && (n += " else { ")
        } else
            g && (n += " if (true) { ");
        return n
    }
      , Ah = function(e, r, o) {
        var n = " "
          , s = e.level
          , i = e.dataLevel
          , l = e.schema[r]
          , d = e.schemaPath + e.util.getProperty(r)
          , u = e.errSchemaPath + "/" + r
          , g = !e.opts.allErrors
          , c = "data" + (i || "")
          , m = "valid" + s
          , p = "errs__" + s
          , h = e.util.copy(e)
          , f = "";
        h.level++;
        var y = "valid" + h.level
          , b = "i" + s
          , x = h.dataLevel = e.dataLevel + 1
          , v = "data" + x
          , S = e.baseId;
        if (n += "var " + p + " = errors;var " + m + ";",
        Array.isArray(l)) {
            var w = e.schema.additionalItems;
            if (w === !1) {
                n += " " + m + " = " + c + ".length <= " + l.length + "; ";
                var _ = u;
                u = e.errSchemaPath + "/additionalItems",
                n += "  if (!" + m + ") {   ";
                var I = I || [];
                I.push(n),
                n = "",
                e.createErrors !== !1 ? (n += " { keyword: 'additionalItems' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { limit: " + l.length + " } ",
                e.opts.messages !== !1 && (n += " , message: 'should NOT have more than " + l.length + " items' "),
                e.opts.verbose && (n += " , schema: false , parentSchema: validate.schema" + e.schemaPath + " , data: " + c + " "),
                n += " } ") : n += " {} ";
                var k = n;
                n = I.pop(),
                !e.compositeRule && g ? e.async ? n += " throw new ValidationError([" + k + "]); " : n += " validate.errors = [" + k + "]; return false; " : n += " var err = " + k + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",
                n += " } ",
                u = _,
                g && (f += "}",
                n += " else { ")
            }
            var C = l;
            if (C) {
                for (var L, N = -1, A = C.length - 1; N < A; )
                    if (L = C[N += 1],
                    e.opts.strictKeywords ? typeof L == "object" && Object.keys(L).length > 0 || L === !1 : e.util.schemaHasRules(L, e.RULES.all)) {
                        n += " " + y + " = true; if (" + c + ".length > " + N + ") { ";
                        var $ = c + "[" + N + "]";
                        h.schema = L,
                        h.schemaPath = d + "[" + N + "]",
                        h.errSchemaPath = u + "/" + N,
                        h.errorPath = e.util.getPathExpr(e.errorPath, N, e.opts.jsonPointers, !0),
                        h.dataPathArr[x] = N;
                        var R = e.validate(h);
                        h.baseId = S,
                        e.util.varOccurences(R, v) < 2 ? n += " " + e.util.varReplace(R, v, $) + " " : n += " var " + v + " = " + $ + "; " + R + " ",
                        n += " }  ",
                        g && (n += " if (" + y + ") { ",
                        f += "}")
                    }
            }
            if (typeof w == "object" && (e.opts.strictKeywords ? typeof w == "object" && Object.keys(w).length > 0 || w === !1 : e.util.schemaHasRules(w, e.RULES.all))) {
                h.schema = w,
                h.schemaPath = e.schemaPath + ".additionalItems",
                h.errSchemaPath = e.errSchemaPath + "/additionalItems",
                n += " " + y + " = true; if (" + c + ".length > " + l.length + ") {  for (var " + b + " = " + l.length + "; " + b + " < " + c + ".length; " + b + "++) { ",
                h.errorPath = e.util.getPathExpr(e.errorPath, b, e.opts.jsonPointers, !0);
                var $ = c + "[" + b + "]";
                h.dataPathArr[x] = b;
                var R = e.validate(h);
                h.baseId = S,
                e.util.varOccurences(R, v) < 2 ? n += " " + e.util.varReplace(R, v, $) + " " : n += " var " + v + " = " + $ + "; " + R + " ",
                g && (n += " if (!" + y + ") break; "),
                n += " } }  ",
                g && (n += " if (" + y + ") { ",
                f += "}")
            }
        } else if (e.opts.strictKeywords ? typeof l == "object" && Object.keys(l).length > 0 || l === !1 : e.util.schemaHasRules(l, e.RULES.all)) {
            h.schema = l,
            h.schemaPath = d,
            h.errSchemaPath = u,
            n += "  for (var " + b + " = 0; " + b + " < " + c + ".length; " + b + "++) { ",
            h.errorPath = e.util.getPathExpr(e.errorPath, b, e.opts.jsonPointers, !0);
            var $ = c + "[" + b + "]";
            h.dataPathArr[x] = b;
            var R = e.validate(h);
            h.baseId = S,
            e.util.varOccurences(R, v) < 2 ? n += " " + e.util.varReplace(R, v, $) + " " : n += " var " + v + " = " + $ + "; " + R + " ",
            g && (n += " if (!" + y + ") break; "),
            n += " }"
        }
        return g && (n += " " + f + " if (" + p + " == errors) {"),
        n
    }
      , rc = function(e, r, o) {
        var n = " ", s = e.level, i = e.dataLevel, l = e.schema[r], d = e.schemaPath + e.util.getProperty(r), u = e.errSchemaPath + "/" + r, g = !e.opts.allErrors, S, c = "data" + (i || ""), m = e.opts.$data && l && l.$data, p;
        m ? (n += " var schema" + s + " = " + e.util.getData(l.$data, i, e.dataPathArr) + "; ",
        p = "schema" + s) : p = l;
        var h = r == "maximum"
          , f = h ? "exclusiveMaximum" : "exclusiveMinimum"
          , y = e.schema[f]
          , b = e.opts.$data && y && y.$data
          , x = h ? "<" : ">"
          , v = h ? ">" : "<"
          , S = void 0;
        if (!(m || typeof l == "number" || l === void 0))
            throw new Error(r + " must be number");
        if (!(b || y === void 0 || typeof y == "number" || typeof y == "boolean"))
            throw new Error(f + " must be number or boolean");
        if (b) {
            var w = e.util.getData(y.$data, i, e.dataPathArr)
              , _ = "exclusive" + s
              , I = "exclType" + s
              , k = "exclIsNumber" + s
              , C = "op" + s
              , L = "' + " + C + " + '";
            n += " var schemaExcl" + s + " = " + w + "; ",
            w = "schemaExcl" + s,
            n += " var " + _ + "; var " + I + " = typeof " + w + "; if (" + I + " != 'boolean' && " + I + " != 'undefined' && " + I + " != 'number') { ";
            var S = f
              , N = N || [];
            N.push(n),
            n = "",
            e.createErrors !== !1 ? (n += " { keyword: '" + (S || "_exclusiveLimit") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: {} ",
            e.opts.messages !== !1 && (n += " , message: '" + f + " should be boolean' "),
            e.opts.verbose && (n += " , schema: validate.schema" + d + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + c + " "),
            n += " } ") : n += " {} ";
            var A = n;
            n = N.pop(),
            !e.compositeRule && g ? e.async ? n += " throw new ValidationError([" + A + "]); " : n += " validate.errors = [" + A + "]; return false; " : n += " var err = " + A + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",
            n += " } else if ( ",
            m && (n += " (" + p + " !== undefined && typeof " + p + " != 'number') || "),
            n += " " + I + " == 'number' ? ( (" + _ + " = " + p + " === undefined || " + w + " " + x + "= " + p + ") ? " + c + " " + v + "= " + w + " : " + c + " " + v + " " + p + " ) : ( (" + _ + " = " + w + " === true) ? " + c + " " + v + "= " + p + " : " + c + " " + v + " " + p + " ) || " + c + " !== " + c + ") { var op" + s + " = " + _ + " ? '" + x + "' : '" + x + "='; ",
            l === void 0 && (S = f,
            u = e.errSchemaPath + "/" + f,
            p = w,
            m = b)
        } else {
            var k = typeof y == "number"
              , L = x;
            if (k && m) {
                var C = "'" + L + "'";
                n += " if ( ",
                m && (n += " (" + p + " !== undefined && typeof " + p + " != 'number') || "),
                n += " ( " + p + " === undefined || " + y + " " + x + "= " + p + " ? " + c + " " + v + "= " + y + " : " + c + " " + v + " " + p + " ) || " + c + " !== " + c + ") { "
            } else {
                k && l === void 0 ? (_ = !0,
                S = f,
                u = e.errSchemaPath + "/" + f,
                p = y,
                v += "=") : (k && (p = Math[h ? "min" : "max"](y, l)),
                y === (k ? p : !0) ? (_ = !0,
                S = f,
                u = e.errSchemaPath + "/" + f,
                v += "=") : (_ = !1,
                L += "="));
                var C = "'" + L + "'";
                n += " if ( ",
                m && (n += " (" + p + " !== undefined && typeof " + p + " != 'number') || "),
                n += " " + c + " " + v + " " + p + " || " + c + " !== " + c + ") { "
            }
        }
        S = S || r;
        var N = N || [];
        N.push(n),
        n = "",
        e.createErrors !== !1 ? (n += " { keyword: '" + (S || "_limit") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { comparison: " + C + ", limit: " + p + ", exclusive: " + _ + " } ",
        e.opts.messages !== !1 && (n += " , message: 'should be " + L + " ",
        m ? n += "' + " + p : n += "" + p + "'"),
        e.opts.verbose && (n += " , schema:  ",
        m ? n += "validate.schema" + d : n += "" + l,
        n += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + c + " "),
        n += " } ") : n += " {} ";
        var A = n;
        return n = N.pop(),
        !e.compositeRule && g ? e.async ? n += " throw new ValidationError([" + A + "]); " : n += " validate.errors = [" + A + "]; return false; " : n += " var err = " + A + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",
        n += " } ",
        g && (n += " else { "),
        n
    }
      , nc = function(e, r, o) {
        var n = " ", s = e.level, i = e.dataLevel, l = e.schema[r], d = e.schemaPath + e.util.getProperty(r), u = e.errSchemaPath + "/" + r, g = !e.opts.allErrors, f, c = "data" + (i || ""), m = e.opts.$data && l && l.$data, p;
        if (m ? (n += " var schema" + s + " = " + e.util.getData(l.$data, i, e.dataPathArr) + "; ",
        p = "schema" + s) : p = l,
        !(m || typeof l == "number"))
            throw new Error(r + " must be number");
        var h = r == "maxItems" ? ">" : "<";
        n += "if ( ",
        m && (n += " (" + p + " !== undefined && typeof " + p + " != 'number') || "),
        n += " " + c + ".length " + h + " " + p + ") { ";
        var f = r
          , y = y || [];
        y.push(n),
        n = "",
        e.createErrors !== !1 ? (n += " { keyword: '" + (f || "_limitItems") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { limit: " + p + " } ",
        e.opts.messages !== !1 && (n += " , message: 'should NOT have ",
        r == "maxItems" ? n += "more" : n += "fewer",
        n += " than ",
        m ? n += "' + " + p + " + '" : n += "" + l,
        n += " items' "),
        e.opts.verbose && (n += " , schema:  ",
        m ? n += "validate.schema" + d : n += "" + l,
        n += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + c + " "),
        n += " } ") : n += " {} ";
        var b = n;
        return n = y.pop(),
        !e.compositeRule && g ? e.async ? n += " throw new ValidationError([" + b + "]); " : n += " validate.errors = [" + b + "]; return false; " : n += " var err = " + b + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",
        n += "} ",
        g && (n += " else { "),
        n
    }
      , oc = function(e, r, o) {
        var n = " ", s = e.level, i = e.dataLevel, l = e.schema[r], d = e.schemaPath + e.util.getProperty(r), u = e.errSchemaPath + "/" + r, g = !e.opts.allErrors, f, c = "data" + (i || ""), m = e.opts.$data && l && l.$data, p;
        if (m ? (n += " var schema" + s + " = " + e.util.getData(l.$data, i, e.dataPathArr) + "; ",
        p = "schema" + s) : p = l,
        !(m || typeof l == "number"))
            throw new Error(r + " must be number");
        var h = r == "maxLength" ? ">" : "<";
        n += "if ( ",
        m && (n += " (" + p + " !== undefined && typeof " + p + " != 'number') || "),
        e.opts.unicode === !1 ? n += " " + c + ".length " : n += " ucs2length(" + c + ") ",
        n += " " + h + " " + p + ") { ";
        var f = r
          , y = y || [];
        y.push(n),
        n = "",
        e.createErrors !== !1 ? (n += " { keyword: '" + (f || "_limitLength") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { limit: " + p + " } ",
        e.opts.messages !== !1 && (n += " , message: 'should NOT be ",
        r == "maxLength" ? n += "longer" : n += "shorter",
        n += " than ",
        m ? n += "' + " + p + " + '" : n += "" + l,
        n += " characters' "),
        e.opts.verbose && (n += " , schema:  ",
        m ? n += "validate.schema" + d : n += "" + l,
        n += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + c + " "),
        n += " } ") : n += " {} ";
        var b = n;
        return n = y.pop(),
        !e.compositeRule && g ? e.async ? n += " throw new ValidationError([" + b + "]); " : n += " validate.errors = [" + b + "]; return false; " : n += " var err = " + b + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",
        n += "} ",
        g && (n += " else { "),
        n
    }
      , sc = function(e, r, o) {
        var n = " ", s = e.level, i = e.dataLevel, l = e.schema[r], d = e.schemaPath + e.util.getProperty(r), u = e.errSchemaPath + "/" + r, g = !e.opts.allErrors, f, c = "data" + (i || ""), m = e.opts.$data && l && l.$data, p;
        if (m ? (n += " var schema" + s + " = " + e.util.getData(l.$data, i, e.dataPathArr) + "; ",
        p = "schema" + s) : p = l,
        !(m || typeof l == "number"))
            throw new Error(r + " must be number");
        var h = r == "maxProperties" ? ">" : "<";
        n += "if ( ",
        m && (n += " (" + p + " !== undefined && typeof " + p + " != 'number') || "),
        n += " Object.keys(" + c + ").length " + h + " " + p + ") { ";
        var f = r
          , y = y || [];
        y.push(n),
        n = "",
        e.createErrors !== !1 ? (n += " { keyword: '" + (f || "_limitProperties") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { limit: " + p + " } ",
        e.opts.messages !== !1 && (n += " , message: 'should NOT have ",
        r == "maxProperties" ? n += "more" : n += "fewer",
        n += " than ",
        m ? n += "' + " + p + " + '" : n += "" + l,
        n += " properties' "),
        e.opts.verbose && (n += " , schema:  ",
        m ? n += "validate.schema" + d : n += "" + l,
        n += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + c + " "),
        n += " } ") : n += " {} ";
        var b = n;
        return n = y.pop(),
        !e.compositeRule && g ? e.async ? n += " throw new ValidationError([" + b + "]); " : n += " validate.errors = [" + b + "]; return false; " : n += " var err = " + b + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",
        n += "} ",
        g && (n += " else { "),
        n
    }
      , Rh = function(e, r, o) {
        var n = " ", s = e.level, i = e.dataLevel, l = e.schema[r], d = e.schemaPath + e.util.getProperty(r), u = e.errSchemaPath + "/" + r, g = !e.opts.allErrors, c = "data" + (i || ""), m = e.opts.$data && l && l.$data, p;
        if (m ? (n += " var schema" + s + " = " + e.util.getData(l.$data, i, e.dataPathArr) + "; ",
        p = "schema" + s) : p = l,
        !(m || typeof l == "number"))
            throw new Error(r + " must be number");
        n += "var division" + s + ";if (",
        m && (n += " " + p + " !== undefined && ( typeof " + p + " != 'number' || "),
        n += " (division" + s + " = " + c + " / " + p + ", ",
        e.opts.multipleOfPrecision ? n += " Math.abs(Math.round(division" + s + ") - division" + s + ") > 1e-" + e.opts.multipleOfPrecision + " " : n += " division" + s + " !== parseInt(division" + s + ") ",
        n += " ) ",
        m && (n += "  )  "),
        n += " ) {   ";
        var h = h || [];
        h.push(n),
        n = "",
        e.createErrors !== !1 ? (n += " { keyword: 'multipleOf' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { multipleOf: " + p + " } ",
        e.opts.messages !== !1 && (n += " , message: 'should be multiple of ",
        m ? n += "' + " + p : n += "" + p + "'"),
        e.opts.verbose && (n += " , schema:  ",
        m ? n += "validate.schema" + d : n += "" + l,
        n += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + c + " "),
        n += " } ") : n += " {} ";
        var f = n;
        return n = h.pop(),
        !e.compositeRule && g ? e.async ? n += " throw new ValidationError([" + f + "]); " : n += " validate.errors = [" + f + "]; return false; " : n += " var err = " + f + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",
        n += "} ",
        g && (n += " else { "),
        n
    }
      , Oh = function(e, r, o) {
        var n = " "
          , s = e.level
          , i = e.dataLevel
          , l = e.schema[r]
          , d = e.schemaPath + e.util.getProperty(r)
          , u = e.errSchemaPath + "/" + r
          , g = !e.opts.allErrors
          , c = "data" + (i || "")
          , m = "errs__" + s
          , p = e.util.copy(e);
        p.level++;
        var h = "valid" + p.level;
        if (e.opts.strictKeywords ? typeof l == "object" && Object.keys(l).length > 0 || l === !1 : e.util.schemaHasRules(l, e.RULES.all)) {
            p.schema = l,
            p.schemaPath = d,
            p.errSchemaPath = u,
            n += " var " + m + " = errors;  ";
            var f = e.compositeRule;
            e.compositeRule = p.compositeRule = !0,
            p.createErrors = !1;
            var y;
            p.opts.allErrors && (y = p.opts.allErrors,
            p.opts.allErrors = !1),
            n += " " + e.validate(p) + " ",
            p.createErrors = !0,
            y && (p.opts.allErrors = y),
            e.compositeRule = p.compositeRule = f,
            n += " if (" + h + ") {   ";
            var b = b || [];
            b.push(n),
            n = "",
            e.createErrors !== !1 ? (n += " { keyword: 'not' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: {} ",
            e.opts.messages !== !1 && (n += " , message: 'should NOT be valid' "),
            e.opts.verbose && (n += " , schema: validate.schema" + d + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + c + " "),
            n += " } ") : n += " {} ";
            var x = n;
            n = b.pop(),
            !e.compositeRule && g ? e.async ? n += " throw new ValidationError([" + x + "]); " : n += " validate.errors = [" + x + "]; return false; " : n += " var err = " + x + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",
            n += " } else {  errors = " + m + "; if (vErrors !== null) { if (" + m + ") vErrors.length = " + m + "; else vErrors = null; } ",
            e.opts.allErrors && (n += " } ")
        } else
            n += "  var err =   ",
            e.createErrors !== !1 ? (n += " { keyword: 'not' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: {} ",
            e.opts.messages !== !1 && (n += " , message: 'should NOT be valid' "),
            e.opts.verbose && (n += " , schema: validate.schema" + d + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + c + " "),
            n += " } ") : n += " {} ",
            n += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",
            g && (n += " if (false) { ");
        return n
    }
      , Dh = function(e, r, o) {
        var n = " "
          , s = e.level
          , i = e.dataLevel
          , l = e.schema[r]
          , d = e.schemaPath + e.util.getProperty(r)
          , u = e.errSchemaPath + "/" + r
          , g = !e.opts.allErrors
          , c = "data" + (i || "")
          , m = "valid" + s
          , p = "errs__" + s
          , h = e.util.copy(e)
          , f = "";
        h.level++;
        var y = "valid" + h.level
          , b = h.baseId
          , x = "prevValid" + s
          , v = "passingSchemas" + s;
        n += "var " + p + " = errors , " + x + " = false , " + m + " = false , " + v + " = null; ";
        var S = e.compositeRule;
        e.compositeRule = h.compositeRule = !0;
        var w = l;
        if (w)
            for (var _, I = -1, k = w.length - 1; I < k; )
                _ = w[I += 1],
                (e.opts.strictKeywords ? typeof _ == "object" && Object.keys(_).length > 0 || _ === !1 : e.util.schemaHasRules(_, e.RULES.all)) ? (h.schema = _,
                h.schemaPath = d + "[" + I + "]",
                h.errSchemaPath = u + "/" + I,
                n += "  " + e.validate(h) + " ",
                h.baseId = b) : n += " var " + y + " = true; ",
                I && (n += " if (" + y + " && " + x + ") { " + m + " = false; " + v + " = [" + v + ", " + I + "]; } else { ",
                f += "}"),
                n += " if (" + y + ") { " + m + " = " + x + " = true; " + v + " = " + I + "; }";
        return e.compositeRule = h.compositeRule = S,
        n += "" + f + "if (!" + m + ") {   var err =   ",
        e.createErrors !== !1 ? (n += " { keyword: 'oneOf' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { passingSchemas: " + v + " } ",
        e.opts.messages !== !1 && (n += " , message: 'should match exactly one schema in oneOf' "),
        e.opts.verbose && (n += " , schema: validate.schema" + d + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + c + " "),
        n += " } ") : n += " {} ",
        n += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",
        !e.compositeRule && g && (e.async ? n += " throw new ValidationError(vErrors); " : n += " validate.errors = vErrors; return false; "),
        n += "} else {  errors = " + p + "; if (vErrors !== null) { if (" + p + ") vErrors.length = " + p + "; else vErrors = null; }",
        e.opts.allErrors && (n += " } "),
        n
    }
      , Nh = function(e, r, o) {
        var n = " ", s = e.level, i = e.dataLevel, l = e.schema[r], d = e.schemaPath + e.util.getProperty(r), u = e.errSchemaPath + "/" + r, g = !e.opts.allErrors, c = "data" + (i || ""), m = e.opts.$data && l && l.$data, p;
        m ? (n += " var schema" + s + " = " + e.util.getData(l.$data, i, e.dataPathArr) + "; ",
        p = "schema" + s) : p = l;
        var h = m ? "(new RegExp(" + p + "))" : e.usePattern(l);
        n += "if ( ",
        m && (n += " (" + p + " !== undefined && typeof " + p + " != 'string') || "),
        n += " !" + h + ".test(" + c + ") ) {   ";
        var f = f || [];
        f.push(n),
        n = "",
        e.createErrors !== !1 ? (n += " { keyword: 'pattern' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { pattern:  ",
        m ? n += "" + p : n += "" + e.util.toQuotedString(l),
        n += "  } ",
        e.opts.messages !== !1 && (n += ` , message: 'should match pattern "`,
        m ? n += "' + " + p + " + '" : n += "" + e.util.escapeQuotes(l),
        n += `"' `),
        e.opts.verbose && (n += " , schema:  ",
        m ? n += "validate.schema" + d : n += "" + e.util.toQuotedString(l),
        n += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + c + " "),
        n += " } ") : n += " {} ";
        var y = n;
        return n = f.pop(),
        !e.compositeRule && g ? e.async ? n += " throw new ValidationError([" + y + "]); " : n += " validate.errors = [" + y + "]; return false; " : n += " var err = " + y + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",
        n += "} ",
        g && (n += " else { "),
        n
    }
      , Lh = function(e, r, o) {
        var n = " "
          , s = e.level
          , i = e.dataLevel
          , l = e.schema[r]
          , d = e.schemaPath + e.util.getProperty(r)
          , u = e.errSchemaPath + "/" + r
          , g = !e.opts.allErrors
          , c = "data" + (i || "")
          , m = "errs__" + s
          , p = e.util.copy(e)
          , h = "";
        p.level++;
        var f = "valid" + p.level
          , y = "key" + s
          , b = "idx" + s
          , x = p.dataLevel = e.dataLevel + 1
          , v = "data" + x
          , S = "dataProperties" + s
          , w = Object.keys(l || {}).filter(te)
          , _ = e.schema.patternProperties || {}
          , I = Object.keys(_).filter(te)
          , k = e.schema.additionalProperties
          , C = w.length || I.length
          , L = k === !1
          , N = typeof k == "object" && Object.keys(k).length
          , A = e.opts.removeAdditional
          , $ = L || N || A
          , R = e.opts.ownProperties
          , q = e.baseId
          , ee = e.schema.required;
        if (ee && !(e.opts.$data && ee.$data) && ee.length < e.opts.loopRequired)
            var ne = e.util.toHash(ee);
        function te(bi) {
            return bi !== "__proto__"
        }
        if (n += "var " + m + " = errors;var " + f + " = true;",
        R && (n += " var " + S + " = undefined;"),
        $) {
            if (R ? n += " " + S + " = " + S + " || Object.keys(" + c + "); for (var " + b + "=0; " + b + "<" + S + ".length; " + b + "++) { var " + y + " = " + S + "[" + b + "]; " : n += " for (var " + y + " in " + c + ") { ",
            C) {
                if (n += " var isAdditional" + s + " = !(false ",
                w.length)
                    if (w.length > 8)
                        n += " || validate.schema" + d + ".hasOwnProperty(" + y + ") ";
                    else {
                        var re = w;
                        if (re)
                            for (var Q, Ie = -1, Fe = re.length - 1; Ie < Fe; )
                                Q = re[Ie += 1],
                                n += " || " + y + " == " + e.util.toQuotedString(Q) + " "
                    }
                if (I.length) {
                    var We = I;
                    if (We)
                        for (var ve, qe = -1, Ke = We.length - 1; qe < Ke; )
                            ve = We[qe += 1],
                            n += " || " + e.usePattern(ve) + ".test(" + y + ") "
                }
                n += " ); if (isAdditional" + s + ") { "
            }
            if (A == "all")
                n += " delete " + c + "[" + y + "]; ";
            else {
                var Te = e.errorPath
                  , Ve = "' + " + y + " + '";
                if (e.opts._errorDataPathProperty && (e.errorPath = e.util.getPathExpr(e.errorPath, y, e.opts.jsonPointers)),
                L)
                    if (A)
                        n += " delete " + c + "[" + y + "]; ";
                    else {
                        n += " " + f + " = false; ";
                        var rt = u;
                        u = e.errSchemaPath + "/additionalProperties";
                        var Ge = Ge || [];
                        Ge.push(n),
                        n = "",
                        e.createErrors !== !1 ? (n += " { keyword: 'additionalProperties' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { additionalProperty: '" + Ve + "' } ",
                        e.opts.messages !== !1 && (n += " , message: '",
                        e.opts._errorDataPathProperty ? n += "is an invalid additional property" : n += "should NOT have additional properties",
                        n += "' "),
                        e.opts.verbose && (n += " , schema: false , parentSchema: validate.schema" + e.schemaPath + " , data: " + c + " "),
                        n += " } ") : n += " {} ";
                        var Ce = n;
                        n = Ge.pop(),
                        !e.compositeRule && g ? e.async ? n += " throw new ValidationError([" + Ce + "]); " : n += " validate.errors = [" + Ce + "]; return false; " : n += " var err = " + Ce + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",
                        u = rt,
                        g && (n += " break; ")
                    }
                else if (N)
                    if (A == "failing") {
                        n += " var " + m + " = errors;  ";
                        var Ut = e.compositeRule;
                        e.compositeRule = p.compositeRule = !0,
                        p.schema = k,
                        p.schemaPath = e.schemaPath + ".additionalProperties",
                        p.errSchemaPath = e.errSchemaPath + "/additionalProperties",
                        p.errorPath = e.opts._errorDataPathProperty ? e.errorPath : e.util.getPathExpr(e.errorPath, y, e.opts.jsonPointers);
                        var Qe = c + "[" + y + "]";
                        p.dataPathArr[x] = y;
                        var Oe = e.validate(p);
                        p.baseId = q,
                        e.util.varOccurences(Oe, v) < 2 ? n += " " + e.util.varReplace(Oe, v, Qe) + " " : n += " var " + v + " = " + Qe + "; " + Oe + " ",
                        n += " if (!" + f + ") { errors = " + m + "; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete " + c + "[" + y + "]; }  ",
                        e.compositeRule = p.compositeRule = Ut
                    } else {
                        p.schema = k,
                        p.schemaPath = e.schemaPath + ".additionalProperties",
                        p.errSchemaPath = e.errSchemaPath + "/additionalProperties",
                        p.errorPath = e.opts._errorDataPathProperty ? e.errorPath : e.util.getPathExpr(e.errorPath, y, e.opts.jsonPointers);
                        var Qe = c + "[" + y + "]";
                        p.dataPathArr[x] = y;
                        var Oe = e.validate(p);
                        p.baseId = q,
                        e.util.varOccurences(Oe, v) < 2 ? n += " " + e.util.varReplace(Oe, v, Qe) + " " : n += " var " + v + " = " + Qe + "; " + Oe + " ",
                        g && (n += " if (!" + f + ") break; ")
                    }
                e.errorPath = Te
            }
            C && (n += " } "),
            n += " }  ",
            g && (n += " if (" + f + ") { ",
            h += "}")
        }
        var br = e.opts.useDefaults && !e.compositeRule;
        if (w.length) {
            var st = w;
            if (st)
                for (var Q, an = -1, Nr = st.length - 1; an < Nr; ) {
                    Q = st[an += 1];
                    var nt = l[Q];
                    if (e.opts.strictKeywords ? typeof nt == "object" && Object.keys(nt).length > 0 || nt === !1 : e.util.schemaHasRules(nt, e.RULES.all)) {
                        var Sr = e.util.getProperty(Q)
                          , Qe = c + Sr
                          , Jn = br && nt.default !== void 0;
                        p.schema = nt,
                        p.schemaPath = d + Sr,
                        p.errSchemaPath = u + "/" + e.util.escapeFragment(Q),
                        p.errorPath = e.util.getPath(e.errorPath, Q, e.opts.jsonPointers),
                        p.dataPathArr[x] = e.util.toQuotedString(Q);
                        var Oe = e.validate(p);
                        if (p.baseId = q,
                        e.util.varOccurences(Oe, v) < 2) {
                            Oe = e.util.varReplace(Oe, v, Qe);
                            var Xe = Qe
                        } else {
                            var Xe = v;
                            n += " var " + v + " = " + Qe + "; "
                        }
                        if (Jn)
                            n += " " + Oe + " ";
                        else {
                            if (ne && ne[Q]) {
                                n += " if ( " + Xe + " === undefined ",
                                R && (n += " || ! Object.prototype.hasOwnProperty.call(" + c + ", '" + e.util.escapeQuotes(Q) + "') "),
                                n += ") { " + f + " = false; ";
                                var Te = e.errorPath
                                  , rt = u
                                  , et = e.util.escapeQuotes(Q);
                                e.opts._errorDataPathProperty && (e.errorPath = e.util.getPath(Te, Q, e.opts.jsonPointers)),
                                u = e.errSchemaPath + "/required";
                                var Ge = Ge || [];
                                Ge.push(n),
                                n = "",
                                e.createErrors !== !1 ? (n += " { keyword: 'required' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { missingProperty: '" + et + "' } ",
                                e.opts.messages !== !1 && (n += " , message: '",
                                e.opts._errorDataPathProperty ? n += "is a required property" : n += "should have required property \\'" + et + "\\'",
                                n += "' "),
                                e.opts.verbose && (n += " , schema: validate.schema" + d + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + c + " "),
                                n += " } ") : n += " {} ";
                                var Ce = n;
                                n = Ge.pop(),
                                !e.compositeRule && g ? e.async ? n += " throw new ValidationError([" + Ce + "]); " : n += " validate.errors = [" + Ce + "]; return false; " : n += " var err = " + Ce + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",
                                u = rt,
                                e.errorPath = Te,
                                n += " } else { "
                            } else
                                g ? (n += " if ( " + Xe + " === undefined ",
                                R && (n += " || ! Object.prototype.hasOwnProperty.call(" + c + ", '" + e.util.escapeQuotes(Q) + "') "),
                                n += ") { " + f + " = true; } else { ") : (n += " if (" + Xe + " !== undefined ",
                                R && (n += " &&   Object.prototype.hasOwnProperty.call(" + c + ", '" + e.util.escapeQuotes(Q) + "') "),
                                n += " ) { ");
                            n += " " + Oe + " } "
                        }
                    }
                    g && (n += " if (" + f + ") { ",
                    h += "}")
                }
        }
        if (I.length) {
            var ft = I;
            if (ft)
                for (var ve, xs = -1, wi = ft.length - 1; xs < wi; ) {
                    ve = ft[xs += 1];
                    var nt = _[ve];
                    if (e.opts.strictKeywords ? typeof nt == "object" && Object.keys(nt).length > 0 || nt === !1 : e.util.schemaHasRules(nt, e.RULES.all)) {
                        p.schema = nt,
                        p.schemaPath = e.schemaPath + ".patternProperties" + e.util.getProperty(ve),
                        p.errSchemaPath = e.errSchemaPath + "/patternProperties/" + e.util.escapeFragment(ve),
                        R ? n += " " + S + " = " + S + " || Object.keys(" + c + "); for (var " + b + "=0; " + b + "<" + S + ".length; " + b + "++) { var " + y + " = " + S + "[" + b + "]; " : n += " for (var " + y + " in " + c + ") { ",
                        n += " if (" + e.usePattern(ve) + ".test(" + y + ")) { ",
                        p.errorPath = e.util.getPathExpr(e.errorPath, y, e.opts.jsonPointers);
                        var Qe = c + "[" + y + "]";
                        p.dataPathArr[x] = y;
                        var Oe = e.validate(p);
                        p.baseId = q,
                        e.util.varOccurences(Oe, v) < 2 ? n += " " + e.util.varReplace(Oe, v, Qe) + " " : n += " var " + v + " = " + Qe + "; " + Oe + " ",
                        g && (n += " if (!" + f + ") break; "),
                        n += " } ",
                        g && (n += " else " + f + " = true; "),
                        n += " }  ",
                        g && (n += " if (" + f + ") { ",
                        h += "}")
                    }
                }
        }
        return g && (n += " " + h + " if (" + m + " == errors) {"),
        n
    }
      , Uh = function(e, r, o) {
        var n = " "
          , s = e.level
          , i = e.dataLevel
          , l = e.schema[r]
          , d = e.schemaPath + e.util.getProperty(r)
          , u = e.errSchemaPath + "/" + r
          , g = !e.opts.allErrors
          , c = "data" + (i || "")
          , m = "errs__" + s
          , p = e.util.copy(e)
          , h = "";
        p.level++;
        var f = "valid" + p.level;
        if (n += "var " + m + " = errors;",
        e.opts.strictKeywords ? typeof l == "object" && Object.keys(l).length > 0 || l === !1 : e.util.schemaHasRules(l, e.RULES.all)) {
            p.schema = l,
            p.schemaPath = d,
            p.errSchemaPath = u;
            var y = "key" + s
              , b = "idx" + s
              , x = "i" + s
              , v = "' + " + y + " + '"
              , S = p.dataLevel = e.dataLevel + 1
              , w = "data" + S
              , _ = "dataProperties" + s
              , I = e.opts.ownProperties
              , k = e.baseId;
            I && (n += " var " + _ + " = undefined; "),
            I ? n += " " + _ + " = " + _ + " || Object.keys(" + c + "); for (var " + b + "=0; " + b + "<" + _ + ".length; " + b + "++) { var " + y + " = " + _ + "[" + b + "]; " : n += " for (var " + y + " in " + c + ") { ",
            n += " var startErrs" + s + " = errors; ";
            var C = y
              , L = e.compositeRule;
            e.compositeRule = p.compositeRule = !0;
            var N = e.validate(p);
            p.baseId = k,
            e.util.varOccurences(N, w) < 2 ? n += " " + e.util.varReplace(N, w, C) + " " : n += " var " + w + " = " + C + "; " + N + " ",
            e.compositeRule = p.compositeRule = L,
            n += " if (!" + f + ") { for (var " + x + "=startErrs" + s + "; " + x + "<errors; " + x + "++) { vErrors[" + x + "].propertyName = " + y + "; }   var err =   ",
            e.createErrors !== !1 ? (n += " { keyword: 'propertyNames' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { propertyName: '" + v + "' } ",
            e.opts.messages !== !1 && (n += " , message: 'property name \\'" + v + "\\' is invalid' "),
            e.opts.verbose && (n += " , schema: validate.schema" + d + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + c + " "),
            n += " } ") : n += " {} ",
            n += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",
            !e.compositeRule && g && (e.async ? n += " throw new ValidationError(vErrors); " : n += " validate.errors = vErrors; return false; "),
            g && (n += " break; "),
            n += " } }"
        }
        return g && (n += " " + h + " if (" + m + " == errors) {"),
        n
    }
      , jh = function(e, r, o) {
        var n = " "
          , s = e.level
          , i = e.dataLevel
          , l = e.schema[r]
          , d = e.schemaPath + e.util.getProperty(r)
          , u = e.errSchemaPath + "/" + r
          , g = !e.opts.allErrors
          , c = "data" + (i || "")
          , m = "valid" + s
          , p = e.opts.$data && l && l.$data;
        p && (n += " var schema" + s + " = " + e.util.getData(l.$data, i, e.dataPathArr) + "; ");
        var h = "schema" + s;
        if (!p)
            if (l.length < e.opts.loopRequired && e.schema.properties && Object.keys(e.schema.properties).length) {
                var f = []
                  , y = l;
                if (y)
                    for (var b, x = -1, v = y.length - 1; x < v; ) {
                        b = y[x += 1];
                        var S = e.schema.properties[b];
                        S && (e.opts.strictKeywords ? typeof S == "object" && Object.keys(S).length > 0 || S === !1 : e.util.schemaHasRules(S, e.RULES.all)) || (f[f.length] = b)
                    }
            } else
                var f = l;
        if (p || f.length) {
            var w = e.errorPath
              , _ = p || f.length >= e.opts.loopRequired
              , I = e.opts.ownProperties;
            if (g)
                if (n += " var missing" + s + "; ",
                _) {
                    p || (n += " var " + h + " = validate.schema" + d + "; ");
                    var k = "i" + s
                      , C = "schema" + s + "[" + k + "]"
                      , L = "' + " + C + " + '";
                    e.opts._errorDataPathProperty && (e.errorPath = e.util.getPathExpr(w, C, e.opts.jsonPointers)),
                    n += " var " + m + " = true; ",
                    p && (n += " if (schema" + s + " === undefined) " + m + " = true; else if (!Array.isArray(schema" + s + ")) " + m + " = false; else {"),
                    n += " for (var " + k + " = 0; " + k + " < " + h + ".length; " + k + "++) { " + m + " = " + c + "[" + h + "[" + k + "]] !== undefined ",
                    I && (n += " &&   Object.prototype.hasOwnProperty.call(" + c + ", " + h + "[" + k + "]) "),
                    n += "; if (!" + m + ") break; } ",
                    p && (n += "  }  "),
                    n += "  if (!" + m + ") {   ";
                    var N = N || [];
                    N.push(n),
                    n = "",
                    e.createErrors !== !1 ? (n += " { keyword: 'required' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { missingProperty: '" + L + "' } ",
                    e.opts.messages !== !1 && (n += " , message: '",
                    e.opts._errorDataPathProperty ? n += "is a required property" : n += "should have required property \\'" + L + "\\'",
                    n += "' "),
                    e.opts.verbose && (n += " , schema: validate.schema" + d + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + c + " "),
                    n += " } ") : n += " {} ";
                    var A = n;
                    n = N.pop(),
                    !e.compositeRule && g ? e.async ? n += " throw new ValidationError([" + A + "]); " : n += " validate.errors = [" + A + "]; return false; " : n += " var err = " + A + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",
                    n += " } else { "
                } else {
                    n += " if ( ";
                    var $ = f;
                    if ($)
                        for (var R, k = -1, q = $.length - 1; k < q; ) {
                            R = $[k += 1],
                            k && (n += " || ");
                            var ee = e.util.getProperty(R)
                              , ne = c + ee;
                            n += " ( ( " + ne + " === undefined ",
                            I && (n += " || ! Object.prototype.hasOwnProperty.call(" + c + ", '" + e.util.escapeQuotes(R) + "') "),
                            n += ") && (missing" + s + " = " + e.util.toQuotedString(e.opts.jsonPointers ? R : ee) + ") ) "
                        }
                    n += ") {  ";
                    var C = "missing" + s
                      , L = "' + " + C + " + '";
                    e.opts._errorDataPathProperty && (e.errorPath = e.opts.jsonPointers ? e.util.getPathExpr(w, C, !0) : w + " + " + C);
                    var N = N || [];
                    N.push(n),
                    n = "",
                    e.createErrors !== !1 ? (n += " { keyword: 'required' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { missingProperty: '" + L + "' } ",
                    e.opts.messages !== !1 && (n += " , message: '",
                    e.opts._errorDataPathProperty ? n += "is a required property" : n += "should have required property \\'" + L + "\\'",
                    n += "' "),
                    e.opts.verbose && (n += " , schema: validate.schema" + d + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + c + " "),
                    n += " } ") : n += " {} ";
                    var A = n;
                    n = N.pop(),
                    !e.compositeRule && g ? e.async ? n += " throw new ValidationError([" + A + "]); " : n += " validate.errors = [" + A + "]; return false; " : n += " var err = " + A + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",
                    n += " } else { "
                }
            else if (_) {
                p || (n += " var " + h + " = validate.schema" + d + "; ");
                var k = "i" + s
                  , C = "schema" + s + "[" + k + "]"
                  , L = "' + " + C + " + '";
                e.opts._errorDataPathProperty && (e.errorPath = e.util.getPathExpr(w, C, e.opts.jsonPointers)),
                p && (n += " if (" + h + " && !Array.isArray(" + h + ")) {  var err =   ",
                e.createErrors !== !1 ? (n += " { keyword: 'required' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { missingProperty: '" + L + "' } ",
                e.opts.messages !== !1 && (n += " , message: '",
                e.opts._errorDataPathProperty ? n += "is a required property" : n += "should have required property \\'" + L + "\\'",
                n += "' "),
                e.opts.verbose && (n += " , schema: validate.schema" + d + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + c + " "),
                n += " } ") : n += " {} ",
                n += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (" + h + " !== undefined) { "),
                n += " for (var " + k + " = 0; " + k + " < " + h + ".length; " + k + "++) { if (" + c + "[" + h + "[" + k + "]] === undefined ",
                I && (n += " || ! Object.prototype.hasOwnProperty.call(" + c + ", " + h + "[" + k + "]) "),
                n += ") {  var err =   ",
                e.createErrors !== !1 ? (n += " { keyword: 'required' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { missingProperty: '" + L + "' } ",
                e.opts.messages !== !1 && (n += " , message: '",
                e.opts._errorDataPathProperty ? n += "is a required property" : n += "should have required property \\'" + L + "\\'",
                n += "' "),
                e.opts.verbose && (n += " , schema: validate.schema" + d + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + c + " "),
                n += " } ") : n += " {} ",
                n += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ",
                p && (n += "  }  ")
            } else {
                var te = f;
                if (te)
                    for (var R, re = -1, Q = te.length - 1; re < Q; ) {
                        R = te[re += 1];
                        var ee = e.util.getProperty(R)
                          , L = e.util.escapeQuotes(R)
                          , ne = c + ee;
                        e.opts._errorDataPathProperty && (e.errorPath = e.util.getPath(w, R, e.opts.jsonPointers)),
                        n += " if ( " + ne + " === undefined ",
                        I && (n += " || ! Object.prototype.hasOwnProperty.call(" + c + ", '" + e.util.escapeQuotes(R) + "') "),
                        n += ") {  var err =   ",
                        e.createErrors !== !1 ? (n += " { keyword: 'required' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { missingProperty: '" + L + "' } ",
                        e.opts.messages !== !1 && (n += " , message: '",
                        e.opts._errorDataPathProperty ? n += "is a required property" : n += "should have required property \\'" + L + "\\'",
                        n += "' "),
                        e.opts.verbose && (n += " , schema: validate.schema" + d + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + c + " "),
                        n += " } ") : n += " {} ",
                        n += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } "
                    }
            }
            e.errorPath = w
        } else
            g && (n += " if (true) {");
        return n
    }
      , Mh = function(e, r, o) {
        var n = " ", s = e.level, i = e.dataLevel, l = e.schema[r], d = e.schemaPath + e.util.getProperty(r), u = e.errSchemaPath + "/" + r, g = !e.opts.allErrors, c = "data" + (i || ""), m = "valid" + s, p = e.opts.$data && l && l.$data, h;
        if (p ? (n += " var schema" + s + " = " + e.util.getData(l.$data, i, e.dataPathArr) + "; ",
        h = "schema" + s) : h = l,
        (l || p) && e.opts.uniqueItems !== !1) {
            p && (n += " var " + m + "; if (" + h + " === false || " + h + " === undefined) " + m + " = true; else if (typeof " + h + " != 'boolean') " + m + " = false; else { "),
            n += " var i = " + c + ".length , " + m + " = true , j; if (i > 1) { ";
            var f = e.schema.items && e.schema.items.type
              , y = Array.isArray(f);
            if (!f || f == "object" || f == "array" || y && (f.indexOf("object") >= 0 || f.indexOf("array") >= 0))
                n += " outer: for (;i--;) { for (j = i; j--;) { if (equal(" + c + "[i], " + c + "[j])) { " + m + " = false; break outer; } } } ";
            else {
                n += " var itemIndices = {}, item; for (;i--;) { var item = " + c + "[i]; ";
                var b = "checkDataType" + (y ? "s" : "");
                n += " if (" + e.util[b](f, "item", e.opts.strictNumbers, !0) + ") continue; ",
                y && (n += ` if (typeof item == 'string') item = '"' + item; `),
                n += " if (typeof itemIndices[item] == 'number') { " + m + " = false; j = itemIndices[item]; break; } itemIndices[item] = i; } "
            }
            n += " } ",
            p && (n += "  }  "),
            n += " if (!" + m + ") {   ";
            var x = x || [];
            x.push(n),
            n = "",
            e.createErrors !== !1 ? (n += " { keyword: 'uniqueItems' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { i: i, j: j } ",
            e.opts.messages !== !1 && (n += " , message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)' "),
            e.opts.verbose && (n += " , schema:  ",
            p ? n += "validate.schema" + d : n += "" + l,
            n += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + c + " "),
            n += " } ") : n += " {} ";
            var v = n;
            n = x.pop(),
            !e.compositeRule && g ? e.async ? n += " throw new ValidationError([" + v + "]); " : n += " validate.errors = [" + v + "]; return false; " : n += " var err = " + v + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",
            n += " } ",
            g && (n += " else { ")
        } else
            g && (n += " if (true) { ");
        return n
    }
      , Fh = {
        $ref: Sh,
        allOf: Eh,
        anyOf: xh,
        $comment: _h,
        const: Th,
        contains: Ph,
        dependencies: kh,
        enum: Ih,
        format: Ch,
        if: $h,
        items: Ah,
        maximum: rc,
        minimum: rc,
        maxItems: nc,
        minItems: nc,
        maxLength: oc,
        minLength: oc,
        maxProperties: sc,
        minProperties: sc,
        multipleOf: Rh,
        not: Oh,
        oneOf: Dh,
        pattern: Nh,
        properties: Lh,
        propertyNames: Uh,
        required: jh,
        uniqueItems: Mh,
        validate: Wl
    }
      , ac = Fh
      , ba = Zr.toHash
      , Wh = function() {
        var e = [{
            type: "number",
            rules: [{
                maximum: ["exclusiveMaximum"]
            }, {
                minimum: ["exclusiveMinimum"]
            }, "multipleOf", "format"]
        }, {
            type: "string",
            rules: ["maxLength", "minLength", "pattern", "format"]
        }, {
            type: "array",
            rules: ["maxItems", "minItems", "items", "contains", "uniqueItems"]
        }, {
            type: "object",
            rules: ["maxProperties", "minProperties", "required", "dependencies", "propertyNames", {
                properties: ["additionalProperties", "patternProperties"]
            }]
        }, {
            rules: ["$ref", "const", "enum", "not", "anyOf", "oneOf", "allOf", "if"]
        }]
          , r = ["type", "$comment"]
          , o = ["$schema", "$id", "id", "$data", "$async", "title", "description", "default", "definitions", "examples", "readOnly", "writeOnly", "contentMediaType", "contentEncoding", "additionalItems", "then", "else"]
          , n = ["number", "integer", "string", "array", "object", "boolean", "null"];
        return e.all = ba(r),
        e.types = ba(n),
        e.forEach(function(s) {
            s.rules = s.rules.map(function(i) {
                var l;
                if (typeof i == "object") {
                    var d = Object.keys(i)[0];
                    l = i[d],
                    i = d,
                    l.forEach(function(g) {
                        r.push(g),
                        e.all[g] = !0
                    })
                }
                r.push(i);
                var u = e.all[i] = {
                    keyword: i,
                    code: ac[i],
                    implements: l
                };
                return u
            }),
            e.all.$comment = {
                keyword: "$comment",
                code: ac.$comment
            },
            s.type && (e.types[s.type] = s)
        }),
        e.keywords = ba(r.concat(o)),
        e.custom = {},
        e
    }
      , ic = ["multipleOf", "maximum", "exclusiveMaximum", "minimum", "exclusiveMinimum", "maxLength", "minLength", "pattern", "additionalItems", "maxItems", "minItems", "uniqueItems", "maxProperties", "minProperties", "required", "additionalProperties", "enum", "format", "const"]
      , qh = function(t, e) {
        for (var r = 0; r < e.length; r++) {
            t = JSON.parse(JSON.stringify(t));
            var o = e[r].split("/"), n = t, s;
            for (s = 1; s < o.length; s++)
                n = n[o[s]];
            for (s = 0; s < ic.length; s++) {
                var i = ic[s]
                  , l = n[i];
                l && (n[i] = {
                    anyOf: [l, {
                        $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
                    }]
                })
            }
        }
        return t
    }
      , Gh = ya.MissingRef
      , Bh = lc;
    function lc(t, e, r) {
        var o = this;
        if (typeof this._opts.loadSchema != "function")
            throw new Error("options.loadSchema should be a function");
        typeof e == "function" && (r = e,
        e = void 0);
        var n = s(t).then(function() {
            var l = o._addSchema(t, void 0, e);
            return l.validate || i(l)
        });
        return r && n.then(function(l) {
            r(null, l)
        }, r),
        n;
        function s(l) {
            var d = l.$schema;
            return d && !o.getSchema(d) ? lc.call(o, {
                $ref: d
            }, !0) : Promise.resolve()
        }
        function i(l) {
            try {
                return o._compile(l)
            } catch (u) {
                if (u instanceof Gh)
                    return d(u);
                throw u
            }
            function d(u) {
                var g = u.missingSchema;
                if (p(g))
                    throw new Error("Schema " + g + " is loaded but " + u.missingRef + " cannot be resolved");
                var c = o._loadingSchemas[g];
                return c || (c = o._loadingSchemas[g] = o._opts.loadSchema(g),
                c.then(m, m)),
                c.then(function(h) {
                    if (!p(g))
                        return s(h).then(function() {
                            p(g) || o.addSchema(h, g, void 0, e)
                        })
                }).then(function() {
                    return i(l)
                });
                function m() {
                    delete o._loadingSchemas[g]
                }
                function p(h) {
                    return o._refs[h] || o._schemas[h]
                }
            }
        }
    }
    var zh = function(e, r, o) {
        var n = " ", s = e.level, i = e.dataLevel, l = e.schema[r], d = e.schemaPath + e.util.getProperty(r), u = e.errSchemaPath + "/" + r, g = !e.opts.allErrors, c, m = "data" + (i || ""), p = "valid" + s, h = "errs__" + s, f = e.opts.$data && l && l.$data, y;
        f ? (n += " var schema" + s + " = " + e.util.getData(l.$data, i, e.dataPathArr) + "; ",
        y = "schema" + s) : y = l;
        var b = this, x = "definition" + s, v = b.definition, S = "", w, _, I, k, C;
        if (f && v.$data) {
            C = "keywordValidate" + s;
            var L = v.validateSchema;
            n += " var " + x + " = RULES.custom['" + r + "'].definition; var " + C + " = " + x + ".validate;"
        } else {
            if (k = e.useCustomRule(b, l, e.schema, e),
            !k)
                return;
            y = "validate.schema" + d,
            C = k.code,
            w = v.compile,
            _ = v.inline,
            I = v.macro
        }
        var N = C + ".errors"
          , A = "i" + s
          , $ = "ruleErr" + s
          , R = v.async;
        if (R && !e.async)
            throw new Error("async keyword in sync schema");
        if (_ || I || (n += "" + N + " = null;"),
        n += "var " + h + " = errors;var " + p + ";",
        f && v.$data && (S += "}",
        n += " if (" + y + " === undefined) { " + p + " = true; } else { ",
        L && (S += "}",
        n += " " + p + " = " + x + ".validateSchema(" + y + "); if (" + p + ") { ")),
        _)
            v.statements ? n += " " + k.validate + " " : n += " " + p + " = " + k.validate + "; ";
        else if (I) {
            var q = e.util.copy(e)
              , S = "";
            q.level++;
            var ee = "valid" + q.level;
            q.schema = k.validate,
            q.schemaPath = "";
            var ne = e.compositeRule;
            e.compositeRule = q.compositeRule = !0;
            var te = e.validate(q).replace(/validate\.schema/g, C);
            e.compositeRule = q.compositeRule = ne,
            n += " " + te
        } else {
            var re = re || [];
            re.push(n),
            n = "",
            n += "  " + C + ".call( ",
            e.opts.passContext ? n += "this" : n += "self",
            w || v.schema === !1 ? n += " , " + m + " " : n += " , " + y + " , " + m + " , validate.schema" + e.schemaPath + " ",
            n += " , (dataPath || '')",
            e.errorPath != '""' && (n += " + " + e.errorPath);
            var Q = i ? "data" + (i - 1 || "") : "parentData"
              , Ie = i ? e.dataPathArr[i] : "parentDataProperty";
            n += " , " + Q + " , " + Ie + " , rootData )  ";
            var Fe = n;
            n = re.pop(),
            v.errors === !1 ? (n += " " + p + " = ",
            R && (n += "await "),
            n += "" + Fe + "; ") : R ? (N = "customErrors" + s,
            n += " var " + N + " = null; try { " + p + " = await " + Fe + "; } catch (e) { " + p + " = false; if (e instanceof ValidationError) " + N + " = e.errors; else throw e; } ") : n += " " + N + " = null; " + p + " = " + Fe + "; "
        }
        if (v.modifying && (n += " if (" + Q + ") " + m + " = " + Q + "[" + Ie + "];"),
        n += "" + S,
        v.valid)
            g && (n += " if (true) { ");
        else {
            n += " if ( ",
            v.valid === void 0 ? (n += " !",
            I ? n += "" + ee : n += "" + p) : n += " " + !v.valid + " ",
            n += ") { ",
            c = b.keyword;
            var re = re || [];
            re.push(n),
            n = "";
            var re = re || [];
            re.push(n),
            n = "",
            e.createErrors !== !1 ? (n += " { keyword: '" + (c || "custom") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { keyword: '" + b.keyword + "' } ",
            e.opts.messages !== !1 && (n += ` , message: 'should pass "` + b.keyword + `" keyword validation' `),
            e.opts.verbose && (n += " , schema: validate.schema" + d + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + m + " "),
            n += " } ") : n += " {} ";
            var We = n;
            n = re.pop(),
            !e.compositeRule && g ? e.async ? n += " throw new ValidationError([" + We + "]); " : n += " validate.errors = [" + We + "]; return false; " : n += " var err = " + We + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            var ve = n;
            n = re.pop(),
            _ ? v.errors ? v.errors != "full" && (n += "  for (var " + A + "=" + h + "; " + A + "<errors; " + A + "++) { var " + $ + " = vErrors[" + A + "]; if (" + $ + ".dataPath === undefined) " + $ + ".dataPath = (dataPath || '') + " + e.errorPath + "; if (" + $ + ".schemaPath === undefined) { " + $ + '.schemaPath = "' + u + '"; } ',
            e.opts.verbose && (n += " " + $ + ".schema = " + y + "; " + $ + ".data = " + m + "; "),
            n += " } ") : v.errors === !1 ? n += " " + ve + " " : (n += " if (" + h + " == errors) { " + ve + " } else {  for (var " + A + "=" + h + "; " + A + "<errors; " + A + "++) { var " + $ + " = vErrors[" + A + "]; if (" + $ + ".dataPath === undefined) " + $ + ".dataPath = (dataPath || '') + " + e.errorPath + "; if (" + $ + ".schemaPath === undefined) { " + $ + '.schemaPath = "' + u + '"; } ',
            e.opts.verbose && (n += " " + $ + ".schema = " + y + "; " + $ + ".data = " + m + "; "),
            n += " } } ") : I ? (n += "   var err =   ",
            e.createErrors !== !1 ? (n += " { keyword: '" + (c || "custom") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { keyword: '" + b.keyword + "' } ",
            e.opts.messages !== !1 && (n += ` , message: 'should pass "` + b.keyword + `" keyword validation' `),
            e.opts.verbose && (n += " , schema: validate.schema" + d + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + m + " "),
            n += " } ") : n += " {} ",
            n += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",
            !e.compositeRule && g && (e.async ? n += " throw new ValidationError(vErrors); " : n += " validate.errors = vErrors; return false; ")) : v.errors === !1 ? n += " " + ve + " " : (n += " if (Array.isArray(" + N + ")) { if (vErrors === null) vErrors = " + N + "; else vErrors = vErrors.concat(" + N + "); errors = vErrors.length;  for (var " + A + "=" + h + "; " + A + "<errors; " + A + "++) { var " + $ + " = vErrors[" + A + "]; if (" + $ + ".dataPath === undefined) " + $ + ".dataPath = (dataPath || '') + " + e.errorPath + ";  " + $ + '.schemaPath = "' + u + '";  ',
            e.opts.verbose && (n += " " + $ + ".schema = " + y + "; " + $ + ".data = " + m + "; "),
            n += " } } else { " + ve + " } "),
            n += " } ",
            g && (n += " else { ")
        }
        return n
    };
    const cc = {
        $schema: "http://json-schema.org/draft-07/schema#",
        $id: "http://json-schema.org/draft-07/schema#",
        title: "Core schema meta-schema",
        definitions: {
            schemaArray: {
                type: "array",
                minItems: 1,
                items: {
                    $ref: "#"
                }
            },
            nonNegativeInteger: {
                type: "integer",
                minimum: 0
            },
            nonNegativeIntegerDefault0: {
                allOf: [{
                    $ref: "#/definitions/nonNegativeInteger"
                }, {
                    default: 0
                }]
            },
            simpleTypes: {
                enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
            },
            stringArray: {
                type: "array",
                items: {
                    type: "string"
                },
                uniqueItems: !0,
                default: []
            }
        },
        type: ["object", "boolean"],
        properties: {
            $id: {
                type: "string",
                format: "uri-reference"
            },
            $schema: {
                type: "string",
                format: "uri"
            },
            $ref: {
                type: "string",
                format: "uri-reference"
            },
            $comment: {
                type: "string"
            },
            title: {
                type: "string"
            },
            description: {
                type: "string"
            },
            default: !0,
            readOnly: {
                type: "boolean",
                default: !1
            },
            examples: {
                type: "array",
                items: !0
            },
            multipleOf: {
                type: "number",
                exclusiveMinimum: 0
            },
            maximum: {
                type: "number"
            },
            exclusiveMaximum: {
                type: "number"
            },
            minimum: {
                type: "number"
            },
            exclusiveMinimum: {
                type: "number"
            },
            maxLength: {
                $ref: "#/definitions/nonNegativeInteger"
            },
            minLength: {
                $ref: "#/definitions/nonNegativeIntegerDefault0"
            },
            pattern: {
                type: "string",
                format: "regex"
            },
            additionalItems: {
                $ref: "#"
            },
            items: {
                anyOf: [{
                    $ref: "#"
                }, {
                    $ref: "#/definitions/schemaArray"
                }],
                default: !0
            },
            maxItems: {
                $ref: "#/definitions/nonNegativeInteger"
            },
            minItems: {
                $ref: "#/definitions/nonNegativeIntegerDefault0"
            },
            uniqueItems: {
                type: "boolean",
                default: !1
            },
            contains: {
                $ref: "#"
            },
            maxProperties: {
                $ref: "#/definitions/nonNegativeInteger"
            },
            minProperties: {
                $ref: "#/definitions/nonNegativeIntegerDefault0"
            },
            required: {
                $ref: "#/definitions/stringArray"
            },
            additionalProperties: {
                $ref: "#"
            },
            definitions: {
                type: "object",
                additionalProperties: {
                    $ref: "#"
                },
                default: {}
            },
            properties: {
                type: "object",
                additionalProperties: {
                    $ref: "#"
                },
                default: {}
            },
            patternProperties: {
                type: "object",
                additionalProperties: {
                    $ref: "#"
                },
                propertyNames: {
                    format: "regex"
                },
                default: {}
            },
            dependencies: {
                type: "object",
                additionalProperties: {
                    anyOf: [{
                        $ref: "#"
                    }, {
                        $ref: "#/definitions/stringArray"
                    }]
                }
            },
            propertyNames: {
                $ref: "#"
            },
            const: !0,
            enum: {
                type: "array",
                items: !0,
                minItems: 1,
                uniqueItems: !0
            },
            type: {
                anyOf: [{
                    $ref: "#/definitions/simpleTypes"
                }, {
                    type: "array",
                    items: {
                        $ref: "#/definitions/simpleTypes"
                    },
                    minItems: 1,
                    uniqueItems: !0
                }]
            },
            format: {
                type: "string"
            },
            contentMediaType: {
                type: "string"
            },
            contentEncoding: {
                type: "string"
            },
            if: {
                $ref: "#"
            },
            then: {
                $ref: "#"
            },
            else: {
                $ref: "#"
            },
            allOf: {
                $ref: "#/definitions/schemaArray"
            },
            anyOf: {
                $ref: "#/definitions/schemaArray"
            },
            oneOf: {
                $ref: "#/definitions/schemaArray"
            },
            not: {
                $ref: "#"
            }
        },
        default: !0
    };
    var dc = cc
      , Zh = {
        $id: "https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js",
        definitions: {
            simpleTypes: dc.definitions.simpleTypes
        },
        type: "object",
        dependencies: {
            schema: ["validate"],
            $data: ["validate"],
            statements: ["inline"],
            valid: {
                not: {
                    required: ["macro"]
                }
            }
        },
        properties: {
            type: dc.properties.type,
            schema: {
                type: "boolean"
            },
            statements: {
                type: "boolean"
            },
            dependencies: {
                type: "array",
                items: {
                    type: "string"
                }
            },
            metaSchema: {
                type: "object"
            },
            modifying: {
                type: "boolean"
            },
            valid: {
                type: "boolean"
            },
            $data: {
                type: "boolean"
            },
            async: {
                type: "boolean"
            },
            errors: {
                anyOf: [{
                    type: "boolean"
                }, {
                    const: "full"
                }]
            }
        }
    }
      , Hh = /^[a-z_$][a-z0-9_$-]*$/i
      , Vh = zh
      , Jh = Zh
      , Yh = {
        add: Kh,
        get: Qh,
        remove: Xh,
        validate: Sa
    };
    function Kh(t, e) {
        var r = this.RULES;
        if (r.keywords[t])
            throw new Error("Keyword " + t + " is already defined");
        if (!Hh.test(t))
            throw new Error("Keyword " + t + " is not a valid identifier");
        if (e) {
            this.validateKeyword(e, !0);
            var o = e.type;
            if (Array.isArray(o))
                for (var n = 0; n < o.length; n++)
                    i(t, o[n], e);
            else
                i(t, o, e);
            var s = e.metaSchema;
            s && (e.$data && this._opts.$data && (s = {
                anyOf: [s, {
                    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
                }]
            }),
            e.validateSchema = this.compile(s, !0))
        }
        r.keywords[t] = r.all[t] = !0;
        function i(l, d, u) {
            for (var g, c = 0; c < r.length; c++) {
                var m = r[c];
                if (m.type == d) {
                    g = m;
                    break
                }
            }
            g || (g = {
                type: d,
                rules: []
            },
            r.push(g));
            var p = {
                keyword: l,
                definition: u,
                custom: !0,
                code: Vh,
                implements: u.implements
            };
            g.rules.push(p),
            r.custom[l] = p
        }
        return this
    }
    function Qh(t) {
        var e = this.RULES.custom[t];
        return e ? e.definition : this.RULES.keywords[t] || !1
    }
    function Xh(t) {
        var e = this.RULES;
        delete e.keywords[t],
        delete e.all[t],
        delete e.custom[t];
        for (var r = 0; r < e.length; r++)
            for (var o = e[r].rules, n = 0; n < o.length; n++)
                if (o[n].keyword == t) {
                    o.splice(n, 1);
                    break
                }
        return this
    }
    function Sa(t, e) {
        Sa.errors = null;
        var r = this._validateKeyword = this._validateKeyword || this.compile(Jh, !0);
        if (r(t))
            return !0;
        if (Sa.errors = r.errors,
        e)
            throw new Error("custom keyword definition is invalid: " + this.errorsText(r.errors));
        return !1
    }
    const eg = {
        $schema: "http://json-schema.org/draft-07/schema#",
        $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
        description: "Meta-schema for $data reference (JSON Schema extension proposal)",
        type: "object",
        required: ["$data"],
        properties: {
            $data: {
                type: "string",
                anyOf: [{
                    format: "relative-json-pointer"
                }, {
                    format: "json-pointer"
                }]
            }
        },
        additionalProperties: !1
    };
    var uc = eh
      , kr = ma
      , tg = ih
      , mc = Dl
      , rg = Fl
      , ng = hh
      , og = Wh
      , pc = qh
      , hc = Zr
      , sg = Ue;
    Ue.prototype.validate = ig,
    Ue.prototype.compile = lg,
    Ue.prototype.addSchema = cg,
    Ue.prototype.addMetaSchema = dg,
    Ue.prototype.validateSchema = ug,
    Ue.prototype.getSchema = pg,
    Ue.prototype.removeSchema = gg,
    Ue.prototype.addFormat = xg,
    Ue.prototype.errorsText = Eg,
    Ue.prototype._addSchema = fg,
    Ue.prototype._compile = yg,
    Ue.prototype.compileAsync = Bh;
    var jo = Yh;
    Ue.prototype.addKeyword = jo.add,
    Ue.prototype.getKeyword = jo.get,
    Ue.prototype.removeKeyword = jo.remove,
    Ue.prototype.validateKeyword = jo.validate;
    var gc = ya;
    Ue.ValidationError = gc.Validation,
    Ue.MissingRefError = gc.MissingRef,
    Ue.$dataMetaSchema = pc;
    var Mo = "http://json-schema.org/draft-07/schema"
      , fc = ["removeAdditional", "useDefaults", "coerceTypes", "strictDefaults"]
      , ag = ["/properties"];
    function Ue(t) {
        if (!(this instanceof Ue))
            return new Ue(t);
        t = this._opts = hc.copy(t) || {},
        Cg(this),
        this._schemas = {},
        this._refs = {},
        this._fragments = {},
        this._formats = ng(t.format),
        this._cache = t.cache || new tg,
        this._loadingSchemas = {},
        this._compilations = [],
        this.RULES = og(),
        this._getId = vg(t),
        t.loopRequired = t.loopRequired || 1 / 0,
        t.errorDataPath == "property" && (t._errorDataPathProperty = !0),
        t.serialize === void 0 && (t.serialize = rg),
        this._metaOpts = Ig(this),
        t.formats && Pg(this),
        t.keywords && kg(this),
        _g(this),
        typeof t.meta == "object" && this.addMetaSchema(t.meta),
        t.nullable && this.addKeyword("nullable", {
            metaSchema: {
                type: "boolean"
            }
        }),
        Tg(this)
    }
    function ig(t, e) {
        var r;
        if (typeof t == "string") {
            if (r = this.getSchema(t),
            !r)
                throw new Error('no schema with key or ref "' + t + '"')
        } else {
            var o = this._addSchema(t);
            r = o.validate || this._compile(o)
        }
        var n = r(e);
        return r.$async !== !0 && (this.errors = r.errors),
        n
    }
    function lg(t, e) {
        var r = this._addSchema(t, void 0, e);
        return r.validate || this._compile(r)
    }
    function cg(t, e, r, o) {
        if (Array.isArray(t)) {
            for (var n = 0; n < t.length; n++)
                this.addSchema(t[n], void 0, r, o);
            return this
        }
        var s = this._getId(t);
        if (s !== void 0 && typeof s != "string")
            throw new Error("schema id must be string");
        return e = kr.normalizeId(e || s),
        vc(this, e),
        this._schemas[e] = this._addSchema(t, r, o, !0),
        this
    }
    function dg(t, e, r) {
        return this.addSchema(t, e, r, !0),
        this
    }
    function ug(t, e) {
        var r = t.$schema;
        if (r !== void 0 && typeof r != "string")
            throw new Error("$schema must be a string");
        if (r = r || this._opts.defaultMeta || mg(this),
        !r)
            return this.logger.warn("meta-schema not available"),
            this.errors = null,
            !0;
        var o = this.validate(r, t);
        if (!o && e) {
            var n = "schema is invalid: " + this.errorsText();
            if (this._opts.validateSchema == "log")
                this.logger.error(n);
            else
                throw new Error(n)
        }
        return o
    }
    function mg(t) {
        var e = t._opts.meta;
        return t._opts.defaultMeta = typeof e == "object" ? t._getId(e) || e : t.getSchema(Mo) ? Mo : void 0,
        t._opts.defaultMeta
    }
    function pg(t) {
        var e = yc(this, t);
        switch (typeof e) {
        case "object":
            return e.validate || this._compile(e);
        case "string":
            return this.getSchema(e);
        case "undefined":
            return hg(this, t)
        }
    }
    function hg(t, e) {
        var r = kr.schema.call(t, {
            schema: {}
        }, e);
        if (r) {
            var o = r.schema
              , n = r.root
              , s = r.baseId
              , i = uc.call(t, o, n, void 0, s);
            return t._fragments[e] = new mc({
                ref: e,
                fragment: !0,
                schema: o,
                root: n,
                baseId: s,
                validate: i
            }),
            i
        }
    }
    function yc(t, e) {
        return e = kr.normalizeId(e),
        t._schemas[e] || t._refs[e] || t._fragments[e]
    }
    function gg(t) {
        if (t instanceof RegExp)
            return Fo(this, this._schemas, t),
            Fo(this, this._refs, t),
            this;
        switch (typeof t) {
        case "undefined":
            return Fo(this, this._schemas),
            Fo(this, this._refs),
            this._cache.clear(),
            this;
        case "string":
            var e = yc(this, t);
            return e && this._cache.del(e.cacheKey),
            delete this._schemas[t],
            delete this._refs[t],
            this;
        case "object":
            var r = this._opts.serialize
              , o = r ? r(t) : t;
            this._cache.del(o);
            var n = this._getId(t);
            n && (n = kr.normalizeId(n),
            delete this._schemas[n],
            delete this._refs[n])
        }
        return this
    }
    function Fo(t, e, r) {
        for (var o in e) {
            var n = e[o];
            !n.meta && (!r || r.test(o)) && (t._cache.del(n.cacheKey),
            delete e[o])
        }
    }
    function fg(t, e, r, o) {
        if (typeof t != "object" && typeof t != "boolean")
            throw new Error("schema should be object or boolean");
        var n = this._opts.serialize
          , s = n ? n(t) : t
          , i = this._cache.get(s);
        if (i)
            return i;
        o = o || this._opts.addUsedSchema !== !1;
        var l = kr.normalizeId(this._getId(t));
        l && o && vc(this, l);
        var d = this._opts.validateSchema !== !1 && !e, u;
        d && !(u = l && l == kr.normalizeId(t.$schema)) && this.validateSchema(t, !0);
        var g = kr.ids.call(this, t)
          , c = new mc({
            id: l,
            schema: t,
            localRefs: g,
            cacheKey: s,
            meta: r
        });
        return l[0] != "#" && o && (this._refs[l] = c),
        this._cache.put(s, c),
        d && u && this.validateSchema(t, !0),
        c
    }
    function yg(t, e) {
        if (t.compiling)
            return t.validate = n,
            n.schema = t.schema,
            n.errors = null,
            n.root = e || n,
            t.schema.$async === !0 && (n.$async = !0),
            n;
        t.compiling = !0;
        var r;
        t.meta && (r = this._opts,
        this._opts = this._metaOpts);
        var o;
        try {
            o = uc.call(this, t.schema, e, t.localRefs)
        } catch (s) {
            throw delete t.validate,
            s
        } finally {
            t.compiling = !1,
            t.meta && (this._opts = r)
        }
        return t.validate = o,
        t.refs = o.refs,
        t.refVal = o.refVal,
        t.root = o.root,
        o;
        function n() {
            var s = t.validate
              , i = s.apply(this, arguments);
            return n.errors = s.errors,
            i
        }
    }
    function vg(t) {
        switch (t.schemaId) {
        case "auto":
            return Sg;
        case "id":
            return wg;
        default:
            return bg
        }
    }
    function wg(t) {
        return t.$id && this.logger.warn("schema $id ignored", t.$id),
        t.id
    }
    function bg(t) {
        return t.id && this.logger.warn("schema id ignored", t.id),
        t.$id
    }
    function Sg(t) {
        if (t.$id && t.id && t.$id != t.id)
            throw new Error("schema $id is different from id");
        return t.$id || t.id
    }
    function Eg(t, e) {
        if (t = t || this.errors,
        !t)
            return "No errors";
        e = e || {};
        for (var r = e.separator === void 0 ? ", " : e.separator, o = e.dataVar === void 0 ? "data" : e.dataVar, n = "", s = 0; s < t.length; s++) {
            var i = t[s];
            i && (n += o + i.dataPath + " " + i.message + r)
        }
        return n.slice(0, -r.length)
    }
    function xg(t, e) {
        return typeof e == "string" && (e = new RegExp(e)),
        this._formats[t] = e,
        this
    }
    function _g(t) {
        var e;
        if (t._opts.$data && (e = eg,
        t.addMetaSchema(e, e.$id, !0)),
        t._opts.meta !== !1) {
            var r = cc;
            t._opts.$data && (r = pc(r, ag)),
            t.addMetaSchema(r, Mo, !0),
            t._refs["http://json-schema.org/schema"] = Mo
        }
    }
    function Tg(t) {
        var e = t._opts.schemas;
        if (e)
            if (Array.isArray(e))
                t.addSchema(e);
            else
                for (var r in e)
                    t.addSchema(e[r], r)
    }
    function Pg(t) {
        for (var e in t._opts.formats) {
            var r = t._opts.formats[e];
            t.addFormat(e, r)
        }
    }
    function kg(t) {
        for (var e in t._opts.keywords) {
            var r = t._opts.keywords[e];
            t.addKeyword(e, r)
        }
    }
    function vc(t, e) {
        if (t._schemas[e] || t._refs[e])
            throw new Error('schema with key or id "' + e + '" already exists')
    }
    function Ig(t) {
        for (var e = hc.copy(t._opts), r = 0; r < fc.length; r++)
            delete e[fc[r]];
        return e
    }
    function Cg(t) {
        var e = t._opts.logger;
        if (e === !1)
            t.logger = {
                log: Ea,
                warn: Ea,
                error: Ea
            };
        else {
            if (e === void 0 && (e = console),
            !(typeof e == "object" && e.log && e.warn && e.error))
                throw new Error("logger must implement log, warn and error methods");
            t.logger = e
        }
    }
    function Ea() {}
    const $g = wp(sg);
    class Ag extends fp {
        constructor(e, r) {
            var o;
            super(r),
            this._serverInfo = e,
            this._capabilities = (o = r == null ? void 0 : r.capabilities) !== null && o !== void 0 ? o : {},
            this._instructions = r == null ? void 0 : r.instructions,
            this.setRequestHandler(mo, n => this._oninitialize(n)),
            this.setNotificationHandler(po, () => {
                var n;
                return (n = this.oninitialized) === null || n === void 0 ? void 0 : n.call(this)
            }
            )
        }
        registerCapabilities(e) {
            if (this.transport)
                throw new Error("Cannot register capabilities after connecting to transport");
            this._capabilities = yp(this._capabilities, e)
        }
        assertCapabilityForMethod(e) {
            var r, o, n;
            switch (e) {
            case "sampling/createMessage":
                if (!(!((r = this._clientCapabilities) === null || r === void 0) && r.sampling))
                    throw new Error(`Client does not support sampling (required for ${e})`);
                break;
            case "elicitation/create":
                if (!(!((o = this._clientCapabilities) === null || o === void 0) && o.elicitation))
                    throw new Error(`Client does not support elicitation (required for ${e})`);
                break;
            case "roots/list":
                if (!(!((n = this._clientCapabilities) === null || n === void 0) && n.roots))
                    throw new Error(`Client does not support listing roots (required for ${e})`);
                break
            }
        }
        assertNotificationCapability(e) {
            switch (e) {
            case "notifications/message":
                if (!this._capabilities.logging)
                    throw new Error(`Server does not support logging (required for ${e})`);
                break;
            case "notifications/resources/updated":
            case "notifications/resources/list_changed":
                if (!this._capabilities.resources)
                    throw new Error(`Server does not support notifying about resources (required for ${e})`);
                break;
            case "notifications/tools/list_changed":
                if (!this._capabilities.tools)
                    throw new Error(`Server does not support notifying of tool list changes (required for ${e})`);
                break;
            case "notifications/prompts/list_changed":
                if (!this._capabilities.prompts)
                    throw new Error(`Server does not support notifying of prompt list changes (required for ${e})`);
                break
            }
        }
        assertRequestHandlerCapability(e) {
            switch (e) {
            case "sampling/createMessage":
                if (!this._capabilities.sampling)
                    throw new Error(`Server does not support sampling (required for ${e})`);
                break;
            case "logging/setLevel":
                if (!this._capabilities.logging)
                    throw new Error(`Server does not support logging (required for ${e})`);
                break;
            case "prompts/get":
            case "prompts/list":
                if (!this._capabilities.prompts)
                    throw new Error(`Server does not support prompts (required for ${e})`);
                break;
            case "resources/list":
            case "resources/templates/list":
            case "resources/read":
                if (!this._capabilities.resources)
                    throw new Error(`Server does not support resources (required for ${e})`);
                break;
            case "tools/call":
            case "tools/list":
                if (!this._capabilities.tools)
                    throw new Error(`Server does not support tools (required for ${e})`);
                break
            }
        }
        async _oninitialize(e) {
            const r = e.params.protocolVersion;
            return this._clientCapabilities = e.params.capabilities,
            this._clientVersion = e.params.clientInfo,
            {
                protocolVersion: qi.includes(r) ? r : Ds,
                capabilities: this.getCapabilities(),
                serverInfo: this._serverInfo,
                ...this._instructions && {
                    instructions: this._instructions
                }
            }
        }
        getClientCapabilities() {
            return this._clientCapabilities
        }
        getClientVersion() {
            return this._clientVersion
        }
        getCapabilities() {
            return this._capabilities
        }
        async ping() {
            return this.request({
                method: "ping"
            }, co)
        }
        async createMessage(e, r) {
            return this.request({
                method: "sampling/createMessage",
                params: e
            }, Xs, r)
        }
        async elicitInput(e, r) {
            const o = await this.request({
                method: "elicitation/create",
                params: e
            }, ea, r);
            if (o.action === "accept" && o.content)
                try {
                    const n = new $g
                      , s = n.compile(e.requestedSchema);
                    if (!s(o.content))
                        throw new Le(Re.InvalidParams,`Elicitation response content does not match requested schema: ${n.errorsText(s.errors)}`)
                } catch (n) {
                    throw n instanceof Le ? n : new Le(Re.InternalError,`Error validating elicitation response: ${n}`)
                }
            return o
        }
        async listRoots(e, r) {
            return this.request({
                method: "roots/list",
                params: e
            }, ra, r)
        }
        async sendLoggingMessage(e) {
            return this.notification({
                method: "notifications/message",
                params: e
            })
        }
        async sendResourceUpdated(e) {
            return this.notification({
                method: "notifications/resources/updated",
                params: e
            })
        }
        async sendResourceListChanged() {
            return this.notification({
                method: "notifications/resources/list_changed"
            })
        }
        async sendToolListChanged() {
            return this.notification({
                method: "notifications/tools/list_changed"
            })
        }
        async sendPromptListChanged() {
            return this.notification({
                method: "notifications/prompts/list_changed"
            })
        }
    }
    const Rg = Symbol("Let zodToJsonSchema decide on which parser to use")
      , wc = {
        name: void 0,
        $refStrategy: "root",
        basePath: ["#"],
        effectStrategy: "input",
        pipeStrategy: "all",
        dateStrategy: "format:date-time",
        mapStrategy: "entries",
        removeAdditionalStrategy: "passthrough",
        allowedAdditionalProperties: !0,
        rejectedAdditionalProperties: !1,
        definitionPath: "definitions",
        target: "jsonSchema7",
        strictUnions: !1,
        definitions: {},
        errorMessages: !1,
        markdownDescription: !1,
        patternStrategy: "escape",
        applyRegexFlags: !1,
        emailStrategy: "format:email",
        base64Strategy: "contentEncoding:base64",
        nameStrategy: "ref"
    }
      , Og = t => typeof t == "string" ? {
        ...wc,
        name: t
    } : {
        ...wc,
        ...t
    }
      , Dg = t => {
        const e = Og(t)
          , r = e.name !== void 0 ? [...e.basePath, e.definitionPath, e.name] : e.basePath;
        return {
            ...e,
            currentPath: r,
            propertyPath: void 0,
            seen: new Map(Object.entries(e.definitions).map( ([o,n]) => [n._def, {
                def: n._def,
                path: [...e.basePath, e.definitionPath, o],
                jsonSchema: void 0
            }]))
        }
    }
    ;
    function bc(t, e, r, o) {
        o != null && o.errorMessages && r && (t.errorMessage = {
            ...t.errorMessage,
            [e]: r
        })
    }
    function Ee(t, e, r, o, n) {
        t[e] = r,
        bc(t, e, o, n)
    }
    function Ng() {
        return {}
    }
    function Lg(t, e) {
        var o, n, s;
        const r = {
            type: "array"
        };
        return (o = t.type) != null && o._def && ((s = (n = t.type) == null ? void 0 : n._def) == null ? void 0 : s.typeName) !== F.ZodAny && (r.items = we(t.type._def, {
            ...e,
            currentPath: [...e.currentPath, "items"]
        })),
        t.minLength && Ee(r, "minItems", t.minLength.value, t.minLength.message, e),
        t.maxLength && Ee(r, "maxItems", t.maxLength.value, t.maxLength.message, e),
        t.exactLength && (Ee(r, "minItems", t.exactLength.value, t.exactLength.message, e),
        Ee(r, "maxItems", t.exactLength.value, t.exactLength.message, e)),
        r
    }
    function Ug(t, e) {
        const r = {
            type: "integer",
            format: "int64"
        };
        if (!t.checks)
            return r;
        for (const o of t.checks)
            switch (o.kind) {
            case "min":
                e.target === "jsonSchema7" ? o.inclusive ? Ee(r, "minimum", o.value, o.message, e) : Ee(r, "exclusiveMinimum", o.value, o.message, e) : (o.inclusive || (r.exclusiveMinimum = !0),
                Ee(r, "minimum", o.value, o.message, e));
                break;
            case "max":
                e.target === "jsonSchema7" ? o.inclusive ? Ee(r, "maximum", o.value, o.message, e) : Ee(r, "exclusiveMaximum", o.value, o.message, e) : (o.inclusive || (r.exclusiveMaximum = !0),
                Ee(r, "maximum", o.value, o.message, e));
                break;
            case "multipleOf":
                Ee(r, "multipleOf", o.value, o.message, e);
                break
            }
        return r
    }
    function jg() {
        return {
            type: "boolean"
        }
    }
    function Sc(t, e) {
        return we(t.type._def, e)
    }
    const Mg = (t, e) => we(t.innerType._def, e);
    function Ec(t, e, r) {
        const o = r ?? e.dateStrategy;
        if (Array.isArray(o))
            return {
                anyOf: o.map( (n, s) => Ec(t, e, n))
            };
        switch (o) {
        case "string":
        case "format:date-time":
            return {
                type: "string",
                format: "date-time"
            };
        case "format:date":
            return {
                type: "string",
                format: "date"
            };
        case "integer":
            return Fg(t, e)
        }
    }
    const Fg = (t, e) => {
        const r = {
            type: "integer",
            format: "unix-time"
        };
        if (e.target === "openApi3")
            return r;
        for (const o of t.checks)
            switch (o.kind) {
            case "min":
                Ee(r, "minimum", o.value, o.message, e);
                break;
            case "max":
                Ee(r, "maximum", o.value, o.message, e);
                break
            }
        return r
    }
    ;
    function Wg(t, e) {
        return {
            ...we(t.innerType._def, e),
            default: t.defaultValue()
        }
    }
    function qg(t, e) {
        return e.effectStrategy === "input" ? we(t.schema._def, e) : {}
    }
    function Gg(t) {
        return {
            type: "string",
            enum: Array.from(t.values)
        }
    }
    const Bg = t => "type"in t && t.type === "string" ? !1 : "allOf"in t;
    function zg(t, e) {
        const r = [we(t.left._def, {
            ...e,
            currentPath: [...e.currentPath, "allOf", "0"]
        }), we(t.right._def, {
            ...e,
            currentPath: [...e.currentPath, "allOf", "1"]
        })].filter(s => !!s);
        let o = e.target === "jsonSchema2019-09" ? {
            unevaluatedProperties: !1
        } : void 0;
        const n = [];
        return r.forEach(s => {
            if (Bg(s))
                n.push(...s.allOf),
                s.unevaluatedProperties === void 0 && (o = void 0);
            else {
                let i = s;
                if ("additionalProperties"in s && s.additionalProperties === !1) {
                    const {additionalProperties: l, ...d} = s;
                    i = d
                } else
                    o = void 0;
                n.push(i)
            }
        }
        ),
        n.length ? {
            allOf: n,
            ...o
        } : void 0
    }
    function Zg(t, e) {
        const r = typeof t.value;
        return r !== "bigint" && r !== "number" && r !== "boolean" && r !== "string" ? {
            type: Array.isArray(t.value) ? "array" : "object"
        } : e.target === "openApi3" ? {
            type: r === "bigint" ? "integer" : r,
            enum: [t.value]
        } : {
            type: r === "bigint" ? "integer" : r,
            const: t.value
        }
    }
    let xa;
    const Dt = {
        cuid: /^[cC][^\s-]{8,}$/,
        cuid2: /^[0-9a-z]+$/,
        ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
        email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
        emoji: () => (xa === void 0 && (xa = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u")),
        xa),
        uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
        ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
        ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
        ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
        ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
        base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
        base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
        nanoid: /^[a-zA-Z0-9_-]{21}$/,
        jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
    };
    function xc(t, e) {
        const r = {
            type: "string"
        };
        if (t.checks)
            for (const o of t.checks)
                switch (o.kind) {
                case "min":
                    Ee(r, "minLength", typeof r.minLength == "number" ? Math.max(r.minLength, o.value) : o.value, o.message, e);
                    break;
                case "max":
                    Ee(r, "maxLength", typeof r.maxLength == "number" ? Math.min(r.maxLength, o.value) : o.value, o.message, e);
                    break;
                case "email":
                    switch (e.emailStrategy) {
                    case "format:email":
                        Nt(r, "email", o.message, e);
                        break;
                    case "format:idn-email":
                        Nt(r, "idn-email", o.message, e);
                        break;
                    case "pattern:zod":
                        lt(r, Dt.email, o.message, e);
                        break
                    }
                    break;
                case "url":
                    Nt(r, "uri", o.message, e);
                    break;
                case "uuid":
                    Nt(r, "uuid", o.message, e);
                    break;
                case "regex":
                    lt(r, o.regex, o.message, e);
                    break;
                case "cuid":
                    lt(r, Dt.cuid, o.message, e);
                    break;
                case "cuid2":
                    lt(r, Dt.cuid2, o.message, e);
                    break;
                case "startsWith":
                    lt(r, RegExp(`^${_a(o.value, e)}`), o.message, e);
                    break;
                case "endsWith":
                    lt(r, RegExp(`${_a(o.value, e)}$`), o.message, e);
                    break;
                case "datetime":
                    Nt(r, "date-time", o.message, e);
                    break;
                case "date":
                    Nt(r, "date", o.message, e);
                    break;
                case "time":
                    Nt(r, "time", o.message, e);
                    break;
                case "duration":
                    Nt(r, "duration", o.message, e);
                    break;
                case "length":
                    Ee(r, "minLength", typeof r.minLength == "number" ? Math.max(r.minLength, o.value) : o.value, o.message, e),
                    Ee(r, "maxLength", typeof r.maxLength == "number" ? Math.min(r.maxLength, o.value) : o.value, o.message, e);
                    break;
                case "includes":
                    {
                        lt(r, RegExp(_a(o.value, e)), o.message, e);
                        break
                    }
                case "ip":
                    {
                        o.version !== "v6" && Nt(r, "ipv4", o.message, e),
                        o.version !== "v4" && Nt(r, "ipv6", o.message, e);
                        break
                    }
                case "base64url":
                    lt(r, Dt.base64url, o.message, e);
                    break;
                case "jwt":
                    lt(r, Dt.jwt, o.message, e);
                    break;
                case "cidr":
                    {
                        o.version !== "v6" && lt(r, Dt.ipv4Cidr, o.message, e),
                        o.version !== "v4" && lt(r, Dt.ipv6Cidr, o.message, e);
                        break
                    }
                case "emoji":
                    lt(r, Dt.emoji(), o.message, e);
                    break;
                case "ulid":
                    {
                        lt(r, Dt.ulid, o.message, e);
                        break
                    }
                case "base64":
                    {
                        switch (e.base64Strategy) {
                        case "format:binary":
                            {
                                Nt(r, "binary", o.message, e);
                                break
                            }
                        case "contentEncoding:base64":
                            {
                                Ee(r, "contentEncoding", "base64", o.message, e);
                                break
                            }
                        case "pattern:zod":
                            {
                                lt(r, Dt.base64, o.message, e);
                                break
                            }
                        }
                        break
                    }
                case "nanoid":
                    lt(r, Dt.nanoid, o.message, e)
                }
        return r
    }
    function _a(t, e) {
        return e.patternStrategy === "escape" ? Vg(t) : t
    }
    const Hg = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
    function Vg(t) {
        let e = "";
        for (let r = 0; r < t.length; r++)
            Hg.has(t[r]) || (e += "\\"),
            e += t[r];
        return e
    }
    function Nt(t, e, r, o) {
        var n;
        t.format || (n = t.anyOf) != null && n.some(s => s.format) ? (t.anyOf || (t.anyOf = []),
        t.format && (t.anyOf.push({
            format: t.format,
            ...t.errorMessage && o.errorMessages && {
                errorMessage: {
                    format: t.errorMessage.format
                }
            }
        }),
        delete t.format,
        t.errorMessage && (delete t.errorMessage.format,
        Object.keys(t.errorMessage).length === 0 && delete t.errorMessage)),
        t.anyOf.push({
            format: e,
            ...r && o.errorMessages && {
                errorMessage: {
                    format: r
                }
            }
        })) : Ee(t, "format", e, r, o)
    }
    function lt(t, e, r, o) {
        var n;
        t.pattern || (n = t.allOf) != null && n.some(s => s.pattern) ? (t.allOf || (t.allOf = []),
        t.pattern && (t.allOf.push({
            pattern: t.pattern,
            ...t.errorMessage && o.errorMessages && {
                errorMessage: {
                    pattern: t.errorMessage.pattern
                }
            }
        }),
        delete t.pattern,
        t.errorMessage && (delete t.errorMessage.pattern,
        Object.keys(t.errorMessage).length === 0 && delete t.errorMessage)),
        t.allOf.push({
            pattern: _c(e, o),
            ...r && o.errorMessages && {
                errorMessage: {
                    pattern: r
                }
            }
        })) : Ee(t, "pattern", _c(e, o), r, o)
    }
    function _c(t, e) {
        var d;
        if (!e.applyRegexFlags || !t.flags)
            return t.source;
        const r = {
            i: t.flags.includes("i"),
            m: t.flags.includes("m"),
            s: t.flags.includes("s")
        }
          , o = r.i ? t.source.toLowerCase() : t.source;
        let n = ""
          , s = !1
          , i = !1
          , l = !1;
        for (let u = 0; u < o.length; u++) {
            if (s) {
                n += o[u],
                s = !1;
                continue
            }
            if (r.i) {
                if (i) {
                    if (o[u].match(/[a-z]/)) {
                        l ? (n += o[u],
                        n += `${o[u - 2]}-${o[u]}`.toUpperCase(),
                        l = !1) : o[u + 1] === "-" && ((d = o[u + 2]) != null && d.match(/[a-z]/)) ? (n += o[u],
                        l = !0) : n += `${o[u]}${o[u].toUpperCase()}`;
                        continue
                    }
                } else if (o[u].match(/[a-z]/)) {
                    n += `[${o[u]}${o[u].toUpperCase()}]`;
                    continue
                }
            }
            if (r.m) {
                if (o[u] === "^") {
                    n += `(^|(?<=[\r
]))`;
                    continue
                } else if (o[u] === "$") {
                    n += `($|(?=[\r
]))`;
                    continue
                }
            }
            if (r.s && o[u] === ".") {
                n += i ? `${o[u]}\r
` : `[${o[u]}\r
]`;
                continue
            }
            n += o[u],
            o[u] === "\\" ? s = !0 : i && o[u] === "]" ? i = !1 : !i && o[u] === "[" && (i = !0)
        }
        try {
            new RegExp(n)
        } catch {
            return console.warn(`Could not convert regex pattern at ${e.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`),
            t.source
        }
        return n
    }
    function Tc(t, e) {
        var o, n, s, i, l, d;
        if (e.target === "openAi" && console.warn("Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead."),
        e.target === "openApi3" && ((o = t.keyType) == null ? void 0 : o._def.typeName) === F.ZodEnum)
            return {
                type: "object",
                required: t.keyType._def.values,
                properties: t.keyType._def.values.reduce( (u, g) => ({
                    ...u,
                    [g]: we(t.valueType._def, {
                        ...e,
                        currentPath: [...e.currentPath, "properties", g]
                    }) ?? {}
                }), {}),
                additionalProperties: e.rejectedAdditionalProperties
            };
        const r = {
            type: "object",
            additionalProperties: we(t.valueType._def, {
                ...e,
                currentPath: [...e.currentPath, "additionalProperties"]
            }) ?? e.allowedAdditionalProperties
        };
        if (e.target === "openApi3")
            return r;
        if (((n = t.keyType) == null ? void 0 : n._def.typeName) === F.ZodString && ((s = t.keyType._def.checks) != null && s.length)) {
            const {type: u, ...g} = xc(t.keyType._def, e);
            return {
                ...r,
                propertyNames: g
            }
        } else {
            if (((i = t.keyType) == null ? void 0 : i._def.typeName) === F.ZodEnum)
                return {
                    ...r,
                    propertyNames: {
                        enum: t.keyType._def.values
                    }
                };
            if (((l = t.keyType) == null ? void 0 : l._def.typeName) === F.ZodBranded && t.keyType._def.type._def.typeName === F.ZodString && ((d = t.keyType._def.type._def.checks) != null && d.length)) {
                const {type: u, ...g} = Sc(t.keyType._def, e);
                return {
                    ...r,
                    propertyNames: g
                }
            }
        }
        return r
    }
    function Jg(t, e) {
        if (e.mapStrategy === "record")
            return Tc(t, e);
        const r = we(t.keyType._def, {
            ...e,
            currentPath: [...e.currentPath, "items", "items", "0"]
        }) || {}
          , o = we(t.valueType._def, {
            ...e,
            currentPath: [...e.currentPath, "items", "items", "1"]
        }) || {};
        return {
            type: "array",
            maxItems: 125,
            items: {
                type: "array",
                items: [r, o],
                minItems: 2,
                maxItems: 2
            }
        }
    }
    function Yg(t) {
        const e = t.values
          , o = Object.keys(t.values).filter(s => typeof e[e[s]] != "number").map(s => e[s])
          , n = Array.from(new Set(o.map(s => typeof s)));
        return {
            type: n.length === 1 ? n[0] === "string" ? "string" : "number" : ["string", "number"],
            enum: o
        }
    }
    function Kg() {
        return {
            not: {}
        }
    }
    function Qg(t) {
        return t.target === "openApi3" ? {
            enum: ["null"],
            nullable: !0
        } : {
            type: "null"
        }
    }
    const Wo = {
        ZodString: "string",
        ZodNumber: "number",
        ZodBigInt: "integer",
        ZodBoolean: "boolean",
        ZodNull: "null"
    };
    function Xg(t, e) {
        if (e.target === "openApi3")
            return Pc(t, e);
        const r = t.options instanceof Map ? Array.from(t.options.values()) : t.options;
        if (r.every(o => o._def.typeName in Wo && (!o._def.checks || !o._def.checks.length))) {
            const o = r.reduce( (n, s) => {
                const i = Wo[s._def.typeName];
                return i && !n.includes(i) ? [...n, i] : n
            }
            , []);
            return {
                type: o.length > 1 ? o : o[0]
            }
        } else if (r.every(o => o._def.typeName === "ZodLiteral" && !o.description)) {
            const o = r.reduce( (n, s) => {
                const i = typeof s._def.value;
                switch (i) {
                case "string":
                case "number":
                case "boolean":
                    return [...n, i];
                case "bigint":
                    return [...n, "integer"];
                case "object":
                    if (s._def.value === null)
                        return [...n, "null"];
                case "symbol":
                case "undefined":
                case "function":
                default:
                    return n
                }
            }
            , []);
            if (o.length === r.length) {
                const n = o.filter( (s, i, l) => l.indexOf(s) === i);
                return {
                    type: n.length > 1 ? n : n[0],
                    enum: r.reduce( (s, i) => s.includes(i._def.value) ? s : [...s, i._def.value], [])
                }
            }
        } else if (r.every(o => o._def.typeName === "ZodEnum"))
            return {
                type: "string",
                enum: r.reduce( (o, n) => [...o, ...n._def.values.filter(s => !o.includes(s))], [])
            };
        return Pc(t, e)
    }
    const Pc = (t, e) => {
        const r = (t.options instanceof Map ? Array.from(t.options.values()) : t.options).map( (o, n) => we(o._def, {
            ...e,
            currentPath: [...e.currentPath, "anyOf", `${n}`]
        })).filter(o => !!o && (!e.strictUnions || typeof o == "object" && Object.keys(o).length > 0));
        return r.length ? {
            anyOf: r
        } : void 0
    }
    ;
    function ef(t, e) {
        if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(t.innerType._def.typeName) && (!t.innerType._def.checks || !t.innerType._def.checks.length))
            return e.target === "openApi3" ? {
                type: Wo[t.innerType._def.typeName],
                nullable: !0
            } : {
                type: [Wo[t.innerType._def.typeName], "null"]
            };
        if (e.target === "openApi3") {
            const o = we(t.innerType._def, {
                ...e,
                currentPath: [...e.currentPath]
            });
            return o && "$ref"in o ? {
                allOf: [o],
                nullable: !0
            } : o && {
                ...o,
                nullable: !0
            }
        }
        const r = we(t.innerType._def, {
            ...e,
            currentPath: [...e.currentPath, "anyOf", "0"]
        });
        return r && {
            anyOf: [r, {
                type: "null"
            }]
        }
    }
    function tf(t, e) {
        const r = {
            type: "number"
        };
        if (!t.checks)
            return r;
        for (const o of t.checks)
            switch (o.kind) {
            case "int":
                r.type = "integer",
                bc(r, "type", o.message, e);
                break;
            case "min":
                e.target === "jsonSchema7" ? o.inclusive ? Ee(r, "minimum", o.value, o.message, e) : Ee(r, "exclusiveMinimum", o.value, o.message, e) : (o.inclusive || (r.exclusiveMinimum = !0),
                Ee(r, "minimum", o.value, o.message, e));
                break;
            case "max":
                e.target === "jsonSchema7" ? o.inclusive ? Ee(r, "maximum", o.value, o.message, e) : Ee(r, "exclusiveMaximum", o.value, o.message, e) : (o.inclusive || (r.exclusiveMaximum = !0),
                Ee(r, "maximum", o.value, o.message, e));
                break;
            case "multipleOf":
                Ee(r, "multipleOf", o.value, o.message, e);
                break
            }
        return r
    }
    function rf(t, e) {
        const r = e.target === "openAi"
          , o = {
            type: "object",
            properties: {}
        }
          , n = []
          , s = t.shape();
        for (const l in s) {
            let d = s[l];
            if (d === void 0 || d._def === void 0)
                continue;
            let u = of(d);
            u && r && (d instanceof Rt && (d = d._def.innerType),
            d.isNullable() || (d = d.nullable()),
            u = !1);
            const g = we(d._def, {
                ...e,
                currentPath: [...e.currentPath, "properties", l],
                propertyPath: [...e.currentPath, "properties", l]
            });
            g !== void 0 && (o.properties[l] = g,
            u || n.push(l))
        }
        n.length && (o.required = n);
        const i = nf(t, e);
        return i !== void 0 && (o.additionalProperties = i),
        o
    }
    function nf(t, e) {
        if (t.catchall._def.typeName !== "ZodNever")
            return we(t.catchall._def, {
                ...e,
                currentPath: [...e.currentPath, "additionalProperties"]
            });
        switch (t.unknownKeys) {
        case "passthrough":
            return e.allowedAdditionalProperties;
        case "strict":
            return e.rejectedAdditionalProperties;
        case "strip":
            return e.removeAdditionalStrategy === "strict" ? e.allowedAdditionalProperties : e.rejectedAdditionalProperties
        }
    }
    function of(t) {
        try {
            return t.isOptional()
        } catch {
            return !0
        }
    }
    const sf = (t, e) => {
        var o;
        if (e.currentPath.toString() === ((o = e.propertyPath) == null ? void 0 : o.toString()))
            return we(t.innerType._def, e);
        const r = we(t.innerType._def, {
            ...e,
            currentPath: [...e.currentPath, "anyOf", "1"]
        });
        return r ? {
            anyOf: [{
                not: {}
            }, r]
        } : {}
    }
      , af = (t, e) => {
        if (e.pipeStrategy === "input")
            return we(t.in._def, e);
        if (e.pipeStrategy === "output")
            return we(t.out._def, e);
        const r = we(t.in._def, {
            ...e,
            currentPath: [...e.currentPath, "allOf", "0"]
        })
          , o = we(t.out._def, {
            ...e,
            currentPath: [...e.currentPath, "allOf", r ? "1" : "0"]
        });
        return {
            allOf: [r, o].filter(n => n !== void 0)
        }
    }
    ;
    function lf(t, e) {
        return we(t.type._def, e)
    }
    function cf(t, e) {
        const o = {
            type: "array",
            uniqueItems: !0,
            items: we(t.valueType._def, {
                ...e,
                currentPath: [...e.currentPath, "items"]
            })
        };
        return t.minSize && Ee(o, "minItems", t.minSize.value, t.minSize.message, e),
        t.maxSize && Ee(o, "maxItems", t.maxSize.value, t.maxSize.message, e),
        o
    }
    function df(t, e) {
        return t.rest ? {
            type: "array",
            minItems: t.items.length,
            items: t.items.map( (r, o) => we(r._def, {
                ...e,
                currentPath: [...e.currentPath, "items", `${o}`]
            })).reduce( (r, o) => o === void 0 ? r : [...r, o], []),
            additionalItems: we(t.rest._def, {
                ...e,
                currentPath: [...e.currentPath, "additionalItems"]
            })
        } : {
            type: "array",
            minItems: t.items.length,
            maxItems: t.items.length,
            items: t.items.map( (r, o) => we(r._def, {
                ...e,
                currentPath: [...e.currentPath, "items", `${o}`]
            })).reduce( (r, o) => o === void 0 ? r : [...r, o], [])
        }
    }
    function uf() {
        return {
            not: {}
        }
    }
    function mf() {
        return {}
    }
    const pf = (t, e) => we(t.innerType._def, e)
      , hf = (t, e, r) => {
        switch (e) {
        case F.ZodString:
            return xc(t, r);
        case F.ZodNumber:
            return tf(t, r);
        case F.ZodObject:
            return rf(t, r);
        case F.ZodBigInt:
            return Ug(t, r);
        case F.ZodBoolean:
            return jg();
        case F.ZodDate:
            return Ec(t, r);
        case F.ZodUndefined:
            return uf();
        case F.ZodNull:
            return Qg(r);
        case F.ZodArray:
            return Lg(t, r);
        case F.ZodUnion:
        case F.ZodDiscriminatedUnion:
            return Xg(t, r);
        case F.ZodIntersection:
            return zg(t, r);
        case F.ZodTuple:
            return df(t, r);
        case F.ZodRecord:
            return Tc(t, r);
        case F.ZodLiteral:
            return Zg(t, r);
        case F.ZodEnum:
            return Gg(t);
        case F.ZodNativeEnum:
            return Yg(t);
        case F.ZodNullable:
            return ef(t, r);
        case F.ZodOptional:
            return sf(t, r);
        case F.ZodMap:
            return Jg(t, r);
        case F.ZodSet:
            return cf(t, r);
        case F.ZodLazy:
            return () => t.getter()._def;
        case F.ZodPromise:
            return lf(t, r);
        case F.ZodNaN:
        case F.ZodNever:
            return Kg();
        case F.ZodEffects:
            return qg(t, r);
        case F.ZodAny:
            return Ng();
        case F.ZodUnknown:
            return mf();
        case F.ZodDefault:
            return Wg(t, r);
        case F.ZodBranded:
            return Sc(t, r);
        case F.ZodReadonly:
            return pf(t, r);
        case F.ZodCatch:
            return Mg(t, r);
        case F.ZodPipeline:
            return af(t, r);
        case F.ZodFunction:
        case F.ZodVoid:
        case F.ZodSymbol:
            return;
        default:
            return (o => {}
            )()
        }
    }
    ;
    function we(t, e, r=!1) {
        var l;
        const o = e.seen.get(t);
        if (e.override) {
            const d = (l = e.override) == null ? void 0 : l.call(e, t, e, o, r);
            if (d !== Rg)
                return d
        }
        if (o && !r) {
            const d = gf(o, e);
            if (d !== void 0)
                return d
        }
        const n = {
            def: t,
            path: e.currentPath,
            jsonSchema: void 0
        };
        e.seen.set(t, n);
        const s = hf(t, t.typeName, e)
          , i = typeof s == "function" ? we(s(), e) : s;
        if (i && yf(t, e, i),
        e.postProcess) {
            const d = e.postProcess(i, t, e);
            return n.jsonSchema = i,
            d
        }
        return n.jsonSchema = i,
        i
    }
    const gf = (t, e) => {
        switch (e.$refStrategy) {
        case "root":
            return {
                $ref: t.path.join("/")
            };
        case "relative":
            return {
                $ref: ff(e.currentPath, t.path)
            };
        case "none":
        case "seen":
            return t.path.length < e.currentPath.length && t.path.every( (r, o) => e.currentPath[o] === r) ? (console.warn(`Recursive reference detected at ${e.currentPath.join("/")}! Defaulting to any`),
            {}) : e.$refStrategy === "seen" ? {} : void 0
        }
    }
      , ff = (t, e) => {
        let r = 0;
        for (; r < t.length && r < e.length && t[r] === e[r]; r++)
            ;
        return [(t.length - r).toString(), ...e.slice(r)].join("/")
    }
      , yf = (t, e, r) => (t.description && (r.description = t.description,
    e.markdownDescription && (r.markdownDescription = t.description)),
    r)
      , kc = (t, e) => {
        const r = Dg(e)
          , o = typeof e == "object" && e.definitions ? Object.entries(e.definitions).reduce( (d, [u,g]) => ({
            ...d,
            [u]: we(g._def, {
                ...r,
                currentPath: [...r.basePath, r.definitionPath, u]
            }, !0) ?? {}
        }), {}) : void 0
          , n = typeof e == "string" ? e : (e == null ? void 0 : e.nameStrategy) === "title" || e == null ? void 0 : e.name
          , s = we(t._def, n === void 0 ? r : {
            ...r,
            currentPath: [...r.basePath, r.definitionPath, n]
        }, !1) ?? {}
          , i = typeof e == "object" && e.name !== void 0 && e.nameStrategy === "title" ? e.name : void 0;
        i !== void 0 && (s.title = i);
        const l = n === void 0 ? o ? {
            ...s,
            [r.definitionPath]: o
        } : s : {
            $ref: [...r.$refStrategy === "relative" ? [] : r.basePath, r.definitionPath, n].join("/"),
            [r.definitionPath]: {
                ...o,
                [n]: s
            }
        };
        return r.target === "jsonSchema7" ? l.$schema = "http://json-schema.org/draft-07/schema#" : (r.target === "jsonSchema2019-09" || r.target === "openAi") && (l.$schema = "https://json-schema.org/draft/2019-09/schema#"),
        r.target === "openAi" && ("anyOf"in l || "oneOf"in l || "allOf"in l || "type"in l && Array.isArray(l.type)) && console.warn("Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property."),
        l
    }
    ;
    var Ta;
    (function(t) {
        t.Completable = "McpCompletable"
    }
    )(Ta || (Ta = {}));
    class Pa extends ue {
        _parse(e) {
            const {ctx: r} = this._processInputParams(e)
              , o = r.data;
            return this._def.type._parse({
                data: o,
                path: r.path,
                parent: r
            })
        }
        unwrap() {
            return this._def.type
        }
    }
    Pa.create = (t, e) => new Pa({
        type: t,
        typeName: Ta.Completable,
        complete: e.complete,
        ...vf(e)
    });
    function vf(t) {
        if (!t)
            return {};
        const {errorMap: e, invalid_type_error: r, required_error: o, description: n} = t;
        if (e && (r || o))
            throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
        return e ? {
            errorMap: e,
            description: n
        } : {
            errorMap: (i, l) => {
                var d, u;
                const {message: g} = t;
                return i.code === "invalid_enum_value" ? {
                    message: g ?? l.defaultError
                } : typeof l.data > "u" ? {
                    message: (d = g ?? o) !== null && d !== void 0 ? d : l.defaultError
                } : i.code !== "invalid_type" ? {
                    message: l.defaultError
                } : {
                    message: (u = g ?? r) !== null && u !== void 0 ? u : l.defaultError
                }
            }
            ,
            description: n
        }
    }
    class He {
        constructor(e, r) {
            this._registeredResources = {},
            this._registeredResourceTemplates = {},
            this._registeredTools = {},
            this._registeredPrompts = {},
            this._toolHandlersInitialized = !1,
            this._completionHandlerInitialized = !1,
            this._resourceHandlersInitialized = !1,
            this._promptHandlersInitialized = !1,
            this.server = new Ag(e,r)
        }
        async connect(e) {
            return await this.server.connect(e)
        }
        async close() {
            await this.server.close()
        }
        setToolRequestHandlers() {
            this._toolHandlersInitialized || (this.server.assertCanSetRequestHandler(_o.shape.method.value),
            this.server.assertCanSetRequestHandler(To.shape.method.value),
            this.server.registerCapabilities({
                tools: {
                    listChanged: !0
                }
            }),
            this.server.setRequestHandler(_o, () => ({
                tools: Object.entries(this._registeredTools).filter( ([,e]) => e.enabled).map( ([e,r]) => {
                    const o = {
                        name: e,
                        title: r.title,
                        description: r.description,
                        inputSchema: r.inputSchema ? kc(r.inputSchema, {
                            strictUnions: !0
                        }) : wf,
                        annotations: r.annotations
                    };
                    return r.outputSchema && (o.outputSchema = kc(r.outputSchema, {
                        strictUnions: !0
                    })),
                    o
                }
                )
            })),
            this.server.setRequestHandler(To, async (e, r) => {
                const o = this._registeredTools[e.params.name];
                if (!o)
                    throw new Le(Re.InvalidParams,`Tool ${e.params.name} not found`);
                if (!o.enabled)
                    throw new Le(Re.InvalidParams,`Tool ${e.params.name} disabled`);
                let n;
                if (o.inputSchema) {
                    const s = await o.inputSchema.safeParseAsync(e.params.arguments);
                    if (!s.success)
                        throw new Le(Re.InvalidParams,`Invalid arguments for tool ${e.params.name}: ${s.error.message}`);
                    const i = s.data
                      , l = o.callback;
                    try {
                        n = await Promise.resolve(l(i, r))
                    } catch (d) {
                        n = {
                            content: [{
                                type: "text",
                                text: d instanceof Error ? d.message : String(d)
                            }],
                            isError: !0
                        }
                    }
                } else {
                    const s = o.callback;
                    try {
                        n = await Promise.resolve(s(r))
                    } catch (i) {
                        n = {
                            content: [{
                                type: "text",
                                text: i instanceof Error ? i.message : String(i)
                            }],
                            isError: !0
                        }
                    }
                }
                if (o.outputSchema && !n.isError) {
                    if (!n.structuredContent)
                        throw new Le(Re.InvalidParams,`Tool ${e.params.name} has an output schema but no structured content was provided`);
                    const s = await o.outputSchema.safeParseAsync(n.structuredContent);
                    if (!s.success)
                        throw new Le(Re.InvalidParams,`Invalid structured content for tool ${e.params.name}: ${s.error.message}`)
                }
                return n
            }
            ),
            this._toolHandlersInitialized = !0)
        }
        setCompletionRequestHandler() {
            this._completionHandlerInitialized || (this.server.assertCanSetRequestHandler(Po.shape.method.value),
            this.server.registerCapabilities({
                completions: {}
            }),
            this.server.setRequestHandler(Po, async e => {
                switch (e.params.ref.type) {
                case "ref/prompt":
                    return this.handlePromptCompletion(e, e.params.ref);
                case "ref/resource":
                    return this.handleResourceCompletion(e, e.params.ref);
                default:
                    throw new Le(Re.InvalidParams,`Invalid completion reference: ${e.params.ref}`)
                }
            }
            ),
            this._completionHandlerInitialized = !0)
        }
        async handlePromptCompletion(e, r) {
            const o = this._registeredPrompts[r.name];
            if (!o)
                throw new Le(Re.InvalidParams,`Prompt ${r.name} not found`);
            if (!o.enabled)
                throw new Le(Re.InvalidParams,`Prompt ${r.name} disabled`);
            if (!o.argsSchema)
                return qo;
            const n = o.argsSchema.shape[e.params.argument.name];
            if (!(n instanceof Pa))
                return qo;
            const i = await n._def.complete(e.params.argument.value, e.params.context);
            return Cc(i)
        }
        async handleResourceCompletion(e, r) {
            const o = Object.values(this._registeredResourceTemplates).find(i => i.resourceTemplate.uriTemplate.toString() === r.uri);
            if (!o) {
                if (this._registeredResources[r.uri])
                    return qo;
                throw new Le(Re.InvalidParams,`Resource template ${e.params.ref.uri} not found`)
            }
            const n = o.resourceTemplate.completeCallback(e.params.argument.name);
            if (!n)
                return qo;
            const s = await n(e.params.argument.value, e.params.context);
            return Cc(s)
        }
        setResourceRequestHandlers() {
            this._resourceHandlersInitialized || (this.server.assertCanSetRequestHandler(fo.shape.method.value),
            this.server.assertCanSetRequestHandler(yo.shape.method.value),
            this.server.assertCanSetRequestHandler(vo.shape.method.value),
            this.server.registerCapabilities({
                resources: {
                    listChanged: !0
                }
            }),
            this.server.setRequestHandler(fo, async (e, r) => {
                const o = Object.entries(this._registeredResources).filter( ([s,i]) => i.enabled).map( ([s,i]) => ({
                    uri: s,
                    name: i.name,
                    ...i.metadata
                }))
                  , n = [];
                for (const s of Object.values(this._registeredResourceTemplates)) {
                    if (!s.resourceTemplate.listCallback)
                        continue;
                    const i = await s.resourceTemplate.listCallback(r);
                    for (const l of i.resources)
                        n.push({
                            ...s.metadata,
                            ...l
                        })
                }
                return {
                    resources: [...o, ...n]
                }
            }
            ),
            this.server.setRequestHandler(yo, async () => ({
                resourceTemplates: Object.entries(this._registeredResourceTemplates).map( ([r,o]) => ({
                    name: r,
                    uriTemplate: o.resourceTemplate.uriTemplate.toString(),
                    ...o.metadata
                }))
            })),
            this.server.setRequestHandler(vo, async (e, r) => {
                const o = new URL(e.params.uri)
                  , n = this._registeredResources[o.toString()];
                if (n) {
                    if (!n.enabled)
                        throw new Le(Re.InvalidParams,`Resource ${o} disabled`);
                    return n.readCallback(o, r)
                }
                for (const s of Object.values(this._registeredResourceTemplates)) {
                    const i = s.resourceTemplate.uriTemplate.match(o.toString());
                    if (i)
                        return s.readCallback(o, i, r)
                }
                throw new Le(Re.InvalidParams,`Resource ${o} not found`)
            }
            ),
            this.setCompletionRequestHandler(),
            this._resourceHandlersInitialized = !0)
        }
        setPromptRequestHandlers() {
            this._promptHandlersInitialized || (this.server.assertCanSetRequestHandler(wo.shape.method.value),
            this.server.assertCanSetRequestHandler(bo.shape.method.value),
            this.server.registerCapabilities({
                prompts: {
                    listChanged: !0
                }
            }),
            this.server.setRequestHandler(wo, () => ({
                prompts: Object.entries(this._registeredPrompts).filter( ([,e]) => e.enabled).map( ([e,r]) => ({
                    name: e,
                    title: r.title,
                    description: r.description,
                    arguments: r.argsSchema ? Sf(r.argsSchema) : void 0
                }))
            })),
            this.server.setRequestHandler(bo, async (e, r) => {
                const o = this._registeredPrompts[e.params.name];
                if (!o)
                    throw new Le(Re.InvalidParams,`Prompt ${e.params.name} not found`);
                if (!o.enabled)
                    throw new Le(Re.InvalidParams,`Prompt ${e.params.name} disabled`);
                if (o.argsSchema) {
                    const n = await o.argsSchema.safeParseAsync(e.params.arguments);
                    if (!n.success)
                        throw new Le(Re.InvalidParams,`Invalid arguments for prompt ${e.params.name}: ${n.error.message}`);
                    const s = n.data
                      , i = o.callback;
                    return await Promise.resolve(i(s, r))
                } else {
                    const n = o.callback;
                    return await Promise.resolve(n(r))
                }
            }
            ),
            this.setCompletionRequestHandler(),
            this._promptHandlersInitialized = !0)
        }
        resource(e, r, ...o) {
            let n;
            typeof o[0] == "object" && (n = o.shift());
            const s = o[0];
            if (typeof r == "string") {
                if (this._registeredResources[r])
                    throw new Error(`Resource ${r} is already registered`);
                const i = this._createRegisteredResource(e, void 0, r, n, s);
                return this.setResourceRequestHandlers(),
                this.sendResourceListChanged(),
                i
            } else {
                if (this._registeredResourceTemplates[e])
                    throw new Error(`Resource template ${e} is already registered`);
                const i = this._createRegisteredResourceTemplate(e, void 0, r, n, s);
                return this.setResourceRequestHandlers(),
                this.sendResourceListChanged(),
                i
            }
        }
        registerResource(e, r, o, n) {
            if (typeof r == "string") {
                if (this._registeredResources[r])
                    throw new Error(`Resource ${r} is already registered`);
                const s = this._createRegisteredResource(e, o.title, r, o, n);
                return this.setResourceRequestHandlers(),
                this.sendResourceListChanged(),
                s
            } else {
                if (this._registeredResourceTemplates[e])
                    throw new Error(`Resource template ${e} is already registered`);
                const s = this._createRegisteredResourceTemplate(e, o.title, r, o, n);
                return this.setResourceRequestHandlers(),
                this.sendResourceListChanged(),
                s
            }
        }
        _createRegisteredResource(e, r, o, n, s) {
            const i = {
                name: e,
                title: r,
                metadata: n,
                readCallback: s,
                enabled: !0,
                disable: () => i.update({
                    enabled: !1
                }),
                enable: () => i.update({
                    enabled: !0
                }),
                remove: () => i.update({
                    uri: null
                }),
                update: l => {
                    typeof l.uri < "u" && l.uri !== o && (delete this._registeredResources[o],
                    l.uri && (this._registeredResources[l.uri] = i)),
                    typeof l.name < "u" && (i.name = l.name),
                    typeof l.title < "u" && (i.title = l.title),
                    typeof l.metadata < "u" && (i.metadata = l.metadata),
                    typeof l.callback < "u" && (i.readCallback = l.callback),
                    typeof l.enabled < "u" && (i.enabled = l.enabled),
                    this.sendResourceListChanged()
                }
            };
            return this._registeredResources[o] = i,
            i
        }
        _createRegisteredResourceTemplate(e, r, o, n, s) {
            const i = {
                resourceTemplate: o,
                title: r,
                metadata: n,
                readCallback: s,
                enabled: !0,
                disable: () => i.update({
                    enabled: !1
                }),
                enable: () => i.update({
                    enabled: !0
                }),
                remove: () => i.update({
                    name: null
                }),
                update: l => {
                    typeof l.name < "u" && l.name !== e && (delete this._registeredResourceTemplates[e],
                    l.name && (this._registeredResourceTemplates[l.name] = i)),
                    typeof l.title < "u" && (i.title = l.title),
                    typeof l.template < "u" && (i.resourceTemplate = l.template),
                    typeof l.metadata < "u" && (i.metadata = l.metadata),
                    typeof l.callback < "u" && (i.readCallback = l.callback),
                    typeof l.enabled < "u" && (i.enabled = l.enabled),
                    this.sendResourceListChanged()
                }
            };
            return this._registeredResourceTemplates[e] = i,
            i
        }
        _createRegisteredPrompt(e, r, o, n, s) {
            const i = {
                title: r,
                description: o,
                argsSchema: n === void 0 ? void 0 : a.object(n),
                callback: s,
                enabled: !0,
                disable: () => i.update({
                    enabled: !1
                }),
                enable: () => i.update({
                    enabled: !0
                }),
                remove: () => i.update({
                    name: null
                }),
                update: l => {
                    typeof l.name < "u" && l.name !== e && (delete this._registeredPrompts[e],
                    l.name && (this._registeredPrompts[l.name] = i)),
                    typeof l.title < "u" && (i.title = l.title),
                    typeof l.description < "u" && (i.description = l.description),
                    typeof l.argsSchema < "u" && (i.argsSchema = a.object(l.argsSchema)),
                    typeof l.callback < "u" && (i.callback = l.callback),
                    typeof l.enabled < "u" && (i.enabled = l.enabled),
                    this.sendPromptListChanged()
                }
            };
            return this._registeredPrompts[e] = i,
            i
        }
        _createRegisteredTool(e, r, o, n, s, i, l) {
            const d = {
                title: r,
                description: o,
                inputSchema: n === void 0 ? void 0 : a.object(n),
                outputSchema: s === void 0 ? void 0 : a.object(s),
                annotations: i,
                callback: l,
                enabled: !0,
                disable: () => d.update({
                    enabled: !1
                }),
                enable: () => d.update({
                    enabled: !0
                }),
                remove: () => d.update({
                    name: null
                }),
                update: u => {
                    typeof u.name < "u" && u.name !== e && (delete this._registeredTools[e],
                    u.name && (this._registeredTools[u.name] = d)),
                    typeof u.title < "u" && (d.title = u.title),
                    typeof u.description < "u" && (d.description = u.description),
                    typeof u.paramsSchema < "u" && (d.inputSchema = a.object(u.paramsSchema)),
                    typeof u.callback < "u" && (d.callback = u.callback),
                    typeof u.annotations < "u" && (d.annotations = u.annotations),
                    typeof u.enabled < "u" && (d.enabled = u.enabled),
                    this.sendToolListChanged()
                }
            };
            return this._registeredTools[e] = d,
            this.setToolRequestHandlers(),
            this.sendToolListChanged(),
            d
        }
        tool(e, ...r) {
            if (this._registeredTools[e])
                throw new Error(`Tool ${e} is already registered`);
            let o, n, s, i;
            if (typeof r[0] == "string" && (o = r.shift()),
            r.length > 1) {
                const d = r[0];
                Ic(d) ? (n = r.shift(),
                r.length > 1 && typeof r[0] == "object" && r[0] !== null && !Ic(r[0]) && (i = r.shift())) : typeof d == "object" && d !== null && (i = r.shift())
            }
            const l = r[0];
            return this._createRegisteredTool(e, void 0, o, n, s, i, l)
        }
        registerTool(e, r, o) {
            if (this._registeredTools[e])
                throw new Error(`Tool ${e} is already registered`);
            const {title: n, description: s, inputSchema: i, outputSchema: l, annotations: d} = r;
            return this._createRegisteredTool(e, n, s, i, l, d, o)
        }
        prompt(e, ...r) {
            if (this._registeredPrompts[e])
                throw new Error(`Prompt ${e} is already registered`);
            let o;
            typeof r[0] == "string" && (o = r.shift());
            let n;
            r.length > 1 && (n = r.shift());
            const s = r[0]
              , i = this._createRegisteredPrompt(e, void 0, o, n, s);
            return this.setPromptRequestHandlers(),
            this.sendPromptListChanged(),
            i
        }
        registerPrompt(e, r, o) {
            if (this._registeredPrompts[e])
                throw new Error(`Prompt ${e} is already registered`);
            const {title: n, description: s, argsSchema: i} = r
              , l = this._createRegisteredPrompt(e, n, s, i, o);
            return this.setPromptRequestHandlers(),
            this.sendPromptListChanged(),
            l
        }
        isConnected() {
            return this.server.transport !== void 0
        }
        sendResourceListChanged() {
            this.isConnected() && this.server.sendResourceListChanged()
        }
        sendToolListChanged() {
            this.isConnected() && this.server.sendToolListChanged()
        }
        sendPromptListChanged() {
            this.isConnected() && this.server.sendPromptListChanged()
        }
    }
    const wf = {
        type: "object",
        properties: {}
    };
    function Ic(t) {
        return typeof t != "object" || t === null ? !1 : Object.keys(t).length === 0 || Object.values(t).some(bf)
    }
    function bf(t) {
        return t !== null && typeof t == "object" && "parse"in t && typeof t.parse == "function" && "safeParse"in t && typeof t.safeParse == "function"
    }
    function Sf(t) {
        return Object.entries(t.shape).map( ([e,r]) => ({
            name: e,
            description: r.description,
            required: !r.isOptional()
        }))
    }
    function Cc(t) {
        return {
            completion: {
                values: t.slice(0, 100),
                total: t.length,
                hasMore: t.length > 100
            }
        }
    }
    const qo = {
        completion: {
            values: [],
            hasMore: !1
        }
    };
    typeof window < "u" && (window.ModelContextProtocolSDK = {
        server: {
            McpServer: He
        },
        types: Al
    }),
    typeof globalThis < "u" && (globalThis.ModelContextProtocolSDK = {
        server: {
            McpServer: He
        },
        types: Al
    });
    var be = (t => (t.ANGIE_ROUTE_NAVIGATION = "angie-route-navigation",
    t.ANGIE_CHAT_TOGGLE = "angie-chat-toggle",
    t.ANGIE_STUDIO_TOGGLE = "angie-studio-toggle",
    t.ANGIE_SIDEBAR_TOGGLED = "angie-sidebar-toggled",
    t.ANGIE_SIDEBAR_RESIZED = "angie-sidebar-resized",
    t.STUDIO_UI_SESSION_START = "studio-ui-session-start",
    t.STUDIO_UI_STATE_UPDATE = "studio-ui-state-update",
    t.STUDIO_UI_SESSION_END = "studio-ui-session-end",
    t.ANGIE_ELEMENT_UPDATE_CUSTOM_CSS = "angie/element/update-custom-css",
    t.ANGIE_ELEMENT_GET_HTML_MARKUP = "angie/element/get-html-markup",
    t.ANGIE_ELEMENT_INJECT_CSS = "angie/element/inject-css",
    t.ANGIE_ELEMENT_REMOVE_CSS = "angie/element/remove-css",
    t.ANGIE_ELEMENT_GET_CSS = "angie/element/get-css",
    t.ANGIE_MEDIA_UPLOAD = "angie/media/upload",
    t.ANGIE_SETTINGS_UPDATE = "angie/settings/update",
    t.ANGIE_CONTEXT_GET_WEBSITE_CONTEXT = "angie/context/get-website-context",
    t.ANGIE_CONTEXT_GET_ANALYTICS_CONTEXT = "angie/context/get-analytics-context",
    t.ANGIE_CONTEXT_GET_POST_ID = "angie/context/get-post-id",
    t.ANGIE_ELEMENT_UPDATE_SETTINGS = "angie/element/update-settings",
    t.ANGIE_GET_MEDIA_BLOB = "angie/get-media-blob",
    t.ANGIE_WP_UPDATE_POST_FEATURED_IMAGE = "angie/wp/update-post-featured-image",
    t.ANGIE_ELEMENT_GET_ELEMENT_ATTRIBUTES = "angie/element/get-element-attributes",
    t.ANGIE_GUTENBERG_UPDATE_BLOCK = "angie/gutenberg/update-block",
    t.ANGIE_GUTENBERG_PREVIEW_IMAGE = "angie/gutenberg/preview-image",
    t.ANGIE_GUTENBERG_REMOVE_PREVIEW = "angie/gutenberg/remove-preview",
    t.ANGIE_MINIAPP_START = "angie/miniapp/start",
    t.ANGIE_ZOOM_DISPLAY = "angie/zoom/display",
    t.ANGIE_MODAL_DISPLAY = "angie/modal/display",
    t.ANGIE_BRAND_VOICE_MODAL = "angie/brand-voice/modal",
    t.INIT_CONTEXT_SERVER = "init-context-server",
    t.ANGIE_NAVIGATE_TO_URL = "angie/navigate-to-url",
    t.ANGIE_PAGE_RELOAD = "angie/page-reload",
    t.ANGIE_CLIPBOARD_WRITE = "angie/clipboard/write",
    t.REFERRER_INFO = "referrer/info",
    t.QUERY_WP_DB = "query-wp-db",
    t.SDK_ANGIE_READY_PING = "sdk-angie-ready-ping",
    t.SDK_ANGIE_REFRESH_PING = "sdk-angie-refresh-ping",
    t.SDK_ANGIE_ALL_SERVERS_REGISTERED = "sdk-angie-all-servers-registered",
    t.SDK_REQUEST_CLIENT_CREATION = "sdk-request-client-creation",
    t.SDK_REQUEST_INIT_SERVER = "sdk-request-init-server",
    t.SDK_TRIGGER_ANGIE = "sdk-trigger-angie",
    t.SDK_TRIGGER_ANGIE_RESPONSE = "sdk-trigger-angie-response",
    t.ANGIE_PROCESSING_STATE_CHANGE = "angie-processing-state-change",
    t))(be || {});
    function Ef() {
        const t = document.createElement("div");
        t.id = "angie-zoom-overlay",
        t.tabIndex = 0,
        t.style.cssText = `
		position: fixed;
		top: 0;
		left: 0;
		width: 100vw;
		height: 100vh;
		background: rgba(0, 0, 0, 0.9);
		display: flex;
		align-items: center;
		justify-content: center;
		z-index: 1000000;
		backdrop-filter: blur(5px);
		outline: none;
	`;
        const e = document.createElement("button");
        e.innerHTML = "",
        e.style.cssText = `
		position: absolute;
		top: 20px;
		right: 20px;
		background: rgba(255, 255, 255, 0.9);
		border: none;
		border-radius: 50%;
		width: 40px;
		height: 40px;
		font-size: 24px;
		cursor: pointer;
		z-index: 1000001;
		display: flex;
		align-items: center;
		justify-content: center;
		color: #333;
		font-weight: bold;
		transition: all 0.2s;
	`,
        e.addEventListener("mouseenter", () => {
            e.style.backgroundColor = "rgba(255, 255, 255, 1)",
            e.style.transform = "scale(1.1)"
        }
        ),
        e.addEventListener("mouseleave", () => {
            e.style.backgroundColor = "rgba(255, 255, 255, 0.9)",
            e.style.transform = "scale(1)"
        }
        );
        const r = document.createElement("div");
        r.style.cssText = `
		position: relative;
		max-width: 90vw;
		max-height: 90vh;
		display: flex;
		align-items: center;
		justify-content: center;
	`;
        const o = document.createElement("div");
        o.style.cssText = `
		position: relative;
		display: flex;
		align-items: center;
		justify-content: center;
	`;
        const n = document.createElement("img");
        return n.style.cssText = `
		max-width: 100%;
		max-height: 100%;
		object-fit: contain;
		border-radius: 8px;
		box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
	`,
        {
            overlay: t,
            closeButton: e,
            contentContainer: r,
            imageContainer: o,
            img: n
        }
    }
    function xf(t, e, r, o) {
        if (o <= 1)
            return {
                prevButton: null,
                nextButton: null
            };
        const n = document.createElement("button");
        n.innerHTML = "",
        n.style.cssText = `
		position: absolute;
		left: -60px;
		top: 50%;
		transform: translateY(-50%);
		background: rgba(255, 255, 255, 0.9);
		border: none;
		border-radius: 50%;
		width: 50px;
		height: 50px;
		font-size: 24px;
		cursor: pointer;
		z-index: 1000001;
		display: flex;
		align-items: center;
		justify-content: center;
		color: #333;
		font-weight: bold;
		transition: all 0.2s;
	`,
        n.addEventListener("mouseenter", () => {
            n.style.backgroundColor = "rgba(255, 255, 255, 1)",
            n.style.transform = "translateY(-50%) scale(1.05)"
        }
        ),
        n.addEventListener("mouseleave", () => {
            n.style.backgroundColor = "rgba(255, 255, 255, 0.9)",
            n.style.transform = "translateY(-50%) scale(1)"
        }
        ),
        n.onclick = i => {
            i.stopPropagation(),
            e()
        }
        ;
        const s = document.createElement("button");
        return s.innerHTML = "",
        s.style.cssText = `
		position: absolute;
		right: -60px;
		top: 50%;
		transform: translateY(-50%);
		background: rgba(255, 255, 255, 0.9);
		border: none;
		border-radius: 50%;
		width: 50px;
		height: 50px;
		font-size: 24px;
		cursor: pointer;
		z-index: 1000001;
		display: flex;
		align-items: center;
		justify-content: center;
		color: #333;
		font-weight: bold;
		transition: all 0.2s;
	`,
        s.addEventListener("mouseenter", () => {
            s.style.backgroundColor = "rgba(255, 255, 255, 1)",
            s.style.transform = "translateY(-50%) scale(1.05)"
        }
        ),
        s.addEventListener("mouseleave", () => {
            s.style.backgroundColor = "rgba(255, 255, 255, 0.9)",
            s.style.transform = "translateY(-50%) scale(1)"
        }
        ),
        s.onclick = i => {
            i.stopPropagation(),
            r()
        }
        ,
        t.appendChild(n),
        t.appendChild(s),
        {
            prevButton: n,
            nextButton: s
        }
    }
    function _f(t, e) {
        if (e <= 1)
            return null;
        const r = document.createElement("div");
        return r.style.cssText = `
		position: absolute;
		top: 20px;
		left: 50%;
		transform: translateX(-50%);
		background: rgba(0, 0, 0, 0.7);
		color: white;
		padding: 8px 16px;
		border-radius: 20px;
		font-size: 14px;
		font-weight: 500;
		z-index: 1000001;
	`,
        t.appendChild(r),
        r
    }
    function Tf(t, e, r) {
        if (e.length <= 1)
            return null;
        const o = document.createElement("div");
        o.style.cssText = `
		position: absolute;
		bottom: 20px;
		left: 50%;
		transform: translateX(-50%);
		display: flex;
		gap: 8px;
		padding: 12px;
		background: rgba(0, 0, 0, 0.5);
		border-radius: 8px;
		max-width: 90vw;
		overflow-x: auto;
		scrollbar-width: none;
		-ms-overflow-style: none;
	`;
        const n = document.createElement("style");
        return n.textContent = `
		#angie-zoom-overlay .thumbnail-container::-webkit-scrollbar {
			display: none;
		}
	`,
        document.head.appendChild(n),
        o.className = "thumbnail-container",
        e.forEach( (s, i) => {
            const l = document.createElement("img");
            l.src = s.image_url,
            l.className = "thumbnail",
            l.style.cssText = `
			width: 60px;
			height: 60px;
			object-fit: cover;
			border-radius: 4px;
			cursor: pointer;
			transition: all 0.2s;
			border: 2px solid rgba(255, 255, 255, 0.3);
			opacity: 0.7;
		`,
            l.addEventListener("mouseenter", () => {
                i !== $c() && (l.style.opacity = "0.9",
                l.style.transform = "scale(1.05)")
            }
            ),
            l.addEventListener("mouseleave", () => {
                i !== $c() && (l.style.opacity = "0.7",
                l.style.transform = "scale(1)")
            }
            ),
            l.onclick = d => {
                d.stopPropagation(),
                r(i)
            }
            ,
            o.appendChild(l)
        }
        ),
        t.appendChild(o),
        o
    }
    let vt = 0;
    function $c() {
        return vt
    }
    function Pf(t, e) {
        const {images: r} = t
          , {img: o, counterElement: n, prevButton: s, nextButton: i, thumbnailContainer: l} = e
          , d = r.length > 1;
        vt = Math.max(0, Math.min(t.initialIndex || 0, r.length - 1));
        const u = () => {
            const p = r[vt];
            o.src = p.image_url,
            o.alt = `Image ${vt + 1}`,
            d && n && (n.textContent = `${vt + 1} of ${r.length}`),
            s && (s.style.opacity = "1",
            s.style.cursor = "pointer"),
            i && (i.style.opacity = "1",
            i.style.cursor = "pointer"),
            d && l && l.querySelectorAll(".thumbnail").forEach( (f, y) => {
                y === vt ? (f.style.border = "3px solid #EB8EFB",
                f.style.opacity = "1") : (f.style.border = "2px solid rgba(255, 255, 255, 0.3)",
                f.style.opacity = "0.7")
            }
            )
        }
        ;
        return {
            updateImage: u,
            goToPrevious: () => {
                vt = vt === 0 ? r.length - 1 : vt - 1,
                u()
            }
            ,
            goToNext: () => {
                vt = vt === r.length - 1 ? 0 : vt + 1,
                u()
            }
            ,
            goToIndex: p => {
                p >= 0 && p < r.length && (vt = p,
                u())
            }
            ,
            isGalleryMode: d
        }
    }
    function kf(t, e, r) {
        const {overlay: o, closeButton: n, contentContainer: s, img: i} = t
          , l = () => {
            o.remove(),
            document.removeEventListener("keydown", d),
            document.head.querySelectorAll("style").forEach(g => {
                var c;
                (c = g.textContent) != null && c.includes("thumbnail-container::-webkit-scrollbar") && g.remove()
            }
            )
        }
          , d = u => {
            switch (u.key) {
            case "Escape":
                l();
                break;
            case "ArrowLeft":
                r && (u.preventDefault(),
                e.goToPrevious());
                break;
            case "ArrowRight":
                r && (u.preventDefault(),
                e.goToNext());
                break
            }
        }
        ;
        n.onclick = u => {
            u.stopPropagation(),
            l()
        }
        ,
        o.onclick = l,
        s.onclick = u => {
            u.stopPropagation()
        }
        ,
        i.onclick = u => {
            u.stopPropagation()
        }
        ,
        document.addEventListener("keydown", d)
    }
    const If = t => {
        if (!t.images || t.images.length === 0) {
            console.warn("No images provided to showZoomOverlay");
            return
        }
        const e = document.getElementById("angie-zoom-overlay");
        e && e.remove();
        const r = Ef()
          , o = Pf(t, r)
          , {updateImage: n, goToPrevious: s, goToNext: i, goToIndex: l, isGalleryMode: d} = o
          , u = xf(r.imageContainer, s, i, t.images.length)
          , g = _f(r.overlay, t.images.length)
          , c = Tf(r.overlay, t.images, l)
          , m = {
            ...r,
            prevButton: u.prevButton || void 0,
            nextButton: u.nextButton || void 0,
            counterElement: g || void 0,
            thumbnailContainer: c || void 0
        };
        kf(m, {
            goToPrevious: s,
            goToNext: i
        }, d),
        m.imageContainer.appendChild(m.img),
        m.contentContainer.appendChild(m.imageContainer),
        m.overlay.appendChild(m.closeButton),
        m.overlay.appendChild(m.contentContainer),
        document.body.appendChild(m.overlay),
        n(),
        m.overlay.focus(),
        console.log("Zoom overlay displayed:", d ? `gallery with ${t.images.length} images` : "single image")
    }
    ;
    async function U(t, e, r, o) {
        var g;
        const n = window.location.origin + "/index.php"
          , s = new URL(n)
          , i = new URL(t,window.location.origin);
        s.searchParams.set("rest_route", i.pathname);
        for (const [c,m] of i.searchParams.entries())
            s.searchParams.append(c, m);
        const l = s.toString()
          , d = {
            "X-WP-Nonce": window.wpApiSettings.nonce,
            ...(o == null ? void 0 : o.customHeaders) || {}
        };
        !(o != null && o.binaryData) && !((g = o == null ? void 0 : o.customHeaders) != null && g["Content-Type"]) && (d["Content-Type"] = "application/json");
        const u = {
            method: e,
            headers: d,
            credentials: "same-origin"
        };
        o != null && o.binaryData ? u.body = o.binaryData : r && (e === "POST" || e === "PUT") && (u.body = JSON.stringify(r));
        try {
            console.log("Fetching WP API call: ", l, u);
            const c = await fetch(l, u);
            if (!c.ok)
                throw new Error(`HTTP error ${c.status}: ${await c.text()}`);
            const m = await c.text()
              , p = Cf(m);
            if ((p == null ? void 0 : p.success) !== void 0 && !p.success)
                throw new Error(`API errors: ${JSON.stringify(p)}`);
            if (console.log("JSON extracted from WordPress response:", p),
            o != null && o.includeHeaders) {
                const h = {};
                c.headers.forEach( (b, x) => {
                    h[x] = b
                }
                );
                const f = c.headers.get("X-WP-Total")
                  , y = c.headers.get("X-WP-TotalPages");
                return {
                    data: p,
                    headers: h,
                    totalItems: f ? parseInt(f, 10) : void 0,
                    totalPages: y ? parseInt(y, 10) : void 0
                }
            }
            return p
        } catch (c) {
            throw console.error("WordPress API call failed:", c),
            c
        }
    }
    function Cf(t) {
        const e = t.indexOf("{")
          , r = t.indexOf("[");
        let o = -1
          , n = !1;
        if (e === -1 && r === -1)
            return null;
        e === -1 ? (o = r,
        n = !0) : r === -1 ? (o = e,
        n = !1) : r < e ? (o = r,
        n = !0) : (o = e,
        n = !1);
        let s = 0
          , i = -1;
        const l = n ? "[" : "{"
          , d = n ? "]" : "}";
        for (let g = o; g < t.length; g++)
            if (t[g] === l)
                s++;
            else if (t[g] === d && (s--,
            s === 0)) {
                i = g;
                break
            }
        if (i === -1)
            return null;
        const u = t.substring(o, i + 1);
        try {
            return JSON.parse(u)
        } catch (g) {
            return console.error("Failed to parse extracted JSON:", g),
            null
        }
    }
    const je = (t, e) => {
        t.postMessage({
            status: "success",
            payload: e
        })
    }
      , ke = (t, e) => {
        t.postMessage({
            status: "error",
            payload: e
        })
    }
    ;
    let ht = {}
      , Ft = {};
    async function ka() {
        try {
            console.log("[WordPress Server] Fetching post types..."),
            ht = await U("/wp/v2/types", "GET"),
            console.log("[WordPress Server] Post types loaded:", Object.keys(ht))
        } catch (t) {
            console.error("[WordPress Server] Failed to fetch post types:", t),
            ht = {
                post: {
                    name: "Posts",
                    slug: "post",
                    rest_base: "posts",
                    hierarchical: !1,
                    has_archive: !1,
                    taxonomies: []
                },
                page: {
                    name: "Pages",
                    slug: "page",
                    rest_base: "pages",
                    hierarchical: !0,
                    has_archive: !1,
                    taxonomies: []
                }
            }
        }
    }
    async function gr(t, e=!1) {
        let r = ht[t];
        if (r || (console.log(`[WordPress Server] Unknown post type: ${t}. Refreshing post types cache...`),
        await ka(),
        r = ht[t]),
        !r)
            throw new Error(`Unknown post type: ${t}. Available types: ${Object.keys(ht).join(", ")}`);
        return e && !r.metaSchema && (r.metaSchema = await Rc(t)),
        `/wp/v2/${r.rest_base}`
    }
    async function Ia() {
        try {
            console.log("[WordPress Server] Fetching taxonomies..."),
            Ft = await U("/wp/v2/taxonomies", "GET"),
            console.log("[WordPress Server] Taxonomies loaded:", Object.keys(Ft))
        } catch (t) {
            console.error("[WordPress Server] Failed to fetch taxonomies:", t),
            Ft = {
                category: {
                    name: "Categories",
                    slug: "category",
                    description: "",
                    rest_base: "categories",
                    hierarchical: !0,
                    public: !0,
                    show_in_rest: !0,
                    types: ["post"]
                },
                post_tag: {
                    name: "Tags",
                    slug: "post_tag",
                    description: "",
                    rest_base: "tags",
                    hierarchical: !1,
                    public: !0,
                    show_in_rest: !0,
                    types: ["post"]
                }
            }
        }
        return Ft
    }
    async function Ac(t) {
        let e = Ft[t];
        if (e || (console.log(`[WordPress Server] Unknown taxonomy: ${t}. Refreshing taxonomies cache...`),
        await Ia(),
        e = Ft[t]),
        !e)
            throw new Error(`Unknown taxonomy: ${t}. Available taxonomies: ${Object.keys(Ft).join(", ")}`);
        return e.rest_base
    }
    async function Ir(t) {
        return `/wp/v2/${await Ac(t)}`
    }
    async function $f(t) {
        var n, s, i, l, d, u;
        const e = ht[t];
        console.log("[WordPress Server] Fetching meta fields for post type:", t);
        const r = await U(`/wp/v2/${e.rest_base}`, "OPTIONS")
          , o = {
            meta: ((i = (s = (n = r.schema) == null ? void 0 : n.properties) == null ? void 0 : s.meta) == null ? void 0 : i.properties) || {},
            acf: ((u = (d = (l = r.schema) == null ? void 0 : l.properties) == null ? void 0 : d.acf) == null ? void 0 : u.properties) || {}
        };
        return console.log("[WordPress Server] Post type meta fields:", o),
        o
    }
    async function Rc(t) {
        const e = ht[t];
        if (!e)
            throw new Error(`Unknown post type: ${t}. Available types: ${Object.keys(ht).join(", ")}`);
        return e.metaSchema || (e.metaSchema = await $f(t)),
        e.metaSchema
    }
    function Et(t, e) {
        const r = new URL(t,"http://localhost");
        return Object.entries(e).forEach( ([o,n]) => {
            n != null && (Array.isArray(n) ? r.searchParams.set(o, n.join(",")) : r.searchParams.set(o, String(n)))
        }
        ),
        r.pathname + r.search
    }
    const Af = async (t, e, r) => {
        try {
            const o = new CustomEvent(t,r ? {
                detail: r
            } : void 0);
            window.dispatchEvent(o),
            je(e, {
                message: `${t} event dispatched successfully`
            })
        } catch (o) {
            console.error(`Error dispatching ${t} event:`, o),
            ke(e, {
                message: `Error dispatching ${t} event: ${o}`
            })
        }
    }
    ;
    async function Go(t, e) {
        const r = await e("/wp/v2/plugins", "GET");
        if (t.includes("/")) {
            if (r.find(n => n.plugin === t))
                return t;
            throw new Error(`Plugin basename "${t}" not found. Use the "list" action first to get the correct basename from installed plugins.`)
        }
        if (Array.isArray(r)) {
            for (const o of r)
                if (o.plugin && o.plugin.startsWith(`${t}/`) || o.name && o.name.toLowerCase().includes(t.toLowerCase()))
                    return o.plugin
        }
        throw new Error(`Plugin "${t}" not found. Use the "list" action first to get available plugins and their exact basenames.`)
    }
    async function Rf(t, e) {
        if (e.length === 0)
            return {
                valid: [],
                invalid: []
            };
        try {
            const r = Et(await Ir(t), {
                include: e,
                per_page: 100,
                _fields: "id"
            })
              , n = (await U(r, "GET")).map(l => l.id)
              , s = e.filter(l => n.includes(l))
              , i = e.filter(l => !n.includes(l));
            return {
                valid: s,
                invalid: i
            }
        } catch (r) {
            return console.error(`[WordPress Server] Error validating terms for taxonomy ${t}:`, r),
            {
                valid: [],
                invalid: e
            }
        }
    }
    function Of(t, e=!1) {
        const {type: r, status: o, ...n} = t
          , s = {
            ...n
        };
        return e && o !== void 0 && (s.status = o),
        delete s.modified,
        delete s.modified_gmt,
        s
    }
    async function Df() {
        try {
            const t = await U("/wp/v2/plugins/elementor/elementor", "GET");
            if ((t == null ? void 0 : t.status) !== "active")
                throw new Error("Elementor plugin not active. Ask the user if he want to activate it.")
        } catch {
            throw new Error("Elementor plugin is not installed. Ask the user if he want to install and activate it.")
        }
    }
    function Bo() {
        var t, e;
        return ((e = (t = window.wp) == null ? void 0 : t.data) == null ? void 0 : e.select("core/editor")) !== void 0
    }
    function zo() {
        const t = new URLSearchParams(window.location.search);
        for (const [,e] of t.entries())
            if (e.includes("elementor"))
                return !0;
        return !1
    }
    const Hr = () => !!window.ElementorAiConfig
      , Oc = () => {
        if (!window.elementorFrontend || !window.elementorFrontend.elements || !window.elementorFrontend.elements.$body)
            throw new Error("elementorFrontend or its required components not available")
    }
      , Ca = () => !!window.$e.components.get("panel")
      , Nf = () => new Promise(t => {
        if (Ca()) {
            t();
            return
        }
        if (!window.elementor)
            throw new Error("Elementor is not available");
        const e = () => {
            Ca() ? t() : setTimeout(e, 100)
        }
        ;
        window.elementor.on("document:loaded", () => {
            Ca() ? t() : window.elementorFrontend.on("components:init", e)
        }
        )
    }
    )
      , Dc = async ({id: t, settings: e}) => {
        console.log("Updating element settings:", {
            id: t,
            settings: e
        });
        const r = window.elementor.getContainer(t);
        if (!r)
            throw new Error(`Element with ID "${t}" not found.`);
        const o = await window.$e.run("document/elements/settings", {
            container: r,
            settings: e,
            options: {
                external: !0,
                render: !0
            }
        });
        return window.elementorFrontend.elements.$body.resize(),
        o
    }
      , $a = t => {
        const e = window.elementor.getContainer(t);
        if (!e)
            throw new Error(`Element with ID "${t}" not found.`);
        const {settings: r} = e;
        return r
    }
      , Lf = () => {
        if (!Bo())
            throw new Error("WordPress editor API is not available");
        const t = window.wp.data.dispatch("core/block-editor")
          , e = window.wp.data.select("core/block-editor");
        if (!t || !e)
            throw new Error("Block editor API is not available");
        return {
            blockEditorDispatch: t,
            blockEditorSelect: e
        }
    }
      , Uf = (t, e) => {
        const r = t.getBlock(e);
        if (!r)
            throw new Error(`Block with ID "${e}" not found`);
        return r
    }
      , jf = (t, e) => {
        const {blockEditorDispatch: r, blockEditorSelect: o} = Lf()
          , n = Uf(o, t);
        return r.updateBlockAttributes(t, e),
        {
            blockId: t,
            blockName: n.name,
            updatedAttributes: Object.keys(e)
        }
    }
      , Mf = (t, e) => {
        const r = t
          , o = document.createElement("style");
        o.id = r,
        o.appendChild(document.createTextNode(e)),
        Oc(),
        window.elementorFrontend.elements.$body[0].appendChild(o)
    }
      , Ff = t => {
        const e = t;
        Oc();
        const r = window.elementorFrontend.elements.$body[0]
          , o = r.querySelectorAll(`#${CSS.escape(e)}`);
        (o == null ? void 0 : o.length) > 0 && o.forEach(n => {
            r.removeChild(n)
        }
        )
    }
      , Wf = t => !!(t.id && t.id.includes("select-all") || t.name && t.name.includes("select-all"))
      , qf = (t, e="", r="") => {
        var s, i, l;
        let o = e
          , n = r;
        if (t && (!o || !n)) {
            const d = (i = (s = window.elementor) == null ? void 0 : s.getContainer) == null ? void 0 : i.call(s, t);
            if (d) {
                const u = d.settings.get("image");
                if (u && typeof u == "object") {
                    const g = u;
                    o = o || ((l = g.id) == null ? void 0 : l.toString()) || "",
                    n = n || g.url || ""
                }
            }
        }
        return {
            imageId: o,
            imageUrl: n
        }
    }
      , Gf = t => {
        const {blockId: e, imageUrl: r, customDimensions: o} = t
          , n = document.querySelector('iframe[name="editor-canvas"]')
          , i = ((n == null ? void 0 : n.contentDocument) || document).querySelector(`[data-block="${e}"]`);
        if (!i) {
            console.warn("[Gutenberg] Block element not found with any selector for ID:", e);
            return
        }
        const l = i.querySelectorAll("img");
        console.log("[Gutenberg] Found images in block:", l.length),
        l.forEach( (d, u) => {
            const g = d;
            console.log(`[Gutenberg] Processing image ${u + 1}:`, {
                currentSrc: g.src,
                hasOriginalSrc: !!g.dataset.originalSrc
            }),
            g.dataset.originalSrc || (g.dataset.originalSrc = g.src,
            g.dataset.originalStyle = g.style.cssText || ""),
            g.src = r,
            g.classList.add("gutenberg-preview-image"),
            o && (g.style.width = `${o.width}px`,
            g.style.height = `${o.height}px`,
            g.style.objectFit = "unset",
            g.style.maxWidth = "none",
            g.style.maxHeight = "none",
            console.log("[Gutenberg] Applied custom dimensions:", o)),
            console.log(`[Gutenberg] Applied preview to image ${u + 1}`)
        }
        )
    }
      , Bf = t => {
        const e = document.querySelector('iframe[name="editor-canvas"]')
          , o = ((e == null ? void 0 : e.contentDocument) || document).querySelector(`[data-block="${t}"]`);
        if (!o)
            return;
        o.querySelectorAll("img").forEach(s => {
            const i = s;
            i.dataset.originalSrc && (i.src = i.dataset.originalSrc,
            delete i.dataset.originalSrc),
            i.style.cssText = "",
            i.dataset.originalStyle && (i.style.cssText = i.dataset.originalStyle,
            delete i.dataset.originalStyle),
            i.classList.remove("gutenberg-preview-image")
        }
        )
    }
      , Nc = t => Array.isArray(t) ? t.map(e => {
        var r;
        return {
            id: e.id,
            title: ((r = e.title) == null ? void 0 : r.rendered) || e.slug || "Untitled",
            alt_text: e.alt_text || "",
            source_url: e.source_url,
            media_type: e.media_type,
            date: e.date
        }
    }
    ) : t
      , zf = () => `${window.location ? `${window.location.protocol}//${window.location.hostname}` : ""}/wp-content/plugins/elementor/assets/images/placeholder.png`
      , Zf = () => `${window.location ? `${window.location.protocol}//${window.location.hostname}` : ""}/wp-includes/images/media/default.png`
      , Lc = t => a.string().refine(e => {
        try {
            const r = new URL(e)
              , o = t();
            return r.hostname === window.location.hostname || r.href === o
        } catch {
            return !1
        }
    }
    , {
        message: "Image URL must be from internal media library. External URLs not allowed. If no internal media library image is matching the request, use the placeholder image: " + t()
    }).superRefine(async (e, r) => {
        try {
            const o = await fetch(e, {
                method: "HEAD"
            });
            o.ok || r.addIssue({
                code: a.ZodIssueCode.custom,
                message: `Image URL does not exist or is not accessible (HTTP ${o.status}). Please select an existing image from the media library or use the placeholder image: ${t()}`
            })
        } catch (o) {
            r.addIssue({
                code: a.ZodIssueCode.custom,
                message: `Failed to validate image URL accessibility: ${oinstanceof Error ? o.message : "Unknown error"}. Please use the placeholder image: ${t()}`
            })
        }
    }
    ).describe("Image URL - internal media library only, must exist")
      , Zo = {
        context: {}
    }
      , Hf = async (t=!0) => {
        var e, r, o, n;
        if (t && Object.keys(Zo.context).length)
            return Zo.context;
        try {
            return Zo.context = {
                wpUsername: (e = window.angieConfig) == null ? void 0 : e.wpUsername,
                untrusted__wpUserRole: (r = window.angieConfig) == null ? void 0 : r.untrusted__wpUserRole,
                pluginVersion: (o = window.angieConfig) == null ? void 0 : o.version,
                siteKey: (n = window.angieConfig) == null ? void 0 : n.siteKey
            },
            Zo.context
        } catch (s) {
            return console.error(s),
            {
                wpUsername: void 0,
                untrusted__wpUserRole: void 0,
                pluginVersion: void 0,
                siteKey: void 0
            }
        }
    }
      , Vf = async (t, e) => {
        var p, h;
        const {blob: r, filename: o, title: n="Generated Image", alt_text: s="Generated Image"} = e;
        console.log("Uploading image to media library:", {
            filename: o,
            title: n,
            altText: s
        });
        let i = "application/octet-stream";
        const l = (p = o.split(".").pop()) == null ? void 0 : p.toLowerCase();
        l && (["jpg", "jpeg"].includes(l) ? i = "image/jpeg" : l === "png" ? i = "image/png" : l === "gif" ? i = "image/gif" : l === "svg" && (i = "image/svg+xml"));
        const d = r.includes("data:") ? r.split(",")[1] : r
          , u = window.atob(d)
          , g = new Uint8Array(u.length);
        for (let f = 0; f < u.length; f++)
            g[f] = u.charCodeAt(f);
        const c = g.buffer
          , m = {
            "Content-Disposition": `attachment; filename="${o}"`,
            "Content-Type": i
        };
        try {
            const f = await U("/wp/v2/media", "POST", {}, {
                binaryData: c,
                customHeaders: m
            });
            if (!f || !f.id) {
                ke(t, {
                    message: "Failed to upload image to media library"
                });
                return
            }
            const y = f.id
              , b = {
                title: n,
                alt_text: s
            }
              , x = await U(`/wp/v2/media/${y}`, "POST", b);
            console.log("Image uploaded to media library:", {
                mediaId: y,
                url: f.source_url,
                title: ((h = x.title) == null ? void 0 : h.rendered) || x.title,
                alt_text: x.alt_text
            }),
            je(t, {
                message: "Image uploaded to media library successfully",
                payload: {
                    mediaId: y,
                    url: f.source_url
                }
            })
        } catch (f) {
            console.error("Error uploading image to media library:", f),
            ke(t, {
                message: `Error uploading image to media library: ${f}`
            })
        }
    }
    ;
    async function Jf(t) {
        return new Promise( (e, r) => {
            const o = n => {
                window.removeEventListener("elementor:ai:modal-closed", o),
                console.log(" AI Modal closed with result:", n.detail),
                n.detail.success ? e(n.detail) : r({
                    ...n.detail,
                    action: "cancel"
                })
            }
            ;
            window.addEventListener("elementor:ai:modal-closed", o),
            console.log(` Triggering AI modal: ${t.modalType}  ${location}`),
            window.dispatchEvent(new CustomEvent("elementor:ai:show-modal",{
                detail: {
                    ...t,
                    location: t.modalType
                }
            }))
        }
        )
    }
    class Aa {
        constructor(e, r) {
            Ae(this, "sessionId");
            Ae(this, "onmessage");
            Ae(this, "onerror");
            Ae(this, "onclose");
            Ae(this, "_port");
            Ae(this, "_started", !1);
            Ae(this, "_closed", !1);
            if (!e)
                throw new Error("MessagePort is required");
            this._port = e,
            this.sessionId = r || this.generateId(),
            this._port.onmessage = o => {
                var n, s;
                try {
                    const i = Zi.parse(o.data);
                    (n = this.onmessage) == null || n.call(this, i)
                } catch (i) {
                    const l = new Error(`Failed to parse message: ${i}`);
                    (s = this.onerror) == null || s.call(this, l)
                }
            }
            ,
            this._port.onmessageerror = o => {
                var s;
                const n = new Error(`MessagePort error: ${JSON.stringify(o)}`);
                (s = this.onerror) == null || s.call(this, n)
            }
        }
        static generateSessionId() {
            if (typeof crypto < "u" && typeof crypto.randomUUID == "function")
                return crypto.randomUUID();
            const e = Date.now().toString(36)
              , r = Math.random().toString(36).substring(2, 10);
            return `${e}-${r}`
        }
        async start() {
            if (this._started)
                throw new Error("BrowserContextTransport already started! If using Client or Server class, note that connect() calls start() automatically.");
            if (this._closed)
                throw new Error("Cannot start a closed BrowserContextTransport");
            this._started = !0,
            this._port.start()
        }
        async send(e) {
            if (this._closed)
                throw new Error("Cannot send on a closed BrowserContextTransport");
            return new Promise( (r, o) => {
                var n;
                try {
                    this._port.postMessage(e),
                    r()
                } catch (s) {
                    const i = s instanceof Error ? s : new Error(String(s));
                    (n = this.onerror) == null || n.call(this, i),
                    o(i)
                }
            }
            )
        }
        async close() {
            var e;
            this._closed || (this._closed = !0,
            this._port.close(),
            (e = this.onclose) == null || e.call(this))
        }
        generateId() {
            return Aa.generateSessionId()
        }
    }
    var ye;
    (function(t) {
        t.assertEqual = n => {}
        ;
        function e(n) {}
        t.assertIs = e;
        function r(n) {
            throw new Error
        }
        t.assertNever = r,
        t.arrayToEnum = n => {
            const s = {};
            for (const i of n)
                s[i] = i;
            return s
        }
        ,
        t.getValidEnumValues = n => {
            const s = t.objectKeys(n).filter(l => typeof n[n[l]] != "number")
              , i = {};
            for (const l of s)
                i[l] = n[l];
            return t.objectValues(i)
        }
        ,
        t.objectValues = n => t.objectKeys(n).map(function(s) {
            return n[s]
        }),
        t.objectKeys = typeof Object.keys == "function" ? n => Object.keys(n) : n => {
            const s = [];
            for (const i in n)
                Object.prototype.hasOwnProperty.call(n, i) && s.push(i);
            return s
        }
        ,
        t.find = (n, s) => {
            for (const i of n)
                if (s(i))
                    return i
        }
        ,
        t.isInteger = typeof Number.isInteger == "function" ? n => Number.isInteger(n) : n => typeof n == "number" && Number.isFinite(n) && Math.floor(n) === n;
        function o(n, s=" | ") {
            return n.map(i => typeof i == "string" ? `'${i}'` : i).join(s)
        }
        t.joinValues = o,
        t.jsonStringifyReplacer = (n, s) => typeof s == "bigint" ? s.toString() : s
    }
    )(ye || (ye = {}));
    var Uc;
    (function(t) {
        t.mergeShapes = (e, r) => ({
            ...e,
            ...r
        })
    }
    )(Uc || (Uc = {}));
    const H = ye.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"])
      , fr = t => {
        switch (typeof t) {
        case "undefined":
            return H.undefined;
        case "string":
            return H.string;
        case "number":
            return Number.isNaN(t) ? H.nan : H.number;
        case "boolean":
            return H.boolean;
        case "function":
            return H.function;
        case "bigint":
            return H.bigint;
        case "symbol":
            return H.symbol;
        case "object":
            return Array.isArray(t) ? H.array : t === null ? H.null : t.then && typeof t.then == "function" && t.catch && typeof t.catch == "function" ? H.promise : typeof Map < "u" && t instanceof Map ? H.map : typeof Set < "u" && t instanceof Set ? H.set : typeof Date < "u" && t instanceof Date ? H.date : H.object;
        default:
            return H.unknown
        }
    }
      , W = ye.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of", "not_finite"]);
    class Xt extends Error {
        get errors() {
            return this.issues
        }
        constructor(e) {
            super(),
            this.issues = [],
            this.addIssue = o => {
                this.issues = [...this.issues, o]
            }
            ,
            this.addIssues = (o=[]) => {
                this.issues = [...this.issues, ...o]
            }
            ;
            const r = new.target.prototype;
            Object.setPrototypeOf ? Object.setPrototypeOf(this, r) : this.__proto__ = r,
            this.name = "ZodError",
            this.issues = e
        }
        format(e) {
            const r = e || function(s) {
                return s.message
            }
              , o = {
                _errors: []
            }
              , n = s => {
                for (const i of s.issues)
                    if (i.code === "invalid_union")
                        i.unionErrors.map(n);
                    else if (i.code === "invalid_return_type")
                        n(i.returnTypeError);
                    else if (i.code === "invalid_arguments")
                        n(i.argumentsError);
                    else if (i.path.length === 0)
                        o._errors.push(r(i));
                    else {
                        let l = o
                          , d = 0;
                        for (; d < i.path.length; ) {
                            const u = i.path[d];
                            d === i.path.length - 1 ? (l[u] = l[u] || {
                                _errors: []
                            },
                            l[u]._errors.push(r(i))) : l[u] = l[u] || {
                                _errors: []
                            },
                            l = l[u],
                            d++
                        }
                    }
            }
            ;
            return n(this),
            o
        }
        static assert(e) {
            if (!(e instanceof Xt))
                throw new Error(`Not a ZodError: ${e}`)
        }
        toString() {
            return this.message
        }
        get message() {
            return JSON.stringify(this.issues, ye.jsonStringifyReplacer, 2)
        }
        get isEmpty() {
            return this.issues.length === 0
        }
        flatten(e=r => r.message) {
            const r = {}
              , o = [];
            for (const n of this.issues)
                if (n.path.length > 0) {
                    const s = n.path[0];
                    r[s] = r[s] || [],
                    r[s].push(e(n))
                } else
                    o.push(e(n));
            return {
                formErrors: o,
                fieldErrors: r
            }
        }
        get formErrors() {
            return this.flatten()
        }
    }
    Xt.create = t => new Xt(t);
    const Ra = (t, e) => {
        let r;
        switch (t.code) {
        case W.invalid_type:
            t.received === H.undefined ? r = "Required" : r = `Expected ${t.expected}, received ${t.received}`;
            break;
        case W.invalid_literal:
            r = `Invalid literal value, expected ${JSON.stringify(t.expected, ye.jsonStringifyReplacer)}`;
            break;
        case W.unrecognized_keys:
            r = `Unrecognized key(s) in object: ${ye.joinValues(t.keys, ", ")}`;
            break;
        case W.invalid_union:
            r = "Invalid input";
            break;
        case W.invalid_union_discriminator:
            r = `Invalid discriminator value. Expected ${ye.joinValues(t.options)}`;
            break;
        case W.invalid_enum_value:
            r = `Invalid enum value. Expected ${ye.joinValues(t.options)}, received '${t.received}'`;
            break;
        case W.invalid_arguments:
            r = "Invalid function arguments";
            break;
        case W.invalid_return_type:
            r = "Invalid function return type";
            break;
        case W.invalid_date:
            r = "Invalid date";
            break;
        case W.invalid_string:
            typeof t.validation == "object" ? "includes"in t.validation ? (r = `Invalid input: must include "${t.validation.includes}"`,
            typeof t.validation.position == "number" && (r = `${r} at one or more positions greater than or equal to ${t.validation.position}`)) : "startsWith"in t.validation ? r = `Invalid input: must start with "${t.validation.startsWith}"` : "endsWith"in t.validation ? r = `Invalid input: must end with "${t.validation.endsWith}"` : ye.assertNever(t.validation) : t.validation !== "regex" ? r = `Invalid ${t.validation}` : r = "Invalid";
            break;
        case W.too_small:
            t.type === "array" ? r = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "more than"} ${t.minimum} element(s)` : t.type === "string" ? r = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "over"} ${t.minimum} character(s)` : t.type === "number" ? r = `Number must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${t.minimum}` : t.type === "bigint" ? r = `Number must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${t.minimum}` : t.type === "date" ? r = `Date must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(t.minimum))}` : r = "Invalid input";
            break;
        case W.too_big:
            t.type === "array" ? r = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "less than"} ${t.maximum} element(s)` : t.type === "string" ? r = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "under"} ${t.maximum} character(s)` : t.type === "number" ? r = `Number must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "bigint" ? r = `BigInt must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "date" ? r = `Date must be ${t.exact ? "exactly" : t.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(t.maximum))}` : r = "Invalid input";
            break;
        case W.custom:
            r = "Invalid input";
            break;
        case W.invalid_intersection_types:
            r = "Intersection results could not be merged";
            break;
        case W.not_multiple_of:
            r = `Number must be a multiple of ${t.multipleOf}`;
            break;
        case W.not_finite:
            r = "Number must be finite";
            break;
        default:
            r = e.defaultError,
            ye.assertNever(t)
        }
        return {
            message: r
        }
    }
    ;
    let Yf = Ra;
    function Kf() {
        return Yf
    }
    const Qf = t => {
        const {data: e, path: r, errorMaps: o, issueData: n} = t
          , s = [...r, ...n.path || []]
          , i = {
            ...n,
            path: s
        };
        if (n.message !== void 0)
            return {
                ...n,
                path: s,
                message: n.message
            };
        let l = "";
        const d = o.filter(u => !!u).slice().reverse();
        for (const u of d)
            l = u(i, {
                data: e,
                defaultError: l
            }).message;
        return {
            ...n,
            path: s,
            message: l
        }
    }
    ;
    function z(t, e) {
        const r = Kf()
          , o = Qf({
            issueData: e,
            data: t.data,
            path: t.path,
            errorMaps: [t.common.contextualErrorMap, t.schemaErrorMap, r, r === Ra ? void 0 : Ra].filter(n => !!n)
        });
        t.common.issues.push(o)
    }
    class ct {
        constructor() {
            this.value = "valid"
        }
        dirty() {
            this.value === "valid" && (this.value = "dirty")
        }
        abort() {
            this.value !== "aborted" && (this.value = "aborted")
        }
        static mergeArray(e, r) {
            const o = [];
            for (const n of r) {
                if (n.status === "aborted")
                    return se;
                n.status === "dirty" && e.dirty(),
                o.push(n.value)
            }
            return {
                status: e.value,
                value: o
            }
        }
        static async mergeObjectAsync(e, r) {
            const o = [];
            for (const n of r) {
                const s = await n.key
                  , i = await n.value;
                o.push({
                    key: s,
                    value: i
                })
            }
            return ct.mergeObjectSync(e, o)
        }
        static mergeObjectSync(e, r) {
            const o = {};
            for (const n of r) {
                const {key: s, value: i} = n;
                if (s.status === "aborted" || i.status === "aborted")
                    return se;
                s.status === "dirty" && e.dirty(),
                i.status === "dirty" && e.dirty(),
                s.value !== "__proto__" && (typeof i.value < "u" || n.alwaysSet) && (o[s.value] = i.value)
            }
            return {
                status: e.value,
                value: o
            }
        }
    }
    const se = Object.freeze({
        status: "aborted"
    })
      , Dn = t => ({
        status: "dirty",
        value: t
    })
      , xt = t => ({
        status: "valid",
        value: t
    })
      , jc = t => t.status === "aborted"
      , Mc = t => t.status === "dirty"
      , Vr = t => t.status === "valid"
      , Ho = t => typeof Promise < "u" && t instanceof Promise;
    var Y;
    (function(t) {
        t.errToObj = e => typeof e == "string" ? {
            message: e
        } : e || {},
        t.toString = e => typeof e == "string" ? e : e == null ? void 0 : e.message
    }
    )(Y || (Y = {}));
    class Wt {
        constructor(e, r, o, n) {
            this._cachedPath = [],
            this.parent = e,
            this.data = r,
            this._path = o,
            this._key = n
        }
        get path() {
            return this._cachedPath.length || (Array.isArray(this._key) ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)),
            this._cachedPath
        }
    }
    const Fc = (t, e) => {
        if (Vr(e))
            return {
                success: !0,
                data: e.value
            };
        if (!t.common.issues.length)
            throw new Error("Validation failed but no issues detected.");
        return {
            success: !1,
            get error() {
                if (this._error)
                    return this._error;
                const r = new Xt(t.common.issues);
                return this._error = r,
                this._error
            }
        }
    }
    ;
    function me(t) {
        if (!t)
            return {};
        const {errorMap: e, invalid_type_error: r, required_error: o, description: n} = t;
        if (e && (r || o))
            throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
        return e ? {
            errorMap: e,
            description: n
        } : {
            errorMap: (i, l) => {
                const {message: d} = t;
                return i.code === "invalid_enum_value" ? {
                    message: d ?? l.defaultError
                } : typeof l.data > "u" ? {
                    message: d ?? o ?? l.defaultError
                } : i.code !== "invalid_type" ? {
                    message: l.defaultError
                } : {
                    message: d ?? r ?? l.defaultError
                }
            }
            ,
            description: n
        }
    }
    class pe {
        get description() {
            return this._def.description
        }
        _getType(e) {
            return fr(e.data)
        }
        _getOrReturnCtx(e, r) {
            return r || {
                common: e.parent.common,
                data: e.data,
                parsedType: fr(e.data),
                schemaErrorMap: this._def.errorMap,
                path: e.path,
                parent: e.parent
            }
        }
        _processInputParams(e) {
            return {
                status: new ct,
                ctx: {
                    common: e.parent.common,
                    data: e.data,
                    parsedType: fr(e.data),
                    schemaErrorMap: this._def.errorMap,
                    path: e.path,
                    parent: e.parent
                }
            }
        }
        _parseSync(e) {
            const r = this._parse(e);
            if (Ho(r))
                throw new Error("Synchronous parse encountered promise.");
            return r
        }
        _parseAsync(e) {
            const r = this._parse(e);
            return Promise.resolve(r)
        }
        parse(e, r) {
            const o = this.safeParse(e, r);
            if (o.success)
                return o.data;
            throw o.error
        }
        safeParse(e, r) {
            const o = {
                common: {
                    issues: [],
                    async: (r == null ? void 0 : r.async) ?? !1,
                    contextualErrorMap: r == null ? void 0 : r.errorMap
                },
                path: (r == null ? void 0 : r.path) || [],
                schemaErrorMap: this._def.errorMap,
                parent: null,
                data: e,
                parsedType: fr(e)
            }
              , n = this._parseSync({
                data: e,
                path: o.path,
                parent: o
            });
            return Fc(o, n)
        }
        "~validate"(e) {
            var o, n;
            const r = {
                common: {
                    issues: [],
                    async: !!this["~standard"].async
                },
                path: [],
                schemaErrorMap: this._def.errorMap,
                parent: null,
                data: e,
                parsedType: fr(e)
            };
            if (!this["~standard"].async)
                try {
                    const s = this._parseSync({
                        data: e,
                        path: [],
                        parent: r
                    });
                    return Vr(s) ? {
                        value: s.value
                    } : {
                        issues: r.common.issues
                    }
                } catch (s) {
                    (n = (o = s == null ? void 0 : s.message) == null ? void 0 : o.toLowerCase()) != null && n.includes("encountered") && (this["~standard"].async = !0),
                    r.common = {
                        issues: [],
                        async: !0
                    }
                }
            return this._parseAsync({
                data: e,
                path: [],
                parent: r
            }).then(s => Vr(s) ? {
                value: s.value
            } : {
                issues: r.common.issues
            })
        }
        async parseAsync(e, r) {
            const o = await this.safeParseAsync(e, r);
            if (o.success)
                return o.data;
            throw o.error
        }
        async safeParseAsync(e, r) {
            const o = {
                common: {
                    issues: [],
                    contextualErrorMap: r == null ? void 0 : r.errorMap,
                    async: !0
                },
                path: (r == null ? void 0 : r.path) || [],
                schemaErrorMap: this._def.errorMap,
                parent: null,
                data: e,
                parsedType: fr(e)
            }
              , n = this._parse({
                data: e,
                path: o.path,
                parent: o
            })
              , s = await (Ho(n) ? n : Promise.resolve(n));
            return Fc(o, s)
        }
        refine(e, r) {
            const o = n => typeof r == "string" || typeof r > "u" ? {
                message: r
            } : typeof r == "function" ? r(n) : r;
            return this._refinement( (n, s) => {
                const i = e(n)
                  , l = () => s.addIssue({
                    code: W.custom,
                    ...o(n)
                });
                return typeof Promise < "u" && i instanceof Promise ? i.then(d => d ? !0 : (l(),
                !1)) : i ? !0 : (l(),
                !1)
            }
            )
        }
        refinement(e, r) {
            return this._refinement( (o, n) => e(o) ? !0 : (n.addIssue(typeof r == "function" ? r(o, n) : r),
            !1))
        }
        _refinement(e) {
            return new rr({
                schema: this,
                typeName: ae.ZodEffects,
                effect: {
                    type: "refinement",
                    refinement: e
                }
            })
        }
        superRefine(e) {
            return this._refinement(e)
        }
        constructor(e) {
            this.spa = this.safeParseAsync,
            this._def = e,
            this.parse = this.parse.bind(this),
            this.safeParse = this.safeParse.bind(this),
            this.parseAsync = this.parseAsync.bind(this),
            this.safeParseAsync = this.safeParseAsync.bind(this),
            this.spa = this.spa.bind(this),
            this.refine = this.refine.bind(this),
            this.refinement = this.refinement.bind(this),
            this.superRefine = this.superRefine.bind(this),
            this.optional = this.optional.bind(this),
            this.nullable = this.nullable.bind(this),
            this.nullish = this.nullish.bind(this),
            this.array = this.array.bind(this),
            this.promise = this.promise.bind(this),
            this.or = this.or.bind(this),
            this.and = this.and.bind(this),
            this.transform = this.transform.bind(this),
            this.brand = this.brand.bind(this),
            this.default = this.default.bind(this),
            this.catch = this.catch.bind(this),
            this.describe = this.describe.bind(this),
            this.pipe = this.pipe.bind(this),
            this.readonly = this.readonly.bind(this),
            this.isNullable = this.isNullable.bind(this),
            this.isOptional = this.isOptional.bind(this),
            this["~standard"] = {
                version: 1,
                vendor: "zod",
                validate: r => this["~validate"](r)
            }
        }
        optional() {
            return nr.create(this, this._def)
        }
        nullable() {
            return Ar.create(this, this._def)
        }
        nullish() {
            return this.nullable().optional()
        }
        array() {
            return qt.create(this)
        }
        promise() {
            return rs.create(this, this._def)
        }
        or(e) {
            return Yo.create([this, e], this._def)
        }
        and(e) {
            return Ko.create(this, e, this._def)
        }
        transform(e) {
            return new rr({
                ...me(this._def),
                schema: this,
                typeName: ae.ZodEffects,
                effect: {
                    type: "transform",
                    transform: e
                }
            })
        }
        default(e) {
            const r = typeof e == "function" ? e : () => e;
            return new ns({
                ...me(this._def),
                innerType: this,
                defaultValue: r,
                typeName: ae.ZodDefault
            })
        }
        brand() {
            return new Bc({
                typeName: ae.ZodBranded,
                type: this,
                ...me(this._def)
            })
        }
        catch(e) {
            const r = typeof e == "function" ? e : () => e;
            return new os({
                ...me(this._def),
                innerType: this,
                catchValue: r,
                typeName: ae.ZodCatch
            })
        }
        describe(e) {
            const r = this.constructor;
            return new r({
                ...this._def,
                description: e
            })
        }
        pipe(e) {
            return Ga.create(this, e)
        }
        readonly() {
            return ss.create(this)
        }
        isOptional() {
            return this.safeParse(void 0).success
        }
        isNullable() {
            return this.safeParse(null).success
        }
    }
    const Xf = /^c[^\s-]{8,}$/i
      , ey = /^[0-9a-z]+$/
      , ty = /^[0-9A-HJKMNP-TV-Z]{26}$/i
      , ry = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i
      , ny = /^[a-z0-9_-]{21}$/i
      , oy = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
      , sy = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/
      , ay = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i
      , iy = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
    let Oa;
    const ly = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/
      , cy = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/
      , dy = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/
      , uy = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/
      , my = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/
      , py = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/
      , Wc = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))"
      , hy = new RegExp(`^${Wc}$`);
    function qc(t) {
        let e = "[0-5]\\d";
        t.precision ? e = `${e}\\.\\d{${t.precision}}` : t.precision == null && (e = `${e}(\\.\\d+)?`);
        const r = t.precision ? "+" : "?";
        return `([01]\\d|2[0-3]):[0-5]\\d(:${e})${r}`
    }
    function gy(t) {
        return new RegExp(`^${qc(t)}$`)
    }
    function fy(t) {
        let e = `${Wc}T${qc(t)}`;
        const r = [];
        return r.push(t.local ? "Z?" : "Z"),
        t.offset && r.push("([+-]\\d{2}:?\\d{2})"),
        e = `${e}(${r.join("|")})`,
        new RegExp(`^${e}$`)
    }
    function yy(t, e) {
        return !!((e === "v4" || !e) && ly.test(t) || (e === "v6" || !e) && dy.test(t))
    }
    function vy(t, e) {
        if (!oy.test(t))
            return !1;
        try {
            const [r] = t.split(".");
            if (!r)
                return !1;
            const o = r.replace(/-/g, "+").replace(/_/g, "/").padEnd(r.length + (4 - r.length % 4) % 4, "=")
              , n = JSON.parse(atob(o));
            return !(typeof n != "object" || n === null || "typ"in n && (n == null ? void 0 : n.typ) !== "JWT" || !n.alg || e && n.alg !== e)
        } catch {
            return !1
        }
    }
    function wy(t, e) {
        return !!((e === "v4" || !e) && cy.test(t) || (e === "v6" || !e) && uy.test(t))
    }
    class er extends pe {
        _parse(e) {
            if (this._def.coerce && (e.data = String(e.data)),
            this._getType(e) !== H.string) {
                const s = this._getOrReturnCtx(e);
                return z(s, {
                    code: W.invalid_type,
                    expected: H.string,
                    received: s.parsedType
                }),
                se
            }
            const o = new ct;
            let n;
            for (const s of this._def.checks)
                if (s.kind === "min")
                    e.data.length < s.value && (n = this._getOrReturnCtx(e, n),
                    z(n, {
                        code: W.too_small,
                        minimum: s.value,
                        type: "string",
                        inclusive: !0,
                        exact: !1,
                        message: s.message
                    }),
                    o.dirty());
                else if (s.kind === "max")
                    e.data.length > s.value && (n = this._getOrReturnCtx(e, n),
                    z(n, {
                        code: W.too_big,
                        maximum: s.value,
                        type: "string",
                        inclusive: !0,
                        exact: !1,
                        message: s.message
                    }),
                    o.dirty());
                else if (s.kind === "length") {
                    const i = e.data.length > s.value
                      , l = e.data.length < s.value;
                    (i || l) && (n = this._getOrReturnCtx(e, n),
                    i ? z(n, {
                        code: W.too_big,
                        maximum: s.value,
                        type: "string",
                        inclusive: !0,
                        exact: !0,
                        message: s.message
                    }) : l && z(n, {
                        code: W.too_small,
                        minimum: s.value,
                        type: "string",
                        inclusive: !0,
                        exact: !0,
                        message: s.message
                    }),
                    o.dirty())
                } else if (s.kind === "email")
                    ay.test(e.data) || (n = this._getOrReturnCtx(e, n),
                    z(n, {
                        validation: "email",
                        code: W.invalid_string,
                        message: s.message
                    }),
                    o.dirty());
                else if (s.kind === "emoji")
                    Oa || (Oa = new RegExp(iy,"u")),
                    Oa.test(e.data) || (n = this._getOrReturnCtx(e, n),
                    z(n, {
                        validation: "emoji",
                        code: W.invalid_string,
                        message: s.message
                    }),
                    o.dirty());
                else if (s.kind === "uuid")
                    ry.test(e.data) || (n = this._getOrReturnCtx(e, n),
                    z(n, {
                        validation: "uuid",
                        code: W.invalid_string,
                        message: s.message
                    }),
                    o.dirty());
                else if (s.kind === "nanoid")
                    ny.test(e.data) || (n = this._getOrReturnCtx(e, n),
                    z(n, {
                        validation: "nanoid",
                        code: W.invalid_string,
                        message: s.message
                    }),
                    o.dirty());
                else if (s.kind === "cuid")
                    Xf.test(e.data) || (n = this._getOrReturnCtx(e, n),
                    z(n, {
                        validation: "cuid",
                        code: W.invalid_string,
                        message: s.message
                    }),
                    o.dirty());
                else if (s.kind === "cuid2")
                    ey.test(e.data) || (n = this._getOrReturnCtx(e, n),
                    z(n, {
                        validation: "cuid2",
                        code: W.invalid_string,
                        message: s.message
                    }),
                    o.dirty());
                else if (s.kind === "ulid")
                    ty.test(e.data) || (n = this._getOrReturnCtx(e, n),
                    z(n, {
                        validation: "ulid",
                        code: W.invalid_string,
                        message: s.message
                    }),
                    o.dirty());
                else if (s.kind === "url")
                    try {
                        new URL(e.data)
                    } catch {
                        n = this._getOrReturnCtx(e, n),
                        z(n, {
                            validation: "url",
                            code: W.invalid_string,
                            message: s.message
                        }),
                        o.dirty()
                    }
                else
                    s.kind === "regex" ? (s.regex.lastIndex = 0,
                    s.regex.test(e.data) || (n = this._getOrReturnCtx(e, n),
                    z(n, {
                        validation: "regex",
                        code: W.invalid_string,
                        message: s.message
                    }),
                    o.dirty())) : s.kind === "trim" ? e.data = e.data.trim() : s.kind === "includes" ? e.data.includes(s.value, s.position) || (n = this._getOrReturnCtx(e, n),
                    z(n, {
                        code: W.invalid_string,
                        validation: {
                            includes: s.value,
                            position: s.position
                        },
                        message: s.message
                    }),
                    o.dirty()) : s.kind === "toLowerCase" ? e.data = e.data.toLowerCase() : s.kind === "toUpperCase" ? e.data = e.data.toUpperCase() : s.kind === "startsWith" ? e.data.startsWith(s.value) || (n = this._getOrReturnCtx(e, n),
                    z(n, {
                        code: W.invalid_string,
                        validation: {
                            startsWith: s.value
                        },
                        message: s.message
                    }),
                    o.dirty()) : s.kind === "endsWith" ? e.data.endsWith(s.value) || (n = this._getOrReturnCtx(e, n),
                    z(n, {
                        code: W.invalid_string,
                        validation: {
                            endsWith: s.value
                        },
                        message: s.message
                    }),
                    o.dirty()) : s.kind === "datetime" ? fy(s).test(e.data) || (n = this._getOrReturnCtx(e, n),
                    z(n, {
                        code: W.invalid_string,
                        validation: "datetime",
                        message: s.message
                    }),
                    o.dirty()) : s.kind === "date" ? hy.test(e.data) || (n = this._getOrReturnCtx(e, n),
                    z(n, {
                        code: W.invalid_string,
                        validation: "date",
                        message: s.message
                    }),
                    o.dirty()) : s.kind === "time" ? gy(s).test(e.data) || (n = this._getOrReturnCtx(e, n),
                    z(n, {
                        code: W.invalid_string,
                        validation: "time",
                        message: s.message
                    }),
                    o.dirty()) : s.kind === "duration" ? sy.test(e.data) || (n = this._getOrReturnCtx(e, n),
                    z(n, {
                        validation: "duration",
                        code: W.invalid_string,
                        message: s.message
                    }),
                    o.dirty()) : s.kind === "ip" ? yy(e.data, s.version) || (n = this._getOrReturnCtx(e, n),
                    z(n, {
                        validation: "ip",
                        code: W.invalid_string,
                        message: s.message
                    }),
                    o.dirty()) : s.kind === "jwt" ? vy(e.data, s.alg) || (n = this._getOrReturnCtx(e, n),
                    z(n, {
                        validation: "jwt",
                        code: W.invalid_string,
                        message: s.message
                    }),
                    o.dirty()) : s.kind === "cidr" ? wy(e.data, s.version) || (n = this._getOrReturnCtx(e, n),
                    z(n, {
                        validation: "cidr",
                        code: W.invalid_string,
                        message: s.message
                    }),
                    o.dirty()) : s.kind === "base64" ? my.test(e.data) || (n = this._getOrReturnCtx(e, n),
                    z(n, {
                        validation: "base64",
                        code: W.invalid_string,
                        message: s.message
                    }),
                    o.dirty()) : s.kind === "base64url" ? py.test(e.data) || (n = this._getOrReturnCtx(e, n),
                    z(n, {
                        validation: "base64url",
                        code: W.invalid_string,
                        message: s.message
                    }),
                    o.dirty()) : ye.assertNever(s);
            return {
                status: o.value,
                value: e.data
            }
        }
        _regex(e, r, o) {
            return this.refinement(n => e.test(n), {
                validation: r,
                code: W.invalid_string,
                ...Y.errToObj(o)
            })
        }
        _addCheck(e) {
            return new er({
                ...this._def,
                checks: [...this._def.checks, e]
            })
        }
        email(e) {
            return this._addCheck({
                kind: "email",
                ...Y.errToObj(e)
            })
        }
        url(e) {
            return this._addCheck({
                kind: "url",
                ...Y.errToObj(e)
            })
        }
        emoji(e) {
            return this._addCheck({
                kind: "emoji",
                ...Y.errToObj(e)
            })
        }
        uuid(e) {
            return this._addCheck({
                kind: "uuid",
                ...Y.errToObj(e)
            })
        }
        nanoid(e) {
            return this._addCheck({
                kind: "nanoid",
                ...Y.errToObj(e)
            })
        }
        cuid(e) {
            return this._addCheck({
                kind: "cuid",
                ...Y.errToObj(e)
            })
        }
        cuid2(e) {
            return this._addCheck({
                kind: "cuid2",
                ...Y.errToObj(e)
            })
        }
        ulid(e) {
            return this._addCheck({
                kind: "ulid",
                ...Y.errToObj(e)
            })
        }
        base64(e) {
            return this._addCheck({
                kind: "base64",
                ...Y.errToObj(e)
            })
        }
        base64url(e) {
            return this._addCheck({
                kind: "base64url",
                ...Y.errToObj(e)
            })
        }
        jwt(e) {
            return this._addCheck({
                kind: "jwt",
                ...Y.errToObj(e)
            })
        }
        ip(e) {
            return this._addCheck({
                kind: "ip",
                ...Y.errToObj(e)
            })
        }
        cidr(e) {
            return this._addCheck({
                kind: "cidr",
                ...Y.errToObj(e)
            })
        }
        datetime(e) {
            return typeof e == "string" ? this._addCheck({
                kind: "datetime",
                precision: null,
                offset: !1,
                local: !1,
                message: e
            }) : this._addCheck({
                kind: "datetime",
                precision: typeof (e == null ? void 0 : e.precision) > "u" ? null : e == null ? void 0 : e.precision,
                offset: (e == null ? void 0 : e.offset) ?? !1,
                local: (e == null ? void 0 : e.local) ?? !1,
                ...Y.errToObj(e == null ? void 0 : e.message)
            })
        }
        date(e) {
            return this._addCheck({
                kind: "date",
                message: e
            })
        }
        time(e) {
            return typeof e == "string" ? this._addCheck({
                kind: "time",
                precision: null,
                message: e
            }) : this._addCheck({
                kind: "time",
                precision: typeof (e == null ? void 0 : e.precision) > "u" ? null : e == null ? void 0 : e.precision,
                ...Y.errToObj(e == null ? void 0 : e.message)
            })
        }
        duration(e) {
            return this._addCheck({
                kind: "duration",
                ...Y.errToObj(e)
            })
        }
        regex(e, r) {
            return this._addCheck({
                kind: "regex",
                regex: e,
                ...Y.errToObj(r)
            })
        }
        includes(e, r) {
            return this._addCheck({
                kind: "includes",
                value: e,
                position: r == null ? void 0 : r.position,
                ...Y.errToObj(r == null ? void 0 : r.message)
            })
        }
        startsWith(e, r) {
            return this._addCheck({
                kind: "startsWith",
                value: e,
                ...Y.errToObj(r)
            })
        }
        endsWith(e, r) {
            return this._addCheck({
                kind: "endsWith",
                value: e,
                ...Y.errToObj(r)
            })
        }
        min(e, r) {
            return this._addCheck({
                kind: "min",
                value: e,
                ...Y.errToObj(r)
            })
        }
        max(e, r) {
            return this._addCheck({
                kind: "max",
                value: e,
                ...Y.errToObj(r)
            })
        }
        length(e, r) {
            return this._addCheck({
                kind: "length",
                value: e,
                ...Y.errToObj(r)
            })
        }
        nonempty(e) {
            return this.min(1, Y.errToObj(e))
        }
        trim() {
            return new er({
                ...this._def,
                checks: [...this._def.checks, {
                    kind: "trim"
                }]
            })
        }
        toLowerCase() {
            return new er({
                ...this._def,
                checks: [...this._def.checks, {
                    kind: "toLowerCase"
                }]
            })
        }
        toUpperCase() {
            return new er({
                ...this._def,
                checks: [...this._def.checks, {
                    kind: "toUpperCase"
                }]
            })
        }
        get isDatetime() {
            return !!this._def.checks.find(e => e.kind === "datetime")
        }
        get isDate() {
            return !!this._def.checks.find(e => e.kind === "date")
        }
        get isTime() {
            return !!this._def.checks.find(e => e.kind === "time")
        }
        get isDuration() {
            return !!this._def.checks.find(e => e.kind === "duration")
        }
        get isEmail() {
            return !!this._def.checks.find(e => e.kind === "email")
        }
        get isURL() {
            return !!this._def.checks.find(e => e.kind === "url")
        }
        get isEmoji() {
            return !!this._def.checks.find(e => e.kind === "emoji")
        }
        get isUUID() {
            return !!this._def.checks.find(e => e.kind === "uuid")
        }
        get isNANOID() {
            return !!this._def.checks.find(e => e.kind === "nanoid")
        }
        get isCUID() {
            return !!this._def.checks.find(e => e.kind === "cuid")
        }
        get isCUID2() {
            return !!this._def.checks.find(e => e.kind === "cuid2")
        }
        get isULID() {
            return !!this._def.checks.find(e => e.kind === "ulid")
        }
        get isIP() {
            return !!this._def.checks.find(e => e.kind === "ip")
        }
        get isCIDR() {
            return !!this._def.checks.find(e => e.kind === "cidr")
        }
        get isBase64() {
            return !!this._def.checks.find(e => e.kind === "base64")
        }
        get isBase64url() {
            return !!this._def.checks.find(e => e.kind === "base64url")
        }
        get minLength() {
            let e = null;
            for (const r of this._def.checks)
                r.kind === "min" && (e === null || r.value > e) && (e = r.value);
            return e
        }
        get maxLength() {
            let e = null;
            for (const r of this._def.checks)
                r.kind === "max" && (e === null || r.value < e) && (e = r.value);
            return e
        }
    }
    er.create = t => new er({
        checks: [],
        typeName: ae.ZodString,
        coerce: (t == null ? void 0 : t.coerce) ?? !1,
        ...me(t)
    });
    function by(t, e) {
        const r = (t.toString().split(".")[1] || "").length
          , o = (e.toString().split(".")[1] || "").length
          , n = r > o ? r : o
          , s = Number.parseInt(t.toFixed(n).replace(".", ""))
          , i = Number.parseInt(e.toFixed(n).replace(".", ""));
        return s % i / 10 ** n
    }
    class Jr extends pe {
        constructor() {
            super(...arguments),
            this.min = this.gte,
            this.max = this.lte,
            this.step = this.multipleOf
        }
        _parse(e) {
            if (this._def.coerce && (e.data = Number(e.data)),
            this._getType(e) !== H.number) {
                const s = this._getOrReturnCtx(e);
                return z(s, {
                    code: W.invalid_type,
                    expected: H.number,
                    received: s.parsedType
                }),
                se
            }
            let o;
            const n = new ct;
            for (const s of this._def.checks)
                s.kind === "int" ? ye.isInteger(e.data) || (o = this._getOrReturnCtx(e, o),
                z(o, {
                    code: W.invalid_type,
                    expected: "integer",
                    received: "float",
                    message: s.message
                }),
                n.dirty()) : s.kind === "min" ? (s.inclusive ? e.data < s.value : e.data <= s.value) && (o = this._getOrReturnCtx(e, o),
                z(o, {
                    code: W.too_small,
                    minimum: s.value,
                    type: "number",
                    inclusive: s.inclusive,
                    exact: !1,
                    message: s.message
                }),
                n.dirty()) : s.kind === "max" ? (s.inclusive ? e.data > s.value : e.data >= s.value) && (o = this._getOrReturnCtx(e, o),
                z(o, {
                    code: W.too_big,
                    maximum: s.value,
                    type: "number",
                    inclusive: s.inclusive,
                    exact: !1,
                    message: s.message
                }),
                n.dirty()) : s.kind === "multipleOf" ? by(e.data, s.value) !== 0 && (o = this._getOrReturnCtx(e, o),
                z(o, {
                    code: W.not_multiple_of,
                    multipleOf: s.value,
                    message: s.message
                }),
                n.dirty()) : s.kind === "finite" ? Number.isFinite(e.data) || (o = this._getOrReturnCtx(e, o),
                z(o, {
                    code: W.not_finite,
                    message: s.message
                }),
                n.dirty()) : ye.assertNever(s);
            return {
                status: n.value,
                value: e.data
            }
        }
        gte(e, r) {
            return this.setLimit("min", e, !0, Y.toString(r))
        }
        gt(e, r) {
            return this.setLimit("min", e, !1, Y.toString(r))
        }
        lte(e, r) {
            return this.setLimit("max", e, !0, Y.toString(r))
        }
        lt(e, r) {
            return this.setLimit("max", e, !1, Y.toString(r))
        }
        setLimit(e, r, o, n) {
            return new Jr({
                ...this._def,
                checks: [...this._def.checks, {
                    kind: e,
                    value: r,
                    inclusive: o,
                    message: Y.toString(n)
                }]
            })
        }
        _addCheck(e) {
            return new Jr({
                ...this._def,
                checks: [...this._def.checks, e]
            })
        }
        int(e) {
            return this._addCheck({
                kind: "int",
                message: Y.toString(e)
            })
        }
        positive(e) {
            return this._addCheck({
                kind: "min",
                value: 0,
                inclusive: !1,
                message: Y.toString(e)
            })
        }
        negative(e) {
            return this._addCheck({
                kind: "max",
                value: 0,
                inclusive: !1,
                message: Y.toString(e)
            })
        }
        nonpositive(e) {
            return this._addCheck({
                kind: "max",
                value: 0,
                inclusive: !0,
                message: Y.toString(e)
            })
        }
        nonnegative(e) {
            return this._addCheck({
                kind: "min",
                value: 0,
                inclusive: !0,
                message: Y.toString(e)
            })
        }
        multipleOf(e, r) {
            return this._addCheck({
                kind: "multipleOf",
                value: e,
                message: Y.toString(r)
            })
        }
        finite(e) {
            return this._addCheck({
                kind: "finite",
                message: Y.toString(e)
            })
        }
        safe(e) {
            return this._addCheck({
                kind: "min",
                inclusive: !0,
                value: Number.MIN_SAFE_INTEGER,
                message: Y.toString(e)
            })._addCheck({
                kind: "max",
                inclusive: !0,
                value: Number.MAX_SAFE_INTEGER,
                message: Y.toString(e)
            })
        }
        get minValue() {
            let e = null;
            for (const r of this._def.checks)
                r.kind === "min" && (e === null || r.value > e) && (e = r.value);
            return e
        }
        get maxValue() {
            let e = null;
            for (const r of this._def.checks)
                r.kind === "max" && (e === null || r.value < e) && (e = r.value);
            return e
        }
        get isInt() {
            return !!this._def.checks.find(e => e.kind === "int" || e.kind === "multipleOf" && ye.isInteger(e.value))
        }
        get isFinite() {
            let e = null
              , r = null;
            for (const o of this._def.checks) {
                if (o.kind === "finite" || o.kind === "int" || o.kind === "multipleOf")
                    return !0;
                o.kind === "min" ? (r === null || o.value > r) && (r = o.value) : o.kind === "max" && (e === null || o.value < e) && (e = o.value)
            }
            return Number.isFinite(r) && Number.isFinite(e)
        }
    }
    Jr.create = t => new Jr({
        checks: [],
        typeName: ae.ZodNumber,
        coerce: (t == null ? void 0 : t.coerce) || !1,
        ...me(t)
    });
    class Yr extends pe {
        constructor() {
            super(...arguments),
            this.min = this.gte,
            this.max = this.lte
        }
        _parse(e) {
            if (this._def.coerce)
                try {
                    e.data = BigInt(e.data)
                } catch {
                    return this._getInvalidInput(e)
                }
            if (this._getType(e) !== H.bigint)
                return this._getInvalidInput(e);
            let o;
            const n = new ct;
            for (const s of this._def.checks)
                s.kind === "min" ? (s.inclusive ? e.data < s.value : e.data <= s.value) && (o = this._getOrReturnCtx(e, o),
                z(o, {
                    code: W.too_small,
                    type: "bigint",
                    minimum: s.value,
                    inclusive: s.inclusive,
                    message: s.message
                }),
                n.dirty()) : s.kind === "max" ? (s.inclusive ? e.data > s.value : e.data >= s.value) && (o = this._getOrReturnCtx(e, o),
                z(o, {
                    code: W.too_big,
                    type: "bigint",
                    maximum: s.value,
                    inclusive: s.inclusive,
                    message: s.message
                }),
                n.dirty()) : s.kind === "multipleOf" ? e.data % s.value !== BigInt(0) && (o = this._getOrReturnCtx(e, o),
                z(o, {
                    code: W.not_multiple_of,
                    multipleOf: s.value,
                    message: s.message
                }),
                n.dirty()) : ye.assertNever(s);
            return {
                status: n.value,
                value: e.data
            }
        }
        _getInvalidInput(e) {
            const r = this._getOrReturnCtx(e);
            return z(r, {
                code: W.invalid_type,
                expected: H.bigint,
                received: r.parsedType
            }),
            se
        }
        gte(e, r) {
            return this.setLimit("min", e, !0, Y.toString(r))
        }
        gt(e, r) {
            return this.setLimit("min", e, !1, Y.toString(r))
        }
        lte(e, r) {
            return this.setLimit("max", e, !0, Y.toString(r))
        }
        lt(e, r) {
            return this.setLimit("max", e, !1, Y.toString(r))
        }
        setLimit(e, r, o, n) {
            return new Yr({
                ...this._def,
                checks: [...this._def.checks, {
                    kind: e,
                    value: r,
                    inclusive: o,
                    message: Y.toString(n)
                }]
            })
        }
        _addCheck(e) {
            return new Yr({
                ...this._def,
                checks: [...this._def.checks, e]
            })
        }
        positive(e) {
            return this._addCheck({
                kind: "min",
                value: BigInt(0),
                inclusive: !1,
                message: Y.toString(e)
            })
        }
        negative(e) {
            return this._addCheck({
                kind: "max",
                value: BigInt(0),
                inclusive: !1,
                message: Y.toString(e)
            })
        }
        nonpositive(e) {
            return this._addCheck({
                kind: "max",
                value: BigInt(0),
                inclusive: !0,
                message: Y.toString(e)
            })
        }
        nonnegative(e) {
            return this._addCheck({
                kind: "min",
                value: BigInt(0),
                inclusive: !0,
                message: Y.toString(e)
            })
        }
        multipleOf(e, r) {
            return this._addCheck({
                kind: "multipleOf",
                value: e,
                message: Y.toString(r)
            })
        }
        get minValue() {
            let e = null;
            for (const r of this._def.checks)
                r.kind === "min" && (e === null || r.value > e) && (e = r.value);
            return e
        }
        get maxValue() {
            let e = null;
            for (const r of this._def.checks)
                r.kind === "max" && (e === null || r.value < e) && (e = r.value);
            return e
        }
    }
    Yr.create = t => new Yr({
        checks: [],
        typeName: ae.ZodBigInt,
        coerce: (t == null ? void 0 : t.coerce) ?? !1,
        ...me(t)
    });
    class Da extends pe {
        _parse(e) {
            if (this._def.coerce && (e.data = !!e.data),
            this._getType(e) !== H.boolean) {
                const o = this._getOrReturnCtx(e);
                return z(o, {
                    code: W.invalid_type,
                    expected: H.boolean,
                    received: o.parsedType
                }),
                se
            }
            return xt(e.data)
        }
    }
    Da.create = t => new Da({
        typeName: ae.ZodBoolean,
        coerce: (t == null ? void 0 : t.coerce) || !1,
        ...me(t)
    });
    class Nn extends pe {
        _parse(e) {
            if (this._def.coerce && (e.data = new Date(e.data)),
            this._getType(e) !== H.date) {
                const s = this._getOrReturnCtx(e);
                return z(s, {
                    code: W.invalid_type,
                    expected: H.date,
                    received: s.parsedType
                }),
                se
            }
            if (Number.isNaN(e.data.getTime())) {
                const s = this._getOrReturnCtx(e);
                return z(s, {
                    code: W.invalid_date
                }),
                se
            }
            const o = new ct;
            let n;
            for (const s of this._def.checks)
                s.kind === "min" ? e.data.getTime() < s.value && (n = this._getOrReturnCtx(e, n),
                z(n, {
                    code: W.too_small,
                    message: s.message,
                    inclusive: !0,
                    exact: !1,
                    minimum: s.value,
                    type: "date"
                }),
                o.dirty()) : s.kind === "max" ? e.data.getTime() > s.value && (n = this._getOrReturnCtx(e, n),
                z(n, {
                    code: W.too_big,
                    message: s.message,
                    inclusive: !0,
                    exact: !1,
                    maximum: s.value,
                    type: "date"
                }),
                o.dirty()) : ye.assertNever(s);
            return {
                status: o.value,
                value: new Date(e.data.getTime())
            }
        }
        _addCheck(e) {
            return new Nn({
                ...this._def,
                checks: [...this._def.checks, e]
            })
        }
        min(e, r) {
            return this._addCheck({
                kind: "min",
                value: e.getTime(),
                message: Y.toString(r)
            })
        }
        max(e, r) {
            return this._addCheck({
                kind: "max",
                value: e.getTime(),
                message: Y.toString(r)
            })
        }
        get minDate() {
            let e = null;
            for (const r of this._def.checks)
                r.kind === "min" && (e === null || r.value > e) && (e = r.value);
            return e != null ? new Date(e) : null
        }
        get maxDate() {
            let e = null;
            for (const r of this._def.checks)
                r.kind === "max" && (e === null || r.value < e) && (e = r.value);
            return e != null ? new Date(e) : null
        }
    }
    Nn.create = t => new Nn({
        checks: [],
        coerce: (t == null ? void 0 : t.coerce) || !1,
        typeName: ae.ZodDate,
        ...me(t)
    });
    class Na extends pe {
        _parse(e) {
            if (this._getType(e) !== H.symbol) {
                const o = this._getOrReturnCtx(e);
                return z(o, {
                    code: W.invalid_type,
                    expected: H.symbol,
                    received: o.parsedType
                }),
                se
            }
            return xt(e.data)
        }
    }
    Na.create = t => new Na({
        typeName: ae.ZodSymbol,
        ...me(t)
    });
    class Vo extends pe {
        _parse(e) {
            if (this._getType(e) !== H.undefined) {
                const o = this._getOrReturnCtx(e);
                return z(o, {
                    code: W.invalid_type,
                    expected: H.undefined,
                    received: o.parsedType
                }),
                se
            }
            return xt(e.data)
        }
    }
    Vo.create = t => new Vo({
        typeName: ae.ZodUndefined,
        ...me(t)
    });
    class Jo extends pe {
        _parse(e) {
            if (this._getType(e) !== H.null) {
                const o = this._getOrReturnCtx(e);
                return z(o, {
                    code: W.invalid_type,
                    expected: H.null,
                    received: o.parsedType
                }),
                se
            }
            return xt(e.data)
        }
    }
    Jo.create = t => new Jo({
        typeName: ae.ZodNull,
        ...me(t)
    });
    class La extends pe {
        constructor() {
            super(...arguments),
            this._any = !0
        }
        _parse(e) {
            return xt(e.data)
        }
    }
    La.create = t => new La({
        typeName: ae.ZodAny,
        ...me(t)
    });
    class Ua extends pe {
        constructor() {
            super(...arguments),
            this._unknown = !0
        }
        _parse(e) {
            return xt(e.data)
        }
    }
    Ua.create = t => new Ua({
        typeName: ae.ZodUnknown,
        ...me(t)
    });
    class yr extends pe {
        _parse(e) {
            const r = this._getOrReturnCtx(e);
            return z(r, {
                code: W.invalid_type,
                expected: H.never,
                received: r.parsedType
            }),
            se
        }
    }
    yr.create = t => new yr({
        typeName: ae.ZodNever,
        ...me(t)
    });
    class ja extends pe {
        _parse(e) {
            if (this._getType(e) !== H.undefined) {
                const o = this._getOrReturnCtx(e);
                return z(o, {
                    code: W.invalid_type,
                    expected: H.void,
                    received: o.parsedType
                }),
                se
            }
            return xt(e.data)
        }
    }
    ja.create = t => new ja({
        typeName: ae.ZodVoid,
        ...me(t)
    });
    class qt extends pe {
        _parse(e) {
            const {ctx: r, status: o} = this._processInputParams(e)
              , n = this._def;
            if (r.parsedType !== H.array)
                return z(r, {
                    code: W.invalid_type,
                    expected: H.array,
                    received: r.parsedType
                }),
                se;
            if (n.exactLength !== null) {
                const i = r.data.length > n.exactLength.value
                  , l = r.data.length < n.exactLength.value;
                (i || l) && (z(r, {
                    code: i ? W.too_big : W.too_small,
                    minimum: l ? n.exactLength.value : void 0,
                    maximum: i ? n.exactLength.value : void 0,
                    type: "array",
                    inclusive: !0,
                    exact: !0,
                    message: n.exactLength.message
                }),
                o.dirty())
            }
            if (n.minLength !== null && r.data.length < n.minLength.value && (z(r, {
                code: W.too_small,
                minimum: n.minLength.value,
                type: "array",
                inclusive: !0,
                exact: !1,
                message: n.minLength.message
            }),
            o.dirty()),
            n.maxLength !== null && r.data.length > n.maxLength.value && (z(r, {
                code: W.too_big,
                maximum: n.maxLength.value,
                type: "array",
                inclusive: !0,
                exact: !1,
                message: n.maxLength.message
            }),
            o.dirty()),
            r.common.async)
                return Promise.all([...r.data].map( (i, l) => n.type._parseAsync(new Wt(r,i,r.path,l)))).then(i => ct.mergeArray(o, i));
            const s = [...r.data].map( (i, l) => n.type._parseSync(new Wt(r,i,r.path,l)));
            return ct.mergeArray(o, s)
        }
        get element() {
            return this._def.type
        }
        min(e, r) {
            return new qt({
                ...this._def,
                minLength: {
                    value: e,
                    message: Y.toString(r)
                }
            })
        }
        max(e, r) {
            return new qt({
                ...this._def,
                maxLength: {
                    value: e,
                    message: Y.toString(r)
                }
            })
        }
        length(e, r) {
            return new qt({
                ...this._def,
                exactLength: {
                    value: e,
                    message: Y.toString(r)
                }
            })
        }
        nonempty(e) {
            return this.min(1, e)
        }
    }
    qt.create = (t, e) => new qt({
        type: t,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: ae.ZodArray,
        ...me(e)
    });
    function Kr(t) {
        if (t instanceof Me) {
            const e = {};
            for (const r in t.shape) {
                const o = t.shape[r];
                e[r] = nr.create(Kr(o))
            }
            return new Me({
                ...t._def,
                shape: () => e
            })
        } else
            return t instanceof qt ? new qt({
                ...t._def,
                type: Kr(t.element)
            }) : t instanceof nr ? nr.create(Kr(t.unwrap())) : t instanceof Ar ? Ar.create(Kr(t.unwrap())) : t instanceof Cr ? Cr.create(t.items.map(e => Kr(e))) : t
    }
    class Me extends pe {
        constructor() {
            super(...arguments),
            this._cached = null,
            this.nonstrict = this.passthrough,
            this.augment = this.extend
        }
        _getCached() {
            if (this._cached !== null)
                return this._cached;
            const e = this._def.shape()
              , r = ye.objectKeys(e);
            return this._cached = {
                shape: e,
                keys: r
            },
            this._cached
        }
        _parse(e) {
            if (this._getType(e) !== H.object) {
                const u = this._getOrReturnCtx(e);
                return z(u, {
                    code: W.invalid_type,
                    expected: H.object,
                    received: u.parsedType
                }),
                se
            }
            const {status: o, ctx: n} = this._processInputParams(e)
              , {shape: s, keys: i} = this._getCached()
              , l = [];
            if (!(this._def.catchall instanceof yr && this._def.unknownKeys === "strip"))
                for (const u in n.data)
                    i.includes(u) || l.push(u);
            const d = [];
            for (const u of i) {
                const g = s[u]
                  , c = n.data[u];
                d.push({
                    key: {
                        status: "valid",
                        value: u
                    },
                    value: g._parse(new Wt(n,c,n.path,u)),
                    alwaysSet: u in n.data
                })
            }
            if (this._def.catchall instanceof yr) {
                const u = this._def.unknownKeys;
                if (u === "passthrough")
                    for (const g of l)
                        d.push({
                            key: {
                                status: "valid",
                                value: g
                            },
                            value: {
                                status: "valid",
                                value: n.data[g]
                            }
                        });
                else if (u === "strict")
                    l.length > 0 && (z(n, {
                        code: W.unrecognized_keys,
                        keys: l
                    }),
                    o.dirty());
                else if (u !== "strip")
                    throw new Error("Internal ZodObject error: invalid unknownKeys value.")
            } else {
                const u = this._def.catchall;
                for (const g of l) {
                    const c = n.data[g];
                    d.push({
                        key: {
                            status: "valid",
                            value: g
                        },
                        value: u._parse(new Wt(n,c,n.path,g)),
                        alwaysSet: g in n.data
                    })
                }
            }
            return n.common.async ? Promise.resolve().then(async () => {
                const u = [];
                for (const g of d) {
                    const c = await g.key
                      , m = await g.value;
                    u.push({
                        key: c,
                        value: m,
                        alwaysSet: g.alwaysSet
                    })
                }
                return u
            }
            ).then(u => ct.mergeObjectSync(o, u)) : ct.mergeObjectSync(o, d)
        }
        get shape() {
            return this._def.shape()
        }
        strict(e) {
            return Y.errToObj,
            new Me({
                ...this._def,
                unknownKeys: "strict",
                ...e !== void 0 ? {
                    errorMap: (r, o) => {
                        var s, i;
                        const n = ((i = (s = this._def).errorMap) == null ? void 0 : i.call(s, r, o).message) ?? o.defaultError;
                        return r.code === "unrecognized_keys" ? {
                            message: Y.errToObj(e).message ?? n
                        } : {
                            message: n
                        }
                    }
                } : {}
            })
        }
        strip() {
            return new Me({
                ...this._def,
                unknownKeys: "strip"
            })
        }
        passthrough() {
            return new Me({
                ...this._def,
                unknownKeys: "passthrough"
            })
        }
        extend(e) {
            return new Me({
                ...this._def,
                shape: () => ({
                    ...this._def.shape(),
                    ...e
                })
            })
        }
        merge(e) {
            return new Me({
                unknownKeys: e._def.unknownKeys,
                catchall: e._def.catchall,
                shape: () => ({
                    ...this._def.shape(),
                    ...e._def.shape()
                }),
                typeName: ae.ZodObject
            })
        }
        setKey(e, r) {
            return this.augment({
                [e]: r
            })
        }
        catchall(e) {
            return new Me({
                ...this._def,
                catchall: e
            })
        }
        pick(e) {
            const r = {};
            for (const o of ye.objectKeys(e))
                e[o] && this.shape[o] && (r[o] = this.shape[o]);
            return new Me({
                ...this._def,
                shape: () => r
            })
        }
        omit(e) {
            const r = {};
            for (const o of ye.objectKeys(this.shape))
                e[o] || (r[o] = this.shape[o]);
            return new Me({
                ...this._def,
                shape: () => r
            })
        }
        deepPartial() {
            return Kr(this)
        }
        partial(e) {
            const r = {};
            for (const o of ye.objectKeys(this.shape)) {
                const n = this.shape[o];
                e && !e[o] ? r[o] = n : r[o] = n.optional()
            }
            return new Me({
                ...this._def,
                shape: () => r
            })
        }
        required(e) {
            const r = {};
            for (const o of ye.objectKeys(this.shape))
                if (e && !e[o])
                    r[o] = this.shape[o];
                else {
                    let s = this.shape[o];
                    for (; s instanceof nr; )
                        s = s._def.innerType;
                    r[o] = s
                }
            return new Me({
                ...this._def,
                shape: () => r
            })
        }
        keyof() {
            return Gc(ye.objectKeys(this.shape))
        }
    }
    Me.create = (t, e) => new Me({
        shape: () => t,
        unknownKeys: "strip",
        catchall: yr.create(),
        typeName: ae.ZodObject,
        ...me(e)
    }),
    Me.strictCreate = (t, e) => new Me({
        shape: () => t,
        unknownKeys: "strict",
        catchall: yr.create(),
        typeName: ae.ZodObject,
        ...me(e)
    }),
    Me.lazycreate = (t, e) => new Me({
        shape: t,
        unknownKeys: "strip",
        catchall: yr.create(),
        typeName: ae.ZodObject,
        ...me(e)
    });
    class Yo extends pe {
        _parse(e) {
            const {ctx: r} = this._processInputParams(e)
              , o = this._def.options;
            function n(s) {
                for (const l of s)
                    if (l.result.status === "valid")
                        return l.result;
                for (const l of s)
                    if (l.result.status === "dirty")
                        return r.common.issues.push(...l.ctx.common.issues),
                        l.result;
                const i = s.map(l => new Xt(l.ctx.common.issues));
                return z(r, {
                    code: W.invalid_union,
                    unionErrors: i
                }),
                se
            }
            if (r.common.async)
                return Promise.all(o.map(async s => {
                    const i = {
                        ...r,
                        common: {
                            ...r.common,
                            issues: []
                        },
                        parent: null
                    };
                    return {
                        result: await s._parseAsync({
                            data: r.data,
                            path: r.path,
                            parent: i
                        }),
                        ctx: i
                    }
                }
                )).then(n);
            {
                let s;
                const i = [];
                for (const d of o) {
                    const u = {
                        ...r,
                        common: {
                            ...r.common,
                            issues: []
                        },
                        parent: null
                    }
                      , g = d._parseSync({
                        data: r.data,
                        path: r.path,
                        parent: u
                    });
                    if (g.status === "valid")
                        return g;
                    g.status === "dirty" && !s && (s = {
                        result: g,
                        ctx: u
                    }),
                    u.common.issues.length && i.push(u.common.issues)
                }
                if (s)
                    return r.common.issues.push(...s.ctx.common.issues),
                    s.result;
                const l = i.map(d => new Xt(d));
                return z(r, {
                    code: W.invalid_union,
                    unionErrors: l
                }),
                se
            }
        }
        get options() {
            return this._def.options
        }
    }
    Yo.create = (t, e) => new Yo({
        options: t,
        typeName: ae.ZodUnion,
        ...me(e)
    });
    const tr = t => t instanceof Xo ? tr(t.schema) : t instanceof rr ? tr(t.innerType()) : t instanceof es ? [t.value] : t instanceof $r ? t.options : t instanceof ts ? ye.objectValues(t.enum) : t instanceof ns ? tr(t._def.innerType) : t instanceof Vo ? [void 0] : t instanceof Jo ? [null] : t instanceof nr ? [void 0, ...tr(t.unwrap())] : t instanceof Ar ? [null, ...tr(t.unwrap())] : t instanceof Bc || t instanceof ss ? tr(t.unwrap()) : t instanceof os ? tr(t._def.innerType) : [];
    class Ma extends pe {
        _parse(e) {
            const {ctx: r} = this._processInputParams(e);
            if (r.parsedType !== H.object)
                return z(r, {
                    code: W.invalid_type,
                    expected: H.object,
                    received: r.parsedType
                }),
                se;
            const o = this.discriminator
              , n = r.data[o]
              , s = this.optionsMap.get(n);
            return s ? r.common.async ? s._parseAsync({
                data: r.data,
                path: r.path,
                parent: r
            }) : s._parseSync({
                data: r.data,
                path: r.path,
                parent: r
            }) : (z(r, {
                code: W.invalid_union_discriminator,
                options: Array.from(this.optionsMap.keys()),
                path: [o]
            }),
            se)
        }
        get discriminator() {
            return this._def.discriminator
        }
        get options() {
            return this._def.options
        }
        get optionsMap() {
            return this._def.optionsMap
        }
        static create(e, r, o) {
            const n = new Map;
            for (const s of r) {
                const i = tr(s.shape[e]);
                if (!i.length)
                    throw new Error(`A discriminator value for key \`${e}\` could not be extracted from all schema options`);
                for (const l of i) {
                    if (n.has(l))
                        throw new Error(`Discriminator property ${String(e)} has duplicate value ${String(l)}`);
                    n.set(l, s)
                }
            }
            return new Ma({
                typeName: ae.ZodDiscriminatedUnion,
                discriminator: e,
                options: r,
                optionsMap: n,
                ...me(o)
            })
        }
    }
    function Fa(t, e) {
        const r = fr(t)
          , o = fr(e);
        if (t === e)
            return {
                valid: !0,
                data: t
            };
        if (r === H.object && o === H.object) {
            const n = ye.objectKeys(e)
              , s = ye.objectKeys(t).filter(l => n.indexOf(l) !== -1)
              , i = {
                ...t,
                ...e
            };
            for (const l of s) {
                const d = Fa(t[l], e[l]);
                if (!d.valid)
                    return {
                        valid: !1
                    };
                i[l] = d.data
            }
            return {
                valid: !0,
                data: i
            }
        } else if (r === H.array && o === H.array) {
            if (t.length !== e.length)
                return {
                    valid: !1
                };
            const n = [];
            for (let s = 0; s < t.length; s++) {
                const i = t[s]
                  , l = e[s]
                  , d = Fa(i, l);
                if (!d.valid)
                    return {
                        valid: !1
                    };
                n.push(d.data)
            }
            return {
                valid: !0,
                data: n
            }
        } else
            return r === H.date && o === H.date && +t == +e ? {
                valid: !0,
                data: t
            } : {
                valid: !1
            }
    }
    class Ko extends pe {
        _parse(e) {
            const {status: r, ctx: o} = this._processInputParams(e)
              , n = (s, i) => {
                if (jc(s) || jc(i))
                    return se;
                const l = Fa(s.value, i.value);
                return l.valid ? ((Mc(s) || Mc(i)) && r.dirty(),
                {
                    status: r.value,
                    value: l.data
                }) : (z(o, {
                    code: W.invalid_intersection_types
                }),
                se)
            }
            ;
            return o.common.async ? Promise.all([this._def.left._parseAsync({
                data: o.data,
                path: o.path,
                parent: o
            }), this._def.right._parseAsync({
                data: o.data,
                path: o.path,
                parent: o
            })]).then( ([s,i]) => n(s, i)) : n(this._def.left._parseSync({
                data: o.data,
                path: o.path,
                parent: o
            }), this._def.right._parseSync({
                data: o.data,
                path: o.path,
                parent: o
            }))
        }
    }
    Ko.create = (t, e, r) => new Ko({
        left: t,
        right: e,
        typeName: ae.ZodIntersection,
        ...me(r)
    });
    class Cr extends pe {
        _parse(e) {
            const {status: r, ctx: o} = this._processInputParams(e);
            if (o.parsedType !== H.array)
                return z(o, {
                    code: W.invalid_type,
                    expected: H.array,
                    received: o.parsedType
                }),
                se;
            if (o.data.length < this._def.items.length)
                return z(o, {
                    code: W.too_small,
                    minimum: this._def.items.length,
                    inclusive: !0,
                    exact: !1,
                    type: "array"
                }),
                se;
            !this._def.rest && o.data.length > this._def.items.length && (z(o, {
                code: W.too_big,
                maximum: this._def.items.length,
                inclusive: !0,
                exact: !1,
                type: "array"
            }),
            r.dirty());
            const s = [...o.data].map( (i, l) => {
                const d = this._def.items[l] || this._def.rest;
                return d ? d._parse(new Wt(o,i,o.path,l)) : null
            }
            ).filter(i => !!i);
            return o.common.async ? Promise.all(s).then(i => ct.mergeArray(r, i)) : ct.mergeArray(r, s)
        }
        get items() {
            return this._def.items
        }
        rest(e) {
            return new Cr({
                ...this._def,
                rest: e
            })
        }
    }
    Cr.create = (t, e) => {
        if (!Array.isArray(t))
            throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
        return new Cr({
            items: t,
            typeName: ae.ZodTuple,
            rest: null,
            ...me(e)
        })
    }
    ;
    class Qo extends pe {
        get keySchema() {
            return this._def.keyType
        }
        get valueSchema() {
            return this._def.valueType
        }
        _parse(e) {
            const {status: r, ctx: o} = this._processInputParams(e);
            if (o.parsedType !== H.object)
                return z(o, {
                    code: W.invalid_type,
                    expected: H.object,
                    received: o.parsedType
                }),
                se;
            const n = []
              , s = this._def.keyType
              , i = this._def.valueType;
            for (const l in o.data)
                n.push({
                    key: s._parse(new Wt(o,l,o.path,l)),
                    value: i._parse(new Wt(o,o.data[l],o.path,l)),
                    alwaysSet: l in o.data
                });
            return o.common.async ? ct.mergeObjectAsync(r, n) : ct.mergeObjectSync(r, n)
        }
        get element() {
            return this._def.valueType
        }
        static create(e, r, o) {
            return r instanceof pe ? new Qo({
                keyType: e,
                valueType: r,
                typeName: ae.ZodRecord,
                ...me(o)
            }) : new Qo({
                keyType: er.create(),
                valueType: e,
                typeName: ae.ZodRecord,
                ...me(r)
            })
        }
    }
    class Wa extends pe {
        get keySchema() {
            return this._def.keyType
        }
        get valueSchema() {
            return this._def.valueType
        }
        _parse(e) {
            const {status: r, ctx: o} = this._processInputParams(e);
            if (o.parsedType !== H.map)
                return z(o, {
                    code: W.invalid_type,
                    expected: H.map,
                    received: o.parsedType
                }),
                se;
            const n = this._def.keyType
              , s = this._def.valueType
              , i = [...o.data.entries()].map( ([l,d], u) => ({
                key: n._parse(new Wt(o,l,o.path,[u, "key"])),
                value: s._parse(new Wt(o,d,o.path,[u, "value"]))
            }));
            if (o.common.async) {
                const l = new Map;
                return Promise.resolve().then(async () => {
                    for (const d of i) {
                        const u = await d.key
                          , g = await d.value;
                        if (u.status === "aborted" || g.status === "aborted")
                            return se;
                        (u.status === "dirty" || g.status === "dirty") && r.dirty(),
                        l.set(u.value, g.value)
                    }
                    return {
                        status: r.value,
                        value: l
                    }
                }
                )
            } else {
                const l = new Map;
                for (const d of i) {
                    const u = d.key
                      , g = d.value;
                    if (u.status === "aborted" || g.status === "aborted")
                        return se;
                    (u.status === "dirty" || g.status === "dirty") && r.dirty(),
                    l.set(u.value, g.value)
                }
                return {
                    status: r.value,
                    value: l
                }
            }
        }
    }
    Wa.create = (t, e, r) => new Wa({
        valueType: e,
        keyType: t,
        typeName: ae.ZodMap,
        ...me(r)
    });
    class Qr extends pe {
        _parse(e) {
            const {status: r, ctx: o} = this._processInputParams(e);
            if (o.parsedType !== H.set)
                return z(o, {
                    code: W.invalid_type,
                    expected: H.set,
                    received: o.parsedType
                }),
                se;
            const n = this._def;
            n.minSize !== null && o.data.size < n.minSize.value && (z(o, {
                code: W.too_small,
                minimum: n.minSize.value,
                type: "set",
                inclusive: !0,
                exact: !1,
                message: n.minSize.message
            }),
            r.dirty()),
            n.maxSize !== null && o.data.size > n.maxSize.value && (z(o, {
                code: W.too_big,
                maximum: n.maxSize.value,
                type: "set",
                inclusive: !0,
                exact: !1,
                message: n.maxSize.message
            }),
            r.dirty());
            const s = this._def.valueType;
            function i(d) {
                const u = new Set;
                for (const g of d) {
                    if (g.status === "aborted")
                        return se;
                    g.status === "dirty" && r.dirty(),
                    u.add(g.value)
                }
                return {
                    status: r.value,
                    value: u
                }
            }
            const l = [...o.data.values()].map( (d, u) => s._parse(new Wt(o,d,o.path,u)));
            return o.common.async ? Promise.all(l).then(d => i(d)) : i(l)
        }
        min(e, r) {
            return new Qr({
                ...this._def,
                minSize: {
                    value: e,
                    message: Y.toString(r)
                }
            })
        }
        max(e, r) {
            return new Qr({
                ...this._def,
                maxSize: {
                    value: e,
                    message: Y.toString(r)
                }
            })
        }
        size(e, r) {
            return this.min(e, r).max(e, r)
        }
        nonempty(e) {
            return this.min(1, e)
        }
    }
    Qr.create = (t, e) => new Qr({
        valueType: t,
        minSize: null,
        maxSize: null,
        typeName: ae.ZodSet,
        ...me(e)
    });
    class Xo extends pe {
        get schema() {
            return this._def.getter()
        }
        _parse(e) {
            const {ctx: r} = this._processInputParams(e);
            return this._def.getter()._parse({
                data: r.data,
                path: r.path,
                parent: r
            })
        }
    }
    Xo.create = (t, e) => new Xo({
        getter: t,
        typeName: ae.ZodLazy,
        ...me(e)
    });
    class es extends pe {
        _parse(e) {
            if (e.data !== this._def.value) {
                const r = this._getOrReturnCtx(e);
                return z(r, {
                    received: r.data,
                    code: W.invalid_literal,
                    expected: this._def.value
                }),
                se
            }
            return {
                status: "valid",
                value: e.data
            }
        }
        get value() {
            return this._def.value
        }
    }
    es.create = (t, e) => new es({
        value: t,
        typeName: ae.ZodLiteral,
        ...me(e)
    });
    function Gc(t, e) {
        return new $r({
            values: t,
            typeName: ae.ZodEnum,
            ...me(e)
        })
    }
    class $r extends pe {
        _parse(e) {
            if (typeof e.data != "string") {
                const r = this._getOrReturnCtx(e)
                  , o = this._def.values;
                return z(r, {
                    expected: ye.joinValues(o),
                    received: r.parsedType,
                    code: W.invalid_type
                }),
                se
            }
            if (this._cache || (this._cache = new Set(this._def.values)),
            !this._cache.has(e.data)) {
                const r = this._getOrReturnCtx(e)
                  , o = this._def.values;
                return z(r, {
                    received: r.data,
                    code: W.invalid_enum_value,
                    options: o
                }),
                se
            }
            return xt(e.data)
        }
        get options() {
            return this._def.values
        }
        get enum() {
            const e = {};
            for (const r of this._def.values)
                e[r] = r;
            return e
        }
        get Values() {
            const e = {};
            for (const r of this._def.values)
                e[r] = r;
            return e
        }
        get Enum() {
            const e = {};
            for (const r of this._def.values)
                e[r] = r;
            return e
        }
        extract(e, r=this._def) {
            return $r.create(e, {
                ...this._def,
                ...r
            })
        }
        exclude(e, r=this._def) {
            return $r.create(this.options.filter(o => !e.includes(o)), {
                ...this._def,
                ...r
            })
        }
    }
    $r.create = Gc;
    class ts extends pe {
        _parse(e) {
            const r = ye.getValidEnumValues(this._def.values)
              , o = this._getOrReturnCtx(e);
            if (o.parsedType !== H.string && o.parsedType !== H.number) {
                const n = ye.objectValues(r);
                return z(o, {
                    expected: ye.joinValues(n),
                    received: o.parsedType,
                    code: W.invalid_type
                }),
                se
            }
            if (this._cache || (this._cache = new Set(ye.getValidEnumValues(this._def.values))),
            !this._cache.has(e.data)) {
                const n = ye.objectValues(r);
                return z(o, {
                    received: o.data,
                    code: W.invalid_enum_value,
                    options: n
                }),
                se
            }
            return xt(e.data)
        }
        get enum() {
            return this._def.values
        }
    }
    ts.create = (t, e) => new ts({
        values: t,
        typeName: ae.ZodNativeEnum,
        ...me(e)
    });
    class rs extends pe {
        unwrap() {
            return this._def.type
        }
        _parse(e) {
            const {ctx: r} = this._processInputParams(e);
            if (r.parsedType !== H.promise && r.common.async === !1)
                return z(r, {
                    code: W.invalid_type,
                    expected: H.promise,
                    received: r.parsedType
                }),
                se;
            const o = r.parsedType === H.promise ? r.data : Promise.resolve(r.data);
            return xt(o.then(n => this._def.type.parseAsync(n, {
                path: r.path,
                errorMap: r.common.contextualErrorMap
            })))
        }
    }
    rs.create = (t, e) => new rs({
        type: t,
        typeName: ae.ZodPromise,
        ...me(e)
    });
    class rr extends pe {
        innerType() {
            return this._def.schema
        }
        sourceType() {
            return this._def.schema._def.typeName === ae.ZodEffects ? this._def.schema.sourceType() : this._def.schema
        }
        _parse(e) {
            const {status: r, ctx: o} = this._processInputParams(e)
              , n = this._def.effect || null
              , s = {
                addIssue: i => {
                    z(o, i),
                    i.fatal ? r.abort() : r.dirty()
                }
                ,
                get path() {
                    return o.path
                }
            };
            if (s.addIssue = s.addIssue.bind(s),
            n.type === "preprocess") {
                const i = n.transform(o.data, s);
                if (o.common.async)
                    return Promise.resolve(i).then(async l => {
                        if (r.value === "aborted")
                            return se;
                        const d = await this._def.schema._parseAsync({
                            data: l,
                            path: o.path,
                            parent: o
                        });
                        return d.status === "aborted" ? se : d.status === "dirty" || r.value === "dirty" ? Dn(d.value) : d
                    }
                    );
                {
                    if (r.value === "aborted")
                        return se;
                    const l = this._def.schema._parseSync({
                        data: i,
                        path: o.path,
                        parent: o
                    });
                    return l.status === "aborted" ? se : l.status === "dirty" || r.value === "dirty" ? Dn(l.value) : l
                }
            }
            if (n.type === "refinement") {
                const i = l => {
                    const d = n.refinement(l, s);
                    if (o.common.async)
                        return Promise.resolve(d);
                    if (d instanceof Promise)
                        throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                    return l
                }
                ;
                if (o.common.async === !1) {
                    const l = this._def.schema._parseSync({
                        data: o.data,
                        path: o.path,
                        parent: o
                    });
                    return l.status === "aborted" ? se : (l.status === "dirty" && r.dirty(),
                    i(l.value),
                    {
                        status: r.value,
                        value: l.value
                    })
                } else
                    return this._def.schema._parseAsync({
                        data: o.data,
                        path: o.path,
                        parent: o
                    }).then(l => l.status === "aborted" ? se : (l.status === "dirty" && r.dirty(),
                    i(l.value).then( () => ({
                        status: r.value,
                        value: l.value
                    }))))
            }
            if (n.type === "transform")
                if (o.common.async === !1) {
                    const i = this._def.schema._parseSync({
                        data: o.data,
                        path: o.path,
                        parent: o
                    });
                    if (!Vr(i))
                        return se;
                    const l = n.transform(i.value, s);
                    if (l instanceof Promise)
                        throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
                    return {
                        status: r.value,
                        value: l
                    }
                } else
                    return this._def.schema._parseAsync({
                        data: o.data,
                        path: o.path,
                        parent: o
                    }).then(i => Vr(i) ? Promise.resolve(n.transform(i.value, s)).then(l => ({
                        status: r.value,
                        value: l
                    })) : se);
            ye.assertNever(n)
        }
    }
    rr.create = (t, e, r) => new rr({
        schema: t,
        typeName: ae.ZodEffects,
        effect: e,
        ...me(r)
    }),
    rr.createWithPreprocess = (t, e, r) => new rr({
        schema: e,
        effect: {
            type: "preprocess",
            transform: t
        },
        typeName: ae.ZodEffects,
        ...me(r)
    });
    class nr extends pe {
        _parse(e) {
            return this._getType(e) === H.undefined ? xt(void 0) : this._def.innerType._parse(e)
        }
        unwrap() {
            return this._def.innerType
        }
    }
    nr.create = (t, e) => new nr({
        innerType: t,
        typeName: ae.ZodOptional,
        ...me(e)
    });
    class Ar extends pe {
        _parse(e) {
            return this._getType(e) === H.null ? xt(null) : this._def.innerType._parse(e)
        }
        unwrap() {
            return this._def.innerType
        }
    }
    Ar.create = (t, e) => new Ar({
        innerType: t,
        typeName: ae.ZodNullable,
        ...me(e)
    });
    class ns extends pe {
        _parse(e) {
            const {ctx: r} = this._processInputParams(e);
            let o = r.data;
            return r.parsedType === H.undefined && (o = this._def.defaultValue()),
            this._def.innerType._parse({
                data: o,
                path: r.path,
                parent: r
            })
        }
        removeDefault() {
            return this._def.innerType
        }
    }
    ns.create = (t, e) => new ns({
        innerType: t,
        typeName: ae.ZodDefault,
        defaultValue: typeof e.default == "function" ? e.default : () => e.default,
        ...me(e)
    });
    class os extends pe {
        _parse(e) {
            const {ctx: r} = this._processInputParams(e)
              , o = {
                ...r,
                common: {
                    ...r.common,
                    issues: []
                }
            }
              , n = this._def.innerType._parse({
                data: o.data,
                path: o.path,
                parent: {
                    ...o
                }
            });
            return Ho(n) ? n.then(s => ({
                status: "valid",
                value: s.status === "valid" ? s.value : this._def.catchValue({
                    get error() {
                        return new Xt(o.common.issues)
                    },
                    input: o.data
                })
            })) : {
                status: "valid",
                value: n.status === "valid" ? n.value : this._def.catchValue({
                    get error() {
                        return new Xt(o.common.issues)
                    },
                    input: o.data
                })
            }
        }
        removeCatch() {
            return this._def.innerType
        }
    }
    os.create = (t, e) => new os({
        innerType: t,
        typeName: ae.ZodCatch,
        catchValue: typeof e.catch == "function" ? e.catch : () => e.catch,
        ...me(e)
    });
    class qa extends pe {
        _parse(e) {
            if (this._getType(e) !== H.nan) {
                const o = this._getOrReturnCtx(e);
                return z(o, {
                    code: W.invalid_type,
                    expected: H.nan,
                    received: o.parsedType
                }),
                se
            }
            return {
                status: "valid",
                value: e.data
            }
        }
    }
    qa.create = t => new qa({
        typeName: ae.ZodNaN,
        ...me(t)
    });
    class Bc extends pe {
        _parse(e) {
            const {ctx: r} = this._processInputParams(e)
              , o = r.data;
            return this._def.type._parse({
                data: o,
                path: r.path,
                parent: r
            })
        }
        unwrap() {
            return this._def.type
        }
    }
    class Ga extends pe {
        _parse(e) {
            const {status: r, ctx: o} = this._processInputParams(e);
            if (o.common.async)
                return (async () => {
                    const s = await this._def.in._parseAsync({
                        data: o.data,
                        path: o.path,
                        parent: o
                    });
                    return s.status === "aborted" ? se : s.status === "dirty" ? (r.dirty(),
                    Dn(s.value)) : this._def.out._parseAsync({
                        data: s.value,
                        path: o.path,
                        parent: o
                    })
                }
                )();
            {
                const n = this._def.in._parseSync({
                    data: o.data,
                    path: o.path,
                    parent: o
                });
                return n.status === "aborted" ? se : n.status === "dirty" ? (r.dirty(),
                {
                    status: "dirty",
                    value: n.value
                }) : this._def.out._parseSync({
                    data: n.value,
                    path: o.path,
                    parent: o
                })
            }
        }
        static create(e, r) {
            return new Ga({
                in: e,
                out: r,
                typeName: ae.ZodPipeline
            })
        }
    }
    class ss extends pe {
        _parse(e) {
            const r = this._def.innerType._parse(e)
              , o = n => (Vr(n) && (n.value = Object.freeze(n.value)),
            n);
            return Ho(r) ? r.then(n => o(n)) : o(r)
        }
        unwrap() {
            return this._def.innerType
        }
    }
    ss.create = (t, e) => new ss({
        innerType: t,
        typeName: ae.ZodReadonly,
        ...me(e)
    }),
    Me.lazycreate;
    var ae;
    (function(t) {
        t.ZodString = "ZodString",
        t.ZodNumber = "ZodNumber",
        t.ZodNaN = "ZodNaN",
        t.ZodBigInt = "ZodBigInt",
        t.ZodBoolean = "ZodBoolean",
        t.ZodDate = "ZodDate",
        t.ZodSymbol = "ZodSymbol",
        t.ZodUndefined = "ZodUndefined",
        t.ZodNull = "ZodNull",
        t.ZodAny = "ZodAny",
        t.ZodUnknown = "ZodUnknown",
        t.ZodNever = "ZodNever",
        t.ZodVoid = "ZodVoid",
        t.ZodArray = "ZodArray",
        t.ZodObject = "ZodObject",
        t.ZodUnion = "ZodUnion",
        t.ZodDiscriminatedUnion = "ZodDiscriminatedUnion",
        t.ZodIntersection = "ZodIntersection",
        t.ZodTuple = "ZodTuple",
        t.ZodRecord = "ZodRecord",
        t.ZodMap = "ZodMap",
        t.ZodSet = "ZodSet",
        t.ZodFunction = "ZodFunction",
        t.ZodLazy = "ZodLazy",
        t.ZodLiteral = "ZodLiteral",
        t.ZodEnum = "ZodEnum",
        t.ZodEffects = "ZodEffects",
        t.ZodNativeEnum = "ZodNativeEnum",
        t.ZodOptional = "ZodOptional",
        t.ZodNullable = "ZodNullable",
        t.ZodDefault = "ZodDefault",
        t.ZodCatch = "ZodCatch",
        t.ZodPromise = "ZodPromise",
        t.ZodBranded = "ZodBranded",
        t.ZodPipeline = "ZodPipeline",
        t.ZodReadonly = "ZodReadonly"
    }
    )(ae || (ae = {}));
    const Z = er.create
      , dt = Jr.create;
    qa.create,
    Yr.create;
    const wt = Da.create;
    Nn.create,
    Na.create,
    Vo.create,
    Jo.create,
    La.create;
    const Ln = Ua.create;
    yr.create,
    ja.create;
    const tt = qt.create
      , V = Me.create;
    Me.strictCreate;
    const ut = Yo.create
      , Sy = Ma.create;
    Ko.create,
    Cr.create;
    const Un = Qo.create;
    Wa.create,
    Qr.create,
    Xo.create;
    const de = es.create
      , or = $r.create;
    ts.create,
    rs.create,
    rr.create;
    const j = nr.create;
    Ar.create,
    rr.createWithPreprocess;
    const as = "2.0"
      , zc = ut([Z(), dt().int()])
      , Zc = Z()
      , Ey = V({
        progressToken: j(zc)
    }).passthrough()
      , _t = V({
        _meta: j(Ey)
    }).passthrough()
      , gt = V({
        method: Z(),
        params: j(_t)
    })
      , jn = V({
        _meta: j(V({}).passthrough())
    }).passthrough()
      , Gt = V({
        method: Z(),
        params: j(jn)
    })
      , Tt = V({
        _meta: j(V({}).passthrough())
    }).passthrough()
      , is = ut([Z(), dt().int()])
      , xy = V({
        jsonrpc: de(as),
        id: is
    }).merge(gt).strict()
      , _y = V({
        jsonrpc: de(as)
    }).merge(Gt).strict()
      , Ty = V({
        jsonrpc: de(as),
        id: is,
        result: Tt
    }).strict();
    var Hc;
    (function(t) {
        t[t.ConnectionClosed = -32e3] = "ConnectionClosed",
        t[t.RequestTimeout = -32001] = "RequestTimeout",
        t[t.ParseError = -32700] = "ParseError",
        t[t.InvalidRequest = -32600] = "InvalidRequest",
        t[t.MethodNotFound = -32601] = "MethodNotFound",
        t[t.InvalidParams = -32602] = "InvalidParams",
        t[t.InternalError = -32603] = "InternalError"
    }
    )(Hc || (Hc = {}));
    const Py = V({
        jsonrpc: de(as),
        id: is,
        error: V({
            code: dt().int(),
            message: Z(),
            data: j(Ln())
        })
    }).strict()
      , ky = ut([xy, _y, Ty, Py])
      , Vc = Tt.strict()
      , Jc = Gt.extend({
        method: de("notifications/cancelled"),
        params: jn.extend({
            requestId: is,
            reason: Z().optional()
        })
    })
      , Mn = V({
        name: Z(),
        title: j(Z())
    }).passthrough()
      , Yc = Mn.extend({
        version: Z()
    })
      , Iy = V({
        experimental: j(V({}).passthrough()),
        sampling: j(V({}).passthrough()),
        elicitation: j(V({}).passthrough()),
        roots: j(V({
            listChanged: j(wt())
        }).passthrough())
    }).passthrough()
      , Cy = gt.extend({
        method: de("initialize"),
        params: _t.extend({
            protocolVersion: Z(),
            capabilities: Iy,
            clientInfo: Yc
        })
    })
      , $y = V({
        experimental: j(V({}).passthrough()),
        logging: j(V({}).passthrough()),
        completions: j(V({}).passthrough()),
        prompts: j(V({
            listChanged: j(wt())
        }).passthrough()),
        resources: j(V({
            subscribe: j(wt()),
            listChanged: j(wt())
        }).passthrough()),
        tools: j(V({
            listChanged: j(wt())
        }).passthrough())
    }).passthrough()
      , Ay = Tt.extend({
        protocolVersion: Z(),
        capabilities: $y,
        serverInfo: Yc,
        instructions: j(Z())
    })
      , Ry = Gt.extend({
        method: de("notifications/initialized")
    })
      , Kc = gt.extend({
        method: de("ping")
    })
      , Oy = V({
        progress: dt(),
        total: j(dt()),
        message: j(Z())
    }).passthrough()
      , Qc = Gt.extend({
        method: de("notifications/progress"),
        params: jn.merge(Oy).extend({
            progressToken: zc
        })
    })
      , ls = gt.extend({
        params: _t.extend({
            cursor: j(Zc)
        }).optional()
    })
      , cs = Tt.extend({
        nextCursor: j(Zc)
    })
      , Xc = V({
        uri: Z(),
        mimeType: j(Z()),
        _meta: j(V({}).passthrough())
    }).passthrough()
      , ed = Xc.extend({
        text: Z()
    })
      , Ba = Z().refine(t => {
        try {
            return atob(t),
            !0
        } catch {
            return !1
        }
    }
    , {
        message: "Invalid Base64 string"
    })
      , td = Xc.extend({
        blob: Ba
    })
      , rd = Mn.extend({
        uri: Z(),
        description: j(Z()),
        mimeType: j(Z()),
        _meta: j(V({}).passthrough())
    })
      , Dy = Mn.extend({
        uriTemplate: Z(),
        description: j(Z()),
        mimeType: j(Z()),
        _meta: j(V({}).passthrough())
    })
      , Ny = ls.extend({
        method: de("resources/list")
    })
      , Ly = cs.extend({
        resources: tt(rd)
    })
      , Uy = ls.extend({
        method: de("resources/templates/list")
    })
      , jy = cs.extend({
        resourceTemplates: tt(Dy)
    })
      , My = gt.extend({
        method: de("resources/read"),
        params: _t.extend({
            uri: Z()
        })
    })
      , Fy = Tt.extend({
        contents: tt(ut([ed, td]))
    })
      , Wy = Gt.extend({
        method: de("notifications/resources/list_changed")
    })
      , qy = gt.extend({
        method: de("resources/subscribe"),
        params: _t.extend({
            uri: Z()
        })
    })
      , Gy = gt.extend({
        method: de("resources/unsubscribe"),
        params: _t.extend({
            uri: Z()
        })
    })
      , By = Gt.extend({
        method: de("notifications/resources/updated"),
        params: jn.extend({
            uri: Z()
        })
    })
      , zy = V({
        name: Z(),
        description: j(Z()),
        required: j(wt())
    }).passthrough()
      , Zy = Mn.extend({
        description: j(Z()),
        arguments: j(tt(zy)),
        _meta: j(V({}).passthrough())
    })
      , Hy = ls.extend({
        method: de("prompts/list")
    })
      , Vy = cs.extend({
        prompts: tt(Zy)
    })
      , Jy = gt.extend({
        method: de("prompts/get"),
        params: _t.extend({
            name: Z(),
            arguments: j(Un(Z()))
        })
    })
      , za = V({
        type: de("text"),
        text: Z(),
        _meta: j(V({}).passthrough())
    }).passthrough()
      , Za = V({
        type: de("image"),
        data: Ba,
        mimeType: Z(),
        _meta: j(V({}).passthrough())
    }).passthrough()
      , Ha = V({
        type: de("audio"),
        data: Ba,
        mimeType: Z(),
        _meta: j(V({}).passthrough())
    }).passthrough()
      , Yy = V({
        type: de("resource"),
        resource: ut([ed, td]),
        _meta: j(V({}).passthrough())
    }).passthrough()
      , Ky = rd.extend({
        type: de("resource_link")
    })
      , nd = ut([za, Za, Ha, Ky, Yy])
      , Qy = V({
        role: or(["user", "assistant"]),
        content: nd
    }).passthrough()
      , Xy = Tt.extend({
        description: j(Z()),
        messages: tt(Qy)
    })
      , ev = Gt.extend({
        method: de("notifications/prompts/list_changed")
    })
      , tv = V({
        title: j(Z()),
        readOnlyHint: j(wt()),
        destructiveHint: j(wt()),
        idempotentHint: j(wt()),
        openWorldHint: j(wt())
    }).passthrough()
      , rv = Mn.extend({
        description: j(Z()),
        inputSchema: V({
            type: de("object"),
            properties: j(V({}).passthrough()),
            required: j(tt(Z()))
        }).passthrough(),
        outputSchema: j(V({
            type: de("object"),
            properties: j(V({}).passthrough()),
            required: j(tt(Z()))
        }).passthrough()),
        annotations: j(tv),
        _meta: j(V({}).passthrough())
    })
      , nv = ls.extend({
        method: de("tools/list")
    })
      , ov = cs.extend({
        tools: tt(rv)
    })
      , od = Tt.extend({
        content: tt(nd).default([]),
        structuredContent: V({}).passthrough().optional(),
        isError: j(wt())
    });
    od.or(Tt.extend({
        toolResult: Ln()
    }));
    const sv = gt.extend({
        method: de("tools/call"),
        params: _t.extend({
            name: Z(),
            arguments: j(Un(Ln()))
        })
    })
      , av = Gt.extend({
        method: de("notifications/tools/list_changed")
    })
      , sd = or(["debug", "info", "notice", "warning", "error", "critical", "alert", "emergency"])
      , iv = gt.extend({
        method: de("logging/setLevel"),
        params: _t.extend({
            level: sd
        })
    })
      , lv = Gt.extend({
        method: de("notifications/message"),
        params: jn.extend({
            level: sd,
            logger: j(Z()),
            data: Ln()
        })
    })
      , cv = V({
        name: Z().optional()
    }).passthrough()
      , dv = V({
        hints: j(tt(cv)),
        costPriority: j(dt().min(0).max(1)),
        speedPriority: j(dt().min(0).max(1)),
        intelligencePriority: j(dt().min(0).max(1))
    }).passthrough()
      , uv = V({
        role: or(["user", "assistant"]),
        content: ut([za, Za, Ha])
    }).passthrough()
      , mv = gt.extend({
        method: de("sampling/createMessage"),
        params: _t.extend({
            messages: tt(uv),
            systemPrompt: j(Z()),
            includeContext: j(or(["none", "thisServer", "allServers"])),
            temperature: j(dt()),
            maxTokens: dt().int(),
            stopSequences: j(tt(Z())),
            metadata: j(V({}).passthrough()),
            modelPreferences: j(dv)
        })
    })
      , pv = Tt.extend({
        model: Z(),
        stopReason: j(or(["endTurn", "stopSequence", "maxTokens"]).or(Z())),
        role: or(["user", "assistant"]),
        content: Sy("type", [za, Za, Ha])
    })
      , hv = V({
        type: de("boolean"),
        title: j(Z()),
        description: j(Z()),
        default: j(wt())
    }).passthrough()
      , gv = V({
        type: de("string"),
        title: j(Z()),
        description: j(Z()),
        minLength: j(dt()),
        maxLength: j(dt()),
        format: j(or(["email", "uri", "date", "date-time"]))
    }).passthrough()
      , fv = V({
        type: or(["number", "integer"]),
        title: j(Z()),
        description: j(Z()),
        minimum: j(dt()),
        maximum: j(dt())
    }).passthrough()
      , yv = V({
        type: de("string"),
        title: j(Z()),
        description: j(Z()),
        enum: tt(Z()),
        enumNames: j(tt(Z()))
    }).passthrough()
      , vv = ut([hv, gv, fv, yv])
      , wv = gt.extend({
        method: de("elicitation/create"),
        params: _t.extend({
            message: Z(),
            requestedSchema: V({
                type: de("object"),
                properties: Un(Z(), vv),
                required: j(tt(Z()))
            }).passthrough()
        })
    })
      , bv = Tt.extend({
        action: or(["accept", "decline", "cancel"]),
        content: j(Un(Z(), Ln()))
    })
      , Sv = V({
        type: de("ref/resource"),
        uri: Z()
    }).passthrough()
      , Ev = V({
        type: de("ref/prompt"),
        name: Z()
    }).passthrough()
      , xv = gt.extend({
        method: de("completion/complete"),
        params: _t.extend({
            ref: ut([Ev, Sv]),
            argument: V({
                name: Z(),
                value: Z()
            }).passthrough(),
            context: j(V({
                arguments: j(Un(Z(), Z()))
            }))
        })
    })
      , _v = Tt.extend({
        completion: V({
            values: tt(Z()).max(100),
            total: j(dt().int()),
            hasMore: j(wt())
        }).passthrough()
    })
      , Tv = V({
        uri: Z().startsWith("file://"),
        name: j(Z()),
        _meta: j(V({}).passthrough())
    }).passthrough()
      , Pv = gt.extend({
        method: de("roots/list")
    })
      , kv = Tt.extend({
        roots: tt(Tv)
    })
      , Iv = Gt.extend({
        method: de("notifications/roots/list_changed")
    });
    ut([Kc, Cy, xv, iv, Jy, Hy, Ny, Uy, My, qy, Gy, sv, nv]),
    ut([Jc, Qc, Ry, Iv]),
    ut([Vc, pv, bv, kv]),
    ut([Kc, mv, wv, Pv]),
    ut([Jc, Qc, lv, By, Wy, av, ev]),
    ut([Vc, Ay, _v, Xy, Vy, Ly, jy, Fy, od, ov]);
    var ad, ds, id, Xr, sr, us, en;
    (function(t) {
        t.POST_MESSAGE = "postMessage"
    }
    )(ad || (ad = {})),
    function(t) {
        t.POST_MESSAGE = "postMessage"
    }(ds || (ds = {})),
    function(t) {
        t.STREAMABLE_HTTP = "streamableHttp",
        t.SSE = "sse"
    }(id || (id = {})),
    function(t) {
        t.LOCAL = "local",
        t.REMOTE = "remote"
    }(Xr || (Xr = {})),
    function(t) {
        t.SDK_ANGIE_READY_PING = "sdk-angie-ready-ping",
        t.SDK_ANGIE_REFRESH_PING = "sdk-angie-refresh-ping",
        t.SDK_REQUEST_CLIENT_CREATION = "sdk-request-client-creation",
        t.SDK_REQUEST_INIT_SERVER = "sdk-request-init-server",
        t.SDK_TRIGGER_ANGIE = "sdk-trigger-angie",
        t.SDK_TRIGGER_ANGIE_RESPONSE = "sdk-trigger-angie-response"
    }(sr || (sr = {})),
    function(t) {
        t.SET = "ANGIE_SET_LOCALSTORAGE",
        t.GET = "ANGIE_GET_LOCALSTORAGE"
    }(us || (us = {})),
    function(t) {
        t.RESET_HASH = "reset-hash",
        t.HOST_READY = "host/ready",
        t.ANGIE_LOADED = "angie/loaded",
        t.ANGIE_READY = "angie/ready"
    }(en || (en = {}));
    class Cv {
        constructor() {
            Ae(this, "isAngieReady", !1);
            Ae(this, "readyPromise");
            Ae(this, "readyResolve");
            if (this.readyPromise = new Promise(o => {
                this.readyResolve = o
            }
            ),
            typeof window > "u")
                return;
            let e = 0;
            const r = () => {
                if (this.isAngieReady || e >= 500)
                    return void (!this.isAngieReady && e >= 500 && this.handleDetectionTimeout());
                const o = new MessageChannel;
                o.port1.onmessage = s => {
                    this.handleAngieReady(s.data),
                    o.port1.close(),
                    o.port2.close()
                }
                ;
                const n = {
                    type: sr.SDK_ANGIE_READY_PING,
                    timestamp: Date.now()
                };
                window.postMessage(n, window.location.origin, [o.port2]),
                e++,
                setTimeout(r, 500)
            }
            ;
            r()
        }
        handleAngieReady(e) {
            this.isAngieReady = !0;
            const r = {
                isReady: !0,
                version: e.version,
                capabilities: e.capabilities
            };
            this.readyResolve && this.readyResolve(r)
        }
        handleDetectionTimeout() {
            this.readyResolve && this.readyResolve({
                isReady: !1
            }),
            console.warn("AngieMcpSdk: AngieDetector: Detection timeout - Angie may not be available")
        }
        isReady() {
            return this.isAngieReady
        }
        async waitForReady() {
            return this.readyPromise
        }
    }
    class $v {
        constructor() {
            Ae(this, "queue", []);
            Ae(this, "isProcessing", !1)
        }
        add(e) {
            const r = {
                id: this.generateId(e),
                config: e,
                timestamp: Date.now(),
                status: "pending"
            };
            return this.queue.push(r),
            console.log(`RegistrationQueue: Added server "${e.name}" to queue`),
            r
        }
        getAll() {
            return [...this.queue]
        }
        getPending() {
            return this.queue.filter(e => e.status === "pending")
        }
        updateStatus(e, r, o) {
            const n = this.queue.find(s => s.id === e);
            n && (n.status = r,
            o ? n.error = o : r !== "pending" && r !== "registered" || delete n.error,
            console.log(`RegistrationQueue: Updated server ${e} status to ${r}`))
        }
        async processQueue(e) {
            if (this.isProcessing)
                return void console.log("RegistrationQueue: Already processing queue");
            this.isProcessing = !0;
            const r = this.getPending();
            console.log(`RegistrationQueue: Processing ${r.length} pending registrations`);
            try {
                for (const o of r)
                    try {
                        await e(o),
                        this.updateStatus(o.id, "registered")
                    } catch (n) {
                        const s = n instanceof Error ? n.message : String(n);
                        this.updateStatus(o.id, "failed", s),
                        console.error(`RegistrationQueue: Failed to process registration ${o.id}:`, s)
                    }
            } finally {
                this.isProcessing = !1
            }
        }
        clear() {
            this.queue = [],
            console.log("RegistrationQueue: Cleared all registrations")
        }
        resetAllToPending() {
            if (this.isProcessing)
                return console.log("RegistrationQueue: Cannot reset to pending - processing in progress"),
                !1;
            const e = this.queue.filter(o => o.status === "registered").length
              , r = this.queue.filter(o => o.status === "failed").length;
            return this.queue.forEach(o => {
                o.status !== "pending" && (o.status = "pending",
                delete o.error)
            }
            ),
            console.log(`RegistrationQueue: Reset ${e + r} registrations to pending`),
            !0
        }
        remove(e) {
            const r = this.queue.findIndex(o => o.id === e);
            return r !== -1 && (this.queue.splice(r, 1),
            console.log(`RegistrationQueue: Removed registration ${e}`),
            !0)
        }
        generateId(e) {
            return `reg_${e.name}_${e.version}_${Date.now()}`
        }
    }
    class Av {
        async requestClientCreation(e) {
            const {config: r} = e
              , o = {
                serverId: e.id,
                serverName: r.name,
                serverVersion: r.version,
                description: r.description,
                transport: r.transport || ds.POST_MESSAGE,
                capabilities: r.capabilities,
                instanceId: e.instanceId
            };
            return "type"in r && r.type === "remote" && (o.remote = {
                url: r.url
            }),
            new Promise( (n, s) => {
                const i = new MessageChannel
                  , l = setTimeout( () => {
                    s(new Error("Client creation request timed out after 15000ms"))
                }
                , 15e3);
                i.port1.onmessage = u => {
                    clearTimeout(l),
                    n(u.data)
                }
                ;
                const d = {
                    type: sr.SDK_REQUEST_CLIENT_CREATION,
                    payload: o,
                    timestamp: Date.now()
                };
                window.postMessage(d, window.location.origin, [i.port2])
            }
            )
        }
    }
    class Va {
        constructor(e, r) {
            Ae(this, "sessionId");
            Ae(this, "onmessage");
            Ae(this, "onerror");
            Ae(this, "onclose");
            Ae(this, "_port");
            Ae(this, "_started", !1);
            Ae(this, "_closed", !1);
            if (!e)
                throw new Error("MessagePort is required");
            this._port = e,
            this.sessionId = r || this.generateId(),
            this._port.onmessage = o => {
                var n, s;
                try {
                    const i = ky.parse(o.data);
                    (n = this.onmessage) == null || n.call(this, i)
                } catch (i) {
                    const l = new Error(`Failed to parse message: ${i}`);
                    (s = this.onerror) == null || s.call(this, l)
                }
            }
            ,
            this._port.onmessageerror = o => {
                var s;
                const n = new Error(`MessagePort error: ${JSON.stringify(o)}`);
                (s = this.onerror) == null || s.call(this, n)
            }
        }
        static generateSessionId() {
            return typeof crypto < "u" && typeof crypto.randomUUID == "function" ? crypto.randomUUID() : `${Date.now().toString(36)}-${Math.random().toString(36).substring(2, 10)}`
        }
        async start() {
            if (this._started)
                throw new Error("BrowserContextTransport already started! If using Client or Server class, note that connect() calls start() automatically.");
            if (this._closed)
                throw new Error("Cannot start a closed BrowserContextTransport");
            this._started = !0,
            this._port.start()
        }
        async send(e) {
            if (this._closed)
                throw new Error("Cannot send on a closed BrowserContextTransport");
            return new Promise( (r, o) => {
                var n;
                try {
                    this._port.postMessage(e),
                    r()
                } catch (s) {
                    const i = s instanceof Error ? s : new Error(String(s));
                    (n = this.onerror) == null || n.call(this, i),
                    o(i)
                }
            }
            )
        }
        async close() {
            var e;
            this._closed || (this._closed = !0,
            this._port.close(),
            (e = this.onclose) == null || e.call(this))
        }
        generateId() {
            return Va.generateSessionId()
        }
    }
    let ms = null;
    const tn = () => (ms && document.contains(ms) || (ms = document.querySelector('iframe[src*="angie/"]')),
    ms)
      , ps = (t, e) => {
        console.log("postMessageToAngieIframe", t, e);
        const r = tn();
        if (!(r != null && r.contentWindow))
            return !1;
        const o = e || ( () => {
            const n = tn();
            if (!n)
                return null;
            try {
                return new URL(n.src).origin
            } catch (s) {
                return console.error("Error parsing iframe URL:", s),
                null
            }
        }
        )();
        return o ? (r.contentWindow.postMessage(t, o),
        !0) : (console.error("Could not determine target origin for Angie iframe"),
        !1)
    }
    ;
    let Ja = !1;
    const Fn = "open"
      , Ya = "closed";
    function ld() {
        if (typeof window > "u")
            return 370;
        try {
            const t = window.localStorage.getItem("angie_sidebar_width");
            if (t) {
                const e = parseInt(t, 10);
                if (e >= 350 && e <= 590)
                    return e
            }
        } catch {
            console.warn("localStorage not available")
        }
        return 370
    }
    function Ka() {
        return typeof window > "u" ? null : localStorage.getItem("angie_sidebar_state")
    }
    function Rv(t) {
        try {
            localStorage.setItem("angie_sidebar_width", t.toString())
        } catch {
            console.warn("localStorage not available")
        }
    }
    function cd(t) {
        document.documentElement.style.setProperty("--angie-sidebar-width", `${t}px`)
    }
    function Ov() {
        (function() {
            const t = new URLSearchParams(window.location.search);
            return t.has("start-oauth") || t.has("oauth_code") || t.has("oauth_state") || t.has("oauth_error")
        }
        )() ? function() {
            dd(Ya);
            try {
                localStorage.setItem("angie_sidebar_state", Ya)
            } catch {
                console.warn("localStorage not available")
            }
        }() : dd(Ka() || Fn)
    }
    function dd(t) {
        typeof window < "u" && window.toggleAngieSidebar && window.toggleAngieSidebar(t === Fn, !0)
    }
    function Dv() {
        const t = document.getElementById("angie-sidebar-container");
        if (!t)
            return;
        let e = !1
          , r = 0
          , o = 0;
        t.addEventListener("mousedown", n => {
            const s = t.getBoundingClientRect();
            (document.documentElement.dir === "rtl" ? n.clientX <= s.left + 4 : n.clientX >= s.right - 4) && (e = !0,
            r = n.clientX,
            o = s.width,
            t.classList.add("angie-resizing"),
            document.body.style.cursor = "ew-resize",
            document.body.style.userSelect = "none",
            n.preventDefault(),
            n.stopPropagation())
        }
        ),
        document.addEventListener("mousemove", n => {
            if (!e)
                return;
            let s;
            s = document.documentElement.dir === "rtl" ? r - n.clientX : n.clientX - r,
            cd(Math.max(350, Math.min(590, o + s))),
            n.preventDefault(),
            n.stopPropagation()
        }
        ),
        document.addEventListener("mouseup", n => {
            if (e) {
                e = !1,
                t.classList.remove("angie-resizing"),
                document.body.style.cursor = "",
                document.body.style.userSelect = "";
                const s = parseInt(getComputedStyle(document.documentElement).getPropertyValue("--angie-sidebar-width"), 10);
                Rv(s),
                ps({
                    type: ot.ANGIE_SIDEBAR_RESIZED,
                    payload: {
                        initialWidth: o,
                        width: s
                    }
                }),
                n.preventDefault(),
                n.stopPropagation()
            }
        }
        ),
        cd(ld())
    }
    function ud(t) {
        (function() {
            if (typeof document > "u" || Ja)
                return;
            const e = "angie-sidebar-styles";
            if (document.getElementById(e))
                return void (Ja = !0);
            const r = document.createElement("style");
            r.id = e,
            r.textContent = `/* Angie Sidebar - CSS Variables */
:root {
    --angie-sidebar-z-index: 1200; /* below MUI popups, elementor popups and media library modal */
    --angie-sidebar-width: 330px;
    --angie-sidebar-transition: margin 0.3s ease-in-out, transform 0.3s ease-in-out;
    /* Direction-aware transform values for sidebar positioning */
    --angie-sidebar-hide-transform: translateX(-100%); /* LTR: hide to the left */
    --angie-sidebar-show-transform: translateX(0);
}

/* RTL-specific transform values */
[dir="rtl"] {
    --angie-sidebar-hide-transform: translateX(100%); /* RTL: hide to the right */
}

/* Respect user's motion preferences */
@media (prefers-reduced-motion: reduce) {
    :root {
        --angie-sidebar-transition: none;
    }
}

/* Apply transitions only when user is actively toggling */
body.angie-sidebar-transitioning {
    transition: var(--angie-sidebar-transition) !important;
}

body.angie-sidebar-transitioning #angie-sidebar-container {
    transition: var(--angie-sidebar-transition) !important;
}

/* LTR Layout (default) - Push content to the right */
@media (min-width: 768px) {
    body.angie-sidebar-active {
        padding-inline-start: var(--angie-sidebar-width) !important;
    }

    body.angie-sidebar-active #angie-body-top-padding {
        width: 100%;
        height: 8px;
    }

    /* Push WordPress Admin Bar - LTR */
    body.angie-sidebar-active #wpadminbar {
        inset-inline-start: var(--angie-sidebar-width) !important;
        inset-inline-end: 8px !important;
        width: calc(100% - 8px - var(--angie-sidebar-width)) !important;
        margin-top: 8px;
    }

    /* Sidebar container - LTR */
    #angie-sidebar-container {
        position: fixed;
        top: 0;
        inset-inline-start: 0;
        width: var(--angie-sidebar-width);
        height: 100vh;
        z-index: var(--angie-sidebar-z-index) !important; /* below elementor popups and media library modal */
        background: #FCFCFC;
        transform: var(--angie-sidebar-hide-transform);
        outline: none;
        overflow: hidden;
        /* No default transition - only when transitioning */
    }

    /* Resize handle */
    #angie-sidebar-container::after {
        content: '';
        position: absolute;
        top: 0;
        inset-inline-end: 0;
        width: 4px;
        height: 100%;
        cursor: ew-resize;
        background: transparent;
        z-index: 1000001;
    }

    /* Pink border during resize */
    #angie-sidebar-container.angie-resizing {
        border-inline-end-color: #ff69b4 !important;
        border-inline-end-width: 2px !important;
    }

    /* Disable iframe pointer events during resize */
    #angie-sidebar-container.angie-resizing iframe#angie-iframe {
        pointer-events: none !important;
    }
}

/* Active states */
body.angie-sidebar-active #angie-sidebar-container {
    transform: var(--angie-sidebar-show-transform);
}

/* Studio mode - sidebar takes full width */
@media (min-width: 768px) {
    html.angie-studio-active body.angie-sidebar-active #angie-sidebar-container {
        width: 100%;
    }
}

/* High contrast mode support */
@media (prefers-contrast: high) {
    #angie-sidebar-container {
        border-color: #000;
        box-shadow: none;
    }
}

/* Screen reader only class */
.angie-sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
}

/* Plugin conflict resolution */
body.angie-sidebar-active {
    /* Reset common conflicting styles */
    box-sizing: border-box !important;
    position: relative !important;
}

#angie-sidebar-toggle {
    z-index: 99999 !important;
}
`;
            const o = document.head || document.getElementsByTagName("head")[0];
            o.insertBefore(r, o.firstChild),
            Ja = !0
        }
        )(),
        typeof window < "u" && (window.toggleAngieSidebar = function(e) {
            return function(r, o) {
                const n = document.body
                  , s = document.getElementById("angie-sidebar-container");
                if (!s)
                    return void console.warn("Angie Sidebar: Required elements not found!");
                const i = n.classList.contains("angie-sidebar-active")
                  , l = r !== void 0 ? r : !i;
                o || (n.classList.add("angie-sidebar-transitioning"),
                setTimeout(function() {
                    n.classList.remove("angie-sidebar-transitioning")
                }, 300)),
                l ? n.classList.add("angie-sidebar-active") : n.classList.remove("angie-sidebar-active"),
                l && setTimeout(function() {
                    ps({
                        type: "focusInput"
                    })
                }, o ? 0 : 300),
                e && e(l, s, o),
                function(u) {
                    try {
                        localStorage.setItem("angie_sidebar_state", u)
                    } catch {
                        console.warn("localStorage not available")
                    }
                }(l ? Fn : Ya);
                const d = new CustomEvent("angieSidebarToggle",{
                    detail: {
                        isOpen: l,
                        sidebar: s,
                        skipTransition: o
                    }
                });
                document.dispatchEvent(d),
                ps({
                    type: ot.ANGIE_SIDEBAR_TOGGLED,
                    payload: {
                        state: l ? "opened" : "closed"
                    }
                })
            }
        }(t),
        window.addEventListener("message", function(e) {
            if (e.data && e.data.type === "toggleAngieSidebar") {
                const {force: r, skipTransition: o} = e.data.payload || {};
                window.toggleAngieSidebar && window.toggleAngieSidebar(r, o)
            }
        }))
    }
    const md = (t, e) => {
        const r = document.getElementById("angie-sidebar-container");
        r && r.setAttribute("aria-hidden", e ? "false" : "true"),
        e ? t.removeAttribute("tabindex") : t.setAttribute("tabindex", "-1")
    }
      , rn = (t, e) => {
        t.postMessage({
            status: "success",
            payload: e
        })
    }
      , Qa = (t, e) => {
        t.postMessage({
            status: "error",
            payload: e
        })
    }
      , Xa = () => new Promise(t => {
        document.readyState === "loading" ? document.addEventListener("DOMContentLoaded", t) : t(null)
    }
    );
    var pd;
    (pd || (pd = {})).POST_MESSAGE = "postMessage";
    const Bt = {
        open: !1,
        iframe: null,
        iframeUrlObject: null
    };
    function hd() {
        const t = new URL(window.location.href);
        t.searchParams.set("start-oauth", "1"),
        console.log("OAuth: Redirecting to wp-admin with OAuth:", t.toString()),
        window.location.href = t.toString()
    }
    const Nv = () => {
        window.addEventListener("message", t => {
            var e;
            if (t.origin === ((e = Bt.iframeUrlObject) == null ? void 0 : e.origin))
                switch (t.data.type) {
                case "OAUTH_GET_CODE_AND_STATE":
                    (r => {
                        const o = new URLSearchParams(window.location.search)
                          , n = o.get("oauth_code")
                          , s = o.get("oauth_state");
                        if (n && s)
                            rn(r, {
                                code: n,
                                state: s
                            });
                        else {
                            const i = o.get("oauth_error");
                            if (i) {
                                Qa(r, {
                                    message: i,
                                    code: n || null,
                                    state: s || null
                                });
                                const l = new URL(window.location.href);
                                l.searchParams.delete("oauth_error"),
                                history.replaceState({}, "", l.toString())
                            } else
                                rn(r, {
                                    message: "No OAuth error found"
                                })
                        }
                    }
                    )(t.ports[0]);
                    break;
                case "OAUTH_GET_TOP_URL":
                    console.log("OAuth: Iframe requested top window URL via MessageChannel"),
                    rn(t.ports[0], {
                        topUrl: window.location.href
                    });
                    break;
                case "OAUTH_REDIRECT_TOP_WINDOW":
                    console.log("OAuth: Iframe requested top window redirect to:", t.data.payload.url),
                    window.location.href = t.data.payload.url;
                    break;
                case "OAUTH_UPDATE_URL":
                    console.log("OAuth: Iframe requested URL update to:", t.data.payload.url),
                    function(r, o) {
                        if (!(history != null && history.replaceState))
                            return console.warn("history.replaceState not supported in this browser"),
                            void Qa(o, {
                                message: "URL update not supported in this browser"
                            });
                        try {
                            const n = window.location.href;
                            history.replaceState({}, "", r),
                            function(s, i) {
                                const l = new URL(i)
                                  , d = new URL(s)
                                  , u = l.searchParams
                                  , g = d.searchParams
                                  , c = ["oauth_code", "oauth_state", "start-oauth"];
                                return c.some(m => g == null ? void 0 : g.has(m)) && !c.some(m => u == null ? void 0 : u.has(m))
                            }(n, r) && function() {
                                console.log("OAuth parameters cleaned, opening sidebar");
                                try {
                                    localStorage.setItem("angie_sidebar_state", "open")
                                } catch {
                                    console.warn("localStorage not available")
                                }
                                setTimeout( () => {
                                    window.toggleAngieSidebar(!0)
                                }
                                , 500)
                            }(),
                            rn(o, {
                                message: "URL updated successfully"
                            })
                        } catch (n) {
                            console.warn("Failed to update URL via history.replaceState:", n),
                            Qa(o, {
                                message: "URL update failed: " + (n instanceof Error ? n.message : "Unknown error")
                            })
                        }
                    }(t.data.payload.url, t.ports[0]);
                    break;
                case "ANGIE_REDIRECT_TO_WP_ADMIN_WITH_OAUTH":
                    hd();
                    break;
                case "ANGIE_REDIRECT_TO_AUTH_ORIGIN_LOGOUT":
                    try {
                        hd()
                    } catch (r) {
                        console.error("OAuth: Auth origin logout fallback failed:", r),
                        window.location.reload()
                    }
                }
        }
        )
    }
    ;
    var ot;
    (function(t) {
        t.SDK_ANGIE_ALL_SERVERS_REGISTERED = "sdk-angie-all-servers-registered",
        t.SDK_ANGIE_READY_PING = "sdk-angie-ready-ping",
        t.SDK_REQUEST_CLIENT_CREATION = "sdk-request-client-creation",
        t.SDK_TRIGGER_ANGIE = "sdk-trigger-angie",
        t.SDK_TRIGGER_ANGIE_RESPONSE = "sdk-trigger-angie-response",
        t.ANGIE_SIDEBAR_RESIZED = "angie-sidebar-resized",
        t.ANGIE_SIDEBAR_TOGGLED = "angie-sidebar-toggled",
        t.ANGIE_CHAT_TOGGLE = "angie-chat-toggle",
        t.ANGIE_STUDIO_TOGGLE = "angie-studio-toggle",
        t.ANGIE_NAVIGATE_TO_URL = "angie/navigate-to-url",
        t.ANGIE_PAGE_RELOAD = "angie/page-reload"
    }
    )(ot || (ot = {}));
    class gd {
        constructor() {
            Ae(this, "angieDetector");
            Ae(this, "registrationQueue");
            Ae(this, "clientManager");
            Ae(this, "isInitialized", !1);
            Ae(this, "instanceId");
            this.instanceId = Math.random().toString(36).substring(2, 8),
            console.log(`AngieMcpSdk: Constructor called - initializing SDK (Instance: ${this.instanceId})`),
            this.angieDetector = new Cv,
            this.registrationQueue = new $v,
            this.clientManager = new Av,
            console.log(`AngieMcpSdk: Setting up event handlers (Instance: ${this.instanceId})`),
            this.setupAngieReadyHandler(),
            this.setupServerInitHandler(),
            this.setupReRegistrationHandler(),
            console.log(`AngieMcpSdk: SDK initialization complete (Instance: ${this.instanceId})`)
        }
        async loadSidebar(e) {
            ud(),
            await (async r => {
                if (window.screen.availWidth <= 768)
                    return void console.log("Angie: Mobile detected, skipping iframe injection");
                let o = document.getElementById("angie-sidebar-container");
                if (!o) {
                    const i = performance.now();
                    if (console.log(" Waiting for sidebar container..."),
                    await new Promise(l => {
                        let d = 0;
                        const u = setInterval( () => {
                            o = document.getElementById("angie-sidebar-container"),
                            d++,
                            (o || d > 20) && (clearInterval(u),
                            o && l())
                        }
                        , 100);
                        setTimeout( () => {
                            if (clearInterval(u),
                            o)
                                return void l();
                            const g = new MutationObserver( () => {
                                o = document.getElementById("angie-sidebar-container"),
                                o && (g.disconnect(),
                                l())
                            }
                            );
                            g.observe(document.body, {
                                childList: !0,
                                subtree: !0
                            }),
                            setTimeout( () => {
                                g.disconnect(),
                                l()
                            }
                            , 8e3)
                        }
                        , 2e3)
                    }
                    ),
                    console.log(` Sidebar container detection took: ${(performance.now() - i).toFixed(2)}ms`),
                    !o)
                        return void console.error("Angie: Sidebar container not found")
                }
                const {iframe: n, iframeUrlObject: s} = await (async i => {
                    const l = i.origin
                      , d = new URL(i.path,l)
                      , u = d.pathname.slice(1).replace(/\//, "--") + "-" + Math.random().toString(36).substring(7);
                    return new Promise(g => {
                        const c = new URL(l);
                        c.pathname = d.pathname;
                        const m = window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
                        if (c.searchParams.append("colorScheme", i.uiTheme || m || "light"),
                        c.searchParams.append("sdkVersion", i.sdkVersion),
                        c.searchParams.append("instanceId", u),
                        c.searchParams.append("origin", window.location.origin),
                        i.isRTL && c.searchParams.append("isRTL", i.isRTL ? "true" : "false"),
                        window.location.hostname === "localhost" && window.location.search.includes("debug_error")) {
                            const y = new URLSearchParams(window.location.search).get("debug_error");
                            y && c.searchParams.append("debug_error", y)
                        }
                        d.searchParams.forEach( (y, b) => {
                            c.searchParams.set(b, y)
                        }
                        ),
                        c.searchParams.set("ver", new Date().getTime().toString());
                        const p = i.parent || document
                          , h = p.createElement("iframe")
                          , f = {
                            "background-color": "transparent",
                            "color-scheme": "normal",
                            ...i.css
                        };
                        window.addEventListener("message", async y => {
                            var b;
                            if (y.origin === c.origin)
                                switch (y.data.type) {
                                case en.ANGIE_READY:
                                    g({
                                        iframe: h,
                                        iframeUrlObject: c
                                    });
                                    break;
                                case en.ANGIE_LOADED:
                                    (b = h.contentWindow) == null || b.postMessage({
                                        type: en.HOST_READY,
                                        instanceId: u
                                    }, c.origin)
                                }
                        }
                        ),
                        h.setAttribute("src", c.href),
                        h.id = "angie-iframe",
                        h.setAttribute("frameborder", "0"),
                        h.setAttribute("scrolling", "no"),
                        h.setAttribute("style", Object.entries(f).map( ([y,b]) => `${y}: ${b}`).join("; ")),
                        h.setAttribute("allow", "clipboard-write; clipboard-read"),
                        i.insertCallback ? i.insertCallback(h) : p.body.appendChild(h)
                    }
                    )
                }
                )({
                    origin: r.origin || "https://angie.elementor.com",
                    path: "angie/wp-admin",
                    insertCallback: i => {
                        console.log("Injecting Angie iframe into sidebar container"),
                        i.setAttribute("title", "Angie AI Assistant"),
                        i.setAttribute("role", "application"),
                        i.setAttribute("aria-label", "Angie AI Assistant Interface");
                        const l = document.getElementById("angie-sidebar-loading");
                        l && (l.textContent = ""),
                        o == null || o.appendChild(i),
                        md(i, !0),
                        i.addEventListener("load", () => {
                            i.focus()
                        }
                        )
                    }
                    ,
                    css: {
                        width: "100%",
                        height: "100%",
                        border: "none",
                        outline: "none"
                    },
                    uiTheme: r.uiTheme,
                    isRTL: r.isRTL,
                    sdkVersion: "1.0.3"
                });
                Bt.iframe = n,
                Bt.iframeUrlObject = s,
                window.addEventListener("message", i => {
                    var l;
                    if (i.origin === ((l = Bt.iframeUrlObject) == null ? void 0 : l.origin))
                        switch (i.data.type) {
                        case us.SET:
                            window.localStorage.setItem(i.data.key, i.data.value);
                            break;
                        case us.GET:
                            const d = i.ports[0]
                              , u = window.localStorage.getItem(i.data.key);
                            d.postMessage({
                                value: u
                            })
                        }
                }
                ),
                (i => {
                    window.addEventListener("message", async l => {
                        var g, c, m, p, h, f, y;
                        const d = l.origin === window.location.origin
                          , u = l.origin === ((g = i.iframeUrlObject) == null ? void 0 : g.origin);
                        if (d || u)
                            switch ((c = l == null ? void 0 : l.data) == null ? void 0 : c.type) {
                            case ot.SDK_ANGIE_ALL_SERVERS_REGISTERED:
                                break;
                            case ot.SDK_ANGIE_READY_PING:
                                const b = l.ports[0];
                                console.log("Angie is ready", l),
                                rn(b, {
                                    message: "Angie is ready"
                                });
                                break;
                            case ot.SDK_REQUEST_CLIENT_CREATION:
                                const x = l.data.payload;
                                try {
                                    const v = l.ports[0]
                                      , S = new MessageChannel;
                                    S.port1.onmessage = _ => {
                                        v.postMessage({
                                            success: !0,
                                            data: _.data
                                        })
                                    }
                                    ;
                                    const w = {
                                        type: ot.SDK_REQUEST_CLIENT_CREATION,
                                        payload: {
                                            success: !0,
                                            ...x,
                                            clientId: `dynamic-client-${x.serverName}-${x.serverVersion}-${Date.now()}`,
                                            requestId: l.data.payload.requestId
                                        },
                                        timestamp: Date.now()
                                    };
                                    if (!i.iframe)
                                        throw new Error("Iframe not found");
                                    (p = i.iframe.contentWindow) == null || p.postMessage(w, ((m = i.iframeUrlObject) == null ? void 0 : m.origin) || "", [S.port2])
                                } catch (v) {
                                    console.error(`AngieMcpSdk:Failed to create client for SDK server "${x.serverName}":`, v)
                                }
                                break;
                            case ot.SDK_TRIGGER_ANGIE:
                                console.log("SDK Trigger Angie received", l.data);
                                try {
                                    const {requestId: v, prompt: S, context: w} = l.data.payload;
                                    if (!i.iframe)
                                        throw new Error("Iframe not found");
                                    (f = i.iframe.contentWindow) == null || f.postMessage({
                                        type: ot.SDK_TRIGGER_ANGIE,
                                        payload: {
                                            requestId: v,
                                            prompt: S,
                                            context: w
                                        }
                                    }, ((h = i.iframeUrlObject) == null ? void 0 : h.origin) || ""),
                                    window.postMessage({
                                        type: ot.SDK_TRIGGER_ANGIE_RESPONSE,
                                        payload: {
                                            success: !0,
                                            requestId: v,
                                            response: "Angie triggered successfully"
                                        }
                                    }, window.location.origin)
                                } catch (v) {
                                    console.error("Failed to trigger Angie:", v),
                                    window.postMessage({
                                        type: ot.SDK_TRIGGER_ANGIE_RESPONSE,
                                        payload: {
                                            success: !1,
                                            requestId: (y = l.data.payload) == null ? void 0 : y.requestId,
                                            error: v instanceof Error ? v.message : "Unknown error"
                                        }
                                    }, window.location.origin)
                                }
                            }
                    }
                    )
                }
                )(Bt),
                Nv(),
                window.addEventListener("message", async i => {
                    var l, d, u, g, c;
                    if (((l = i == null ? void 0 : i.data) == null ? void 0 : l.type) === ot.ANGIE_CHAT_TOGGLE)
                        Bt.open = i.data.open,
                        Bt.iframe && md(Bt.iframe, Bt.open);
                    else if (((d = i == null ? void 0 : i.data) == null ? void 0 : d.type) === ot.ANGIE_STUDIO_TOGGLE) {
                        const m = i.data.isStudioOpen;
                        if (!Bt.iframe)
                            return;
                        if (m)
                            document.documentElement.classList.add("angie-studio-active");
                        else {
                            const p = ld();
                            document.documentElement.style.setProperty("--angie-sidebar-width", `${p}px`),
                            document.documentElement.classList.remove("angie-studio-active")
                        }
                    } else if (((u = i == null ? void 0 : i.data) == null ? void 0 : u.type) === ot.ANGIE_NAVIGATE_TO_URL) {
                        const {url: m} = i.data;
                        window.location.assign(m)
                    } else
                        ((g = i == null ? void 0 : i.data) == null ? void 0 : g.type) === ot.ANGIE_PAGE_RELOAD ? (console.log("Angie requested page reload - database operations completed"),
                        window.location.reload()) : ((c = i == null ? void 0 : i.data) == null ? void 0 : c.type) === en.RESET_HASH && (window.location.hash = "",
                        rn(i.ports[0], {
                            message: "Hash reset successfully"
                        }))
                }
                )
            }
            )({
                origin: (e == null ? void 0 : e.origin) || "https://angie.elementor.com",
                uiTheme: (e == null ? void 0 : e.uiTheme) || "light",
                isRTL: (e == null ? void 0 : e.isRTL) || !1,
                ...e
            }),
            this.setupPromptHashDetection()
        }
        setupReRegistrationHandler() {
            window.addEventListener("message", e => {
                var r;
                if (((r = e.data) == null ? void 0 : r.type) === sr.SDK_ANGIE_REFRESH_PING)
                    if (console.log(`AngieMcpSdk: Angie refresh ping received (Instance: ${this.instanceId})`),
                    this.registrationQueue.resetAllToPending()) {
                        const o = this.registrationQueue.getPending().length;
                        console.log(`AngieMcpSdk: Successfully reset ${o} registrations, processing queue (Instance: ${this.instanceId})`),
                        this.handleAngieReady()
                    } else
                        console.log(`AngieMcpSdk: Skipping queue reset - processing already in progress (Instance: ${this.instanceId})`)
            }
            )
        }
        setupAngieReadyHandler() {
            this.angieDetector.waitForReady().then(e => {
                e.isReady ? this.handleAngieReady() : console.warn("AngieMcpSdk: Angie not detected - servers will remain queued")
            }
            ).catch(e => {
                console.error("AngieMcpSdk: Error waiting for Angie:", e)
            }
            )
        }
        async handleAngieReady() {
            console.log(`AngieMcpSdk: Angie is ready, processing queued registrations (Instance: ${this.instanceId})`);
            try {
                await this.registrationQueue.processQueue(async e => {
                    console.log(`AngieMcpSdk: processQueue callback called for "${e.config.name}" (Instance: ${this.instanceId})`),
                    await this.processRegistration(e)
                }
                ),
                this.isInitialized = !0,
                console.log(`AngieMcpSdk: Initialization complete (Instance: ${this.instanceId})`)
            } catch (e) {
                console.error(`AngieMcpSdk: Error processing registration queue (Instance: ${this.instanceId}):`, e)
            }
        }
        async processRegistration(e) {
            console.log(`AngieMcpSdk: Processing registration for server "${e.config.name}" (ID: ${e.id}) (Instance: ${this.instanceId})`);
            try {
                console.log(`AngieMcpSdk: Calling clientManager.requestClientCreation for "${e.config.name}" (Instance: ${this.instanceId})`);
                const r = {
                    ...e,
                    instanceId: this.instanceId
                };
                await this.clientManager.requestClientCreation(r),
                console.log(`AngieMcpSdk: Successfully registered server "${e.config.name}" (Instance: ${this.instanceId})`)
            } catch (r) {
                throw console.error(`AngieMcpSdk: Failed to register server "${e.config.name}" (Instance: ${this.instanceId}):`, r),
                r
            }
        }
        registerLocalServer(e) {
            return e.type = Xr.LOCAL,
            e.transport = ds.POST_MESSAGE,
            this.registerServer(e)
        }
        registerRemoteServer(e) {
            return e.type = Xr.REMOTE,
            this.registerServer(e)
        }
        isLocalServerConfig(e) {
            return e.type === Xr.LOCAL || !e.type && "server"in e
        }
        isRemoteServerConfig(e) {
            return e.type === Xr.REMOTE && "url"in e
        }
        async registerServer(e) {
            if (!e.type)
                return console.warn("AngieMcpSdk: for a local server, please use registerLocalServer instead of registerServer"),
                void this.registerLocalServer(e);
            if (console.log(`AngieMcpSdk: registerServer called for "${e.name}" (Instance: ${this.instanceId})`),
            !e.name)
                throw new Error("Server name is required");
            if (!e.description)
                throw new Error("Server description is required");
            if (this.isLocalServerConfig(e) && !e.server)
                throw new Error("Server instance is required for local servers");
            console.log(`AngieMcpSdk: Registering server "${e.name}" (Instance: ${this.instanceId})`);
            const r = this.registrationQueue.add(e);
            if (console.log(`AngieMcpSdk: Added registration to queue: ${r.id} (Instance: ${this.instanceId})`),
            this.angieDetector.isReady())
                try {
                    await this.processRegistration(r),
                    this.registrationQueue.updateStatus(r.id, "registered"),
                    console.log(`AngieMcpSdk: Server "${e.name}" registered successfully (Instance: ${this.instanceId})`)
                } catch (o) {
                    const n = o instanceof Error ? o.message : String(o);
                    throw this.registrationQueue.updateStatus(r.id, "failed", n),
                    o
                }
            else
                console.log(`AngieMcpSdk: Server "${e.name}" queued until Angie is ready (Instance: ${this.instanceId})`)
        }
        getRegistrations() {
            return this.registrationQueue.getAll()
        }
        getPendingRegistrations() {
            return this.registrationQueue.getPending()
        }
        isAngieReady() {
            return this.angieDetector.isReady()
        }
        isReady() {
            return this.isInitialized
        }
        async waitForReady() {
            if (!(await this.angieDetector.waitForReady()).isReady)
                throw new Error("Angie is not available");
            for (; !this.isInitialized; )
                await new Promise(e => setTimeout(e, 100))
        }
        async triggerAngie(e) {
            var n;
            if (!this.isAngieReady())
                throw new Error("Angie is not ready. Please wait for Angie to be available before triggering.");
            const r = this.generateRequestId()
              , o = ((n = e.options) == null ? void 0 : n.timeout) || 3e4;
            return new Promise( (s, i) => {
                const l = setTimeout( () => {
                    i(new Error("Angie trigger request timed out"))
                }
                , o)
                  , d = g => {
                    var c, m, p;
                    ((c = g.data) == null ? void 0 : c.type) === sr.SDK_TRIGGER_ANGIE_RESPONSE && ((p = (m = g.data) == null ? void 0 : m.payload) == null ? void 0 : p.requestId) === r && (clearTimeout(l),
                    window.removeEventListener("message", d),
                    s(g.data.payload))
                }
                ;
                window.addEventListener("message", d);
                const u = {
                    type: sr.SDK_TRIGGER_ANGIE,
                    payload: {
                        requestId: r,
                        prompt: e.prompt,
                        options: e.options,
                        context: {
                            pageUrl: window.location.href,
                            pageTitle: document.title,
                            ...e.context
                        }
                    },
                    timestamp: Date.now()
                };
                console.log(`AngieMcpSdk: Triggering Angie with prompt (Request ID: ${r}, Instance: ${this.instanceId})`),
                window.postMessage(u, window.location.origin)
            }
            )
        }
        destroy() {
            this.registrationQueue.clear(),
            console.log(`AngieMcpSdk: SDK destroyed (Instance: ${this.instanceId})`)
        }
        setupServerInitHandler() {
            window.addEventListener("message", e => {
                var r;
                ((r = e.data) == null ? void 0 : r.type) === sr.SDK_REQUEST_INIT_SERVER && (console.log(`AngieMcpSdk: Server init request received (Instance: ${this.instanceId})`),
                this.handleServerInitRequest(e))
            }
            )
        }
        handleServerInitRequest(e) {
            const {clientId: r, serverId: o, instanceId: n} = e.data.payload || {};
            if (r && o)
                if (console.log(`AngieMcpSdk: Server init request received - Request instanceId: ${n}, This instanceId: ${this.instanceId} (Instance: ${this.instanceId})`),
                n && n !== this.instanceId)
                    console.log(`AngieMcpSdk: Ignoring server init request for different instance. Request instanceId: ${n}, this instanceId: ${this.instanceId}`);
                else {
                    console.log(`AngieMcpSdk: Handling server init request for clientId: ${r}, serverId: ${o} (Instance: ${this.instanceId})`);
                    try {
                        const s = this.registrationQueue.getAll().find(u => u.id === o);
                        if (!s)
                            return void console.error(`AngieMcpSdk: No registration found for serverId: ${o} (Instance: ${this.instanceId})`);
                        if ("type"in s.config && s.config.type === "remote")
                            return void console.log(`AngieMcpSdk: Remote server registration detected; skipping local connect (Instance: ${this.instanceId})`);
                        const i = e.ports[0];
                        if (!i)
                            return void console.error(`AngieMcpSdk: No port provided in server init request (Instance: ${this.instanceId})`);
                        const l = s.config.server
                          , d = new Va(i);
                        l.connect(d),
                        console.log(`AngieMcpSdk: Server "${s.config.name}" initialized successfully (Instance: ${this.instanceId})`)
                    } catch (s) {
                        console.error(`AngieMcpSdk: Error initializing server for clientId ${r} (Instance: ${this.instanceId}):`, s)
                    }
                }
            else
                console.error(`AngieMcpSdk: Invalid server init request - missing clientId or serverId (Instance: ${this.instanceId})`)
        }
        generateRequestId() {
            return `${this.instanceId}-${Date.now()}-${Math.random().toString(36).substring(2, 8)}`
        }
        async handlePromptHash() {
            const e = window.location.hash;
            if (e.startsWith("#angie-prompt="))
                try {
                    const r = e.replace("#angie-prompt=", "")
                      , o = decodeURIComponent(r);
                    if (!o)
                        return void console.warn("AngieMcpSdk: Empty prompt detected in hash");
                    console.log("AngieMcpSdk: Detected prompt in hash:", o),
                    await this.waitForReady();
                    const n = await this.triggerAngie({
                        prompt: o,
                        context: {
                            source: "hash-parameter",
                            pageUrl: window.location.href,
                            timestamp: new Date().toISOString()
                        }
                    });
                    console.log("AngieMcpSdk: Triggered successfully from hash:", n),
                    window.location.hash = ""
                } catch (r) {
                    console.error("AngieMcpSdk: Failed to trigger from hash:", r)
                }
        }
        setupPromptHashDetection() {
            this.handlePromptHash(),
            window.addEventListener("hashchange", () => this.handlePromptHash())
        }
    }
    const Lv = (t, e) => {
        if (tn()) {
            e.isOpen && window.toggleAngieSidebar && window.toggleAngieSidebar(!0);
            const r = ps({
                type: "angie-route-navigation",
                path: t,
                payload: e
            });
            return r || console.error("Failed to post navigation message to Angie iframe"),
            r
        }
        return console.error("Angie iframe not found"),
        !1
    }
    ;
    var fd = (t => (t.INPUT = "input",
    t.TEXTAREA = "textarea",
    t.SELECT = "select",
    t.IFRAME = "iframe",
    t))(fd || {})
      , yd = (t => (t.LABEL = "label",
    t.TABLE_HEADER = "th",
    t.LABEL_CLASS = ".label",
    t))(yd || {})
      , vd = (t => (t.TABLE_ROW = "tr",
    t.FORM_FIELD = ".form-field",
    t.FORM_TABLE_ROW = ".form-table tr",
    t))(vd || {});
    const Uv = ['input:not([type="hidden"])', "textarea", "select", 'iframe[id*="content_ifr"], iframe[id*="editor"]', '[contenteditable="true"]']
      , hs = "[WP Admin Fields Context]"
      , jv = {
        INITIAL_CONTEXT: 500,
        EDITOR_SETUP: 2e3
    };
    async function Mv(t) {
        try {
            let e = null;
            const r = h => {
                const f = document.getElementById("wpbody");
                return !f || !f.contains(h) ? !1 : Object.values(fd).includes(h.tagName.toLowerCase()) || h.contentEditable === "true"
            }
              , o = h => {
                if (h.hidden || h.style.display === "none" || h.style.visibility === "hidden" || h.offsetParent === null)
                    return !1;
                const f = document.getElementById("wpbody");
                let y = h.parentElement;
                for (; y && y !== f; ) {
                    const b = window.getComputedStyle(y);
                    if (b.display === "none" || b.visibility === "hidden" || y.hidden)
                        return !1;
                    y = y.parentElement
                }
                return !0
            }
              , n = h => {
                var y, b;
                let f = h.getAttribute("title") || "";
                if (!f && h.id) {
                    const x = document.querySelector(`label[for="${h.id}"]`);
                    x && (f = ((y = x.textContent) == null ? void 0 : y.trim().replace("Select ", "")) || "")
                }
                if (!f) {
                    const x = Object.values(vd).join(", ")
                      , v = h.closest(x);
                    if (v) {
                        const S = Object.values(yd).join(", ")
                          , w = v.querySelector(S);
                        w && (f = ((b = w.textContent) == null ? void 0 : b.trim()) || "")
                    }
                }
                return f || null
            }
              , s = () => {
                const h = document.getElementById("wpbody");
                if (!h)
                    return [];
                const f = []
                  , y = Uv.join(", ");
                return h.querySelectorAll(y).forEach(x => {
                    const v = x
                      , S = v
                      , w = S.name || v.id || "unknown"
                      , _ = S.type || v.tagName.toLowerCase()
                      , I = n(v)
                      , k = o(v)
                      , C = S.disabled || v.getAttribute("disabled") === "disabled";
                    let L = "";
                    if (S.type === "checkbox" || S.type === "radio")
                        L = S.checked ? S.value || "checked" : "";
                    else if (v.tagName.toLowerCase() === "select") {
                        const R = v;
                        R.multiple && R.selectedOptions ? L = Array.from(R.selectedOptions).map(q => q.value) : L = R.value || ""
                    } else
                        v.contentEditable === "true" ? L = v.textContent || "" : L = S.value || v.textContent || "";
                    const N = v.closest("tr") || v.parentElement || v
                      , A = N == null ? void 0 : N.querySelector("img")
                      , $ = A != null && A.src ? A.src.replace(/-\d+x\d+(\.[^.]+)$/i, "$1") || A.src : null;
                    f.push({
                        name: w,
                        type: _,
                        value: L,
                        label: I,
                        id: v.id || null,
                        imageUrl: $,
                        isVisible: k,
                        isDisabled: C
                    })
                }
                ),
                f.filter(x => x.isVisible)
            }
              , i = () => {
                const h = document.getElementById("wpbody");
                if (!h)
                    return [];
                const f = h.querySelectorAll('input[type="checkbox"]')
                  , y = [];
                return f.forEach(b => {
                    var w;
                    const x = b;
                    if (!o(x) || Wf(x))
                        return;
                    const v = x.name || x.id || "unknown";
                    let S = x.getAttribute("title") || "";
                    if (!S && x.id) {
                        const _ = document.querySelector(`label[for="${x.id}"]`);
                        _ && (S = ((w = _.textContent) == null ? void 0 : w.trim()) || "")
                    }
                    S || (S = v),
                    y.push({
                        name: v,
                        title: S,
                        isChecked: x.checked,
                        id: x.id || null
                    })
                }
                ),
                y
            }
              , l = (h, f, y) => {
                var k;
                const b = h.name || h.id || "unknown"
                  , x = n(h)
                  , v = x || b
                  , S = ((k = _e == null ? void 0 : _e.general) == null ? void 0 : k.displayName) || "WordPress Admin"
                  , w = h.closest("tr") || h.parentElement || h
                  , _ = w == null ? void 0 : w.querySelector("img")
                  , I = _ != null && _.src ? _.src.replace(/-\d+x\d+(\.[^.]+)$/i, "$1") || _.src : null;
                return {
                    displayName: `${S} > ${v}`,
                    data: {
                        selectedField: {
                            name: b,
                            type: f || h.type || h.tagName.toLowerCase(),
                            value: y || h.value || h.textContent || "",
                            imageUrl: I,
                            label: x,
                            id: h.id || null,
                            isVisible: o(h),
                            isDisabled: h.disabled || h.getAttribute("disabled") === "disabled"
                        },
                        checklist: i(),
                        allAvailableFields: s()
                    }
                }
            }
              , d = () => ({
                displayName: "",
                data: {
                    selectedField: null,
                    checklist: i(),
                    allAvailableFields: s()
                }
            })
              , u = h => {
                const f = JSON.stringify(h);
                f !== e && (e = f,
                t(h).catch(y => {
                    console.error(`${hs} Error updating context:`, y)
                }
                ))
            }
              , g = (h, f, y) => {
                r(h) && u(l(h, f, y))
            }
              , c = h => {
                var y;
                if (h.target.type === "checkbox") {
                    const b = i().filter(x => x.isChecked);
                    if (b.length === 0)
                        u(d());
                    else if (b.length === 1) {
                        const x = b[0]
                          , v = document.getElementById(x.id || "") || document.querySelector(`input[name="${x.name}"]`);
                        v && u(l(v))
                    } else {
                        const x = b.map(S => S.title)
                          , v = ((y = _e == null ? void 0 : _e.general) == null ? void 0 : y.displayName) || "WordPress Admin";
                        u({
                            displayName: `${v} > Multiple inputs`,
                            data: {
                                selectedField: null,
                                selectedCount: b.length,
                                selectedTitles: x,
                                checklist: i(),
                                allAvailableFields: s()
                            }
                        })
                    }
                }
            }
              , m = () => {
                window.tinymce && typeof window.tinymce.on == "function" && window.tinymce.on("AddEditor", f => {
                    f.editor.on("focus", () => g(f.editor.getElement(), "tinymce_editor", f.editor.getContent()))
                }
                );
                const h = document.getElementById("wpbody");
                if (!h) {
                    console.error(`${hs} WP_BODY not found`);
                    return
                }
                h.querySelectorAll('iframe[id*="content_ifr"], iframe[id*="editor"]').forEach(f => {
                    try {
                        const y = f
                          , b = y.contentDocument;
                        b && b.addEventListener("focusin", () => {
                            var x;
                            return g(y, "visual_editor", (x = b.body) == null ? void 0 : x.innerHTML)
                        }
                        )
                    } catch (y) {
                        console.error(`${hs} Error setting up context listener for iframe:`, y)
                    }
                }
                )
            }
            ;
            document.addEventListener("focusin", h => g(h.target)),
            document.addEventListener("change", c),
            u(d());
            const p = () => {
                m()
            }
            ;
            await Xa(),
            p(),
            setTimeout(p, jv.EDITOR_SETUP)
        } catch (e) {
            console.error(`${hs} Error setting up context listener:`, e)
        }
    }
    const mt = "wc/v3/"
      , vr = () => {
        const {root: t, nonce: e} = window.wpApiSettings;
        return {
            root: t,
            nonce: e
        }
    }
      , Pt = async (t, e={}) => {
        const {nonce: r} = vr();
        return fetch(t, {
            ...{
                credentials: "same-origin",
                headers: {
                    "X-WP-Nonce": r,
                    "Content-Type": "application/json"
                }
            },
            ...e
        })
    }
      , wd = t => {
        t.tool("woo-get-all-products", "A product listing tool. Retrieves a complete list of all WooCommerce products that in the store. Use this when you need to get the IDs and names of all available products.", {}, async () => {
            try {
                const {root: e} = vr()
                  , r = await Pt(`${e}${mt}products`);
                if (!r.ok)
                    throw new Error(`Failed to get products: ${r.statusText}`);
                const n = (await r.json()).map(s => ({
                    id: s.id,
                    name: s.name
                }));
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(n)
                    }]
                }
            } catch (e) {
                return console.error("Error in woo-get-all-products:", e),
                {
                    isError: !0,
                    content: [{
                        type: "text",
                        text: `Error getting all products: ${einstanceof Error ? e.message : String(e)}`
                    }]
                }
            }
        }
        ),
        t.tool("woo-get-product", "This tool retrieves the details of a specific WooCommerce product by its product ID. Use this when you need to get the full information about a single product, such as for editing, displaying, or processing that product. The tool will return the product's details as a JSON object.", {
            productId: a.number().describe("The unique numeric ID of the WooCommerce product to retrieve")
        }, async ({productId: e}) => {
            try {
                const {root: r} = vr()
                  , o = await Pt(`${r}${mt}products/${e}`);
                if (!o.ok)
                    throw new Error(`Failed to get product: ${o.statusText}`);
                const n = await o.json();
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(n)
                    }]
                }
            } catch (r) {
                return console.error("Error in woo-get-product:", r),
                {
                    isError: !0,
                    content: [{
                        type: "text",
                        text: `Error getting product: ${rinstanceof Error ? r.message : String(r)}`
                    }]
                }
            }
        }
        )
    }
    ;
    var bd = (t => (t.ANGIE_MINIAPP_START = "angie/miniapp/start",
    t))(bd || {});
    const xe = async t => new Promise( (e, r) => {
        const o = tn();
        if (!o)
            throw new Error("Angie iframe not found");
        const n = "https://angie.elementor.com"
          , s = new MessageChannel;
        s.port1.onmessage = i => {
            i.data.status === "success" ? e(i.data.payload) : r(new Error(i.data.payload)),
            s.port1.close()
        }
        ,
        o.contentWindow.postMessage({
            type: bd.ANGIE_MINIAPP_START,
            payload: {
                ...t
            }
        }, n, [s.port2])
    }
    )
      , Fv = async t => new Promise( (e, r) => {
        const o = tn();
        if (!o)
            throw new Error("Angie iframe not found");
        const n = "https://angie.elementor.com"
          , s = new MessageChannel;
        s.port1.onmessage = i => {
            i.data.status === "success" ? e(i.data.payload) : r(new Error(i.data.payload)),
            s.port1.close()
        }
        ,
        o.contentWindow.postMessage({
            type: be.ANGIE_GET_MEDIA_BLOB,
            payload: {
                mediaUrl: t
            }
        }, n, [s.port2])
    }
    );
    async function Rr(t) {
        var g;
        const {imageUrl: e, filename: r, title: o, altText: n, description: s, caption: i} = t;
        try {
            qv(e)
        } catch (c) {
            throw new Error(`Invalid image URL: ${cinstanceof Error ? c.message : "Security validation failed"}`)
        }
        console.log("[WordPress Image Upload] Uploading image from URL:", e);
        const l = Gv(r || Wv(e) || "uploaded-image.jpg")
          , d = o || l
          , u = n || d;
        try {
            let c;
            if (e.includes("storage.googleapis.com")) {
                const y = await Fv(e);
                if (!y)
                    throw new Error("Failed to fetch image from Google Storage URL");
                const b = atob(y)
                  , x = new ArrayBuffer(b.length)
                  , v = new Uint8Array(x);
                for (let S = 0; S < b.length; S++)
                    v[S] = b.charCodeAt(S);
                c = x
            } else {
                const y = await fetch(e);
                if (!y.ok)
                    throw new Error(`Failed to fetch image from URL: ${y.statusText}`);
                c = await y.arrayBuffer()
            }
            const p = zv(l)
              , h = {
                "Content-Disposition": `attachment; filename="${Bv(l)}"`,
                "Content-Type": p
            }
              , f = await U("/wp/v2/media", "POST", {
                title: d,
                alt_text: u,
                description: s || "",
                caption: i || ""
            }, {
                binaryData: c,
                customHeaders: h
            });
            if (!f || !f.id || !f.source_url)
                throw new Error("Invalid response from WordPress media upload API");
            return console.log("[WordPress Image Upload] Successfully uploaded with ID:", f.id),
            {
                id: f.id,
                url: f.source_url,
                title: ((g = f.title) == null ? void 0 : g.rendered) || d,
                altText: f.alt_text || u
            }
        } catch (c) {
            console.error("[WordPress Image Upload] Upload failed:", c);
            let m = "Upload failed due to an unexpected error";
            throw c instanceof Error && (c.message.includes("fetch") || c.message.includes("network") ? m = "Failed to download image from the provided URL" : c.message.includes("Invalid response") ? m = "WordPress media upload service is temporarily unavailable" : c.message.includes("Failed to fetch image") ? m = "The image URL is not accessible or invalid" : c.message.includes("Failed to upload") && (m = "Image upload failed - please check file format and size")),
            new Error(m)
        }
    }
    function Wv(t) {
        var e;
        try {
            const o = new URL(t).pathname.split("/").pop() || "image.png";
            return o != null && o.includes(".") ? o : `image-${Date.now()}.png`
        } catch {
            const r = ((e = t.split("/").pop()) == null ? void 0 : e.split("?")[0]) || "image.png";
            return r.includes(".") ? r : `image-${Date.now()}.png`
        }
    }
    function qv(t) {
        let e;
        try {
            e = new URL(t)
        } catch {
            throw new Error("Invalid URL format")
        }
        if (!["http:", "https:"].includes(e.protocol))
            throw new Error("Only HTTP and HTTPS URLs allowed");
        const r = e.hostname.toLowerCase();
        if (["localhost", "127.0.0.1", "0.0.0.0", "::1"].includes(r) || r.startsWith("10.") || r.startsWith("192.168.") || /^172\.(1[6-9]|2[0-9]|3[0-1])\./.test(r))
            throw new Error("Internal addresses not allowed")
    }
    function Gv(t) {
        let e = t.replace(/[<>:"/\\|?*\x00-\x1f]/g, "_").replace(/^\.+/, "").replace(/\.+$/, "").trim();
        if ((!e || e.length === 0) && (e = `upload-${Date.now()}`),
        e.length > 255) {
            const r = e.split(".").pop();
            e = `${e.substring(0, e.lastIndexOf(".")).substring(0, 250 - (r ? r.length + 1 : 0))}${r ? "." + r : ""}`
        }
        return e
    }
    function Bv(t) {
        return t.replace(/["\\\r\n]/g, "_")
    }
    function zv(t) {
        var o;
        const e = (o = t.split(".").pop()) == null ? void 0 : o.toLowerCase()
          , r = {
            gif: "image/gif",
            webp: "image/webp",
            bmp: "image/bmp",
            tiff: "image/tiff",
            tif: "image/tiff",
            jpg: "image/jpeg",
            jpeg: "image/jpeg",
            png: "image/png"
        };
        return e && r[e] ? r[e] : "image/png"
    }
    const Zv = async () => {
        const t = new He({
            name: "woocommerce-single-product-edit-server",
            version: "1.0.0"
        });
        return wd(t),
        t.tool("woo-update-current-viewed-product", `This tool updates the current viewed product in the product dashboard UI.
Use this when you need to modify the currently viewed product (The product in the context).

You can only update the following product fields:
[title, description (content), excerpt, regular_price, sale_price, sku, stock, low_stock_amount, purchase_note, product_length, product_width, weight and the categories]
For other product fields, tell the user to move out of the product edit page because from this page you can only update certain UI fields.

IMPORTANT: If the user asks to do something that requires accessing the WooCommerce database (like creating new products, bulk operations, or advanced database queries), tell them to go to the products page instead.`, {
            productUIInputFields: a.array(a.object({
                elementId: a.string().describe("The UI input element id taken from productUIInputFields"),
                productFieldNewValue: a.string().describe("the new value of the input field")
            })).describe("List of the UI input elements that need to update. Use the productUIInputFields parameter from the context")
        }, async ({productUIInputFields: e}) => {
            var r, o, n, s;
            try {
                let i = 0;
                const l = {};
                for (const d of e) {
                    const {elementId: u, productFieldNewValue: g} = d;
                    if (u === "_stock") {
                        const m = document.getElementById("_manage_stock");
                        m instanceof HTMLInputElement && (m.checked = isNaN(+g) || +g > 0)
                    }
                    let c = null;
                    if (u === "content" ? c = (o = (r = document.getElementById("content_ifr")) == null ? void 0 : r.contentDocument) == null ? void 0 : o.querySelector(`[data-id="${u}"]`) : u === "excerpt" ? c = (s = (n = document.getElementById("excerpt_ifr")) == null ? void 0 : n.contentDocument) == null ? void 0 : s.querySelector(`[data-id="${u}"]`) : (c = document.getElementById(u),
                    c instanceof HTMLInputElement && c.type === "checkbox" && (c.checked = g === "true")),
                    !c) {
                        l[u] = "Element not found";
                        continue
                    }
                    c instanceof HTMLInputElement || c instanceof HTMLTextAreaElement || c instanceof HTMLSelectElement ? (c.value = g,
                    c.dispatchEvent(new Event("change",{
                        bubbles: !0
                    })),
                    i++) : (c.textContent = g,
                    i++)
                }
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify({
                            successfulUpdatedCount: i,
                            failedUpdates: Object.keys(l).length > 0 ? l : void 0,
                            nextStep: "Only if the user asked to save or publish the product, use the woo-update-products tool to save the changes permanently."
                        })
                    }]
                }
            } catch (i) {
                return console.error("Error in woo-update-current-viewed-product:", i),
                {
                    isError: !0,
                    content: [{
                        type: "text",
                        text: `Error updating page elements: ${iinstanceof Error ? i.message : String(i)}`
                    }]
                }
            }
        }
        ),
        t.tool("woo-set-product-image", `Sets or removes the featured image for a WooCommerce product from an image URL. MCP server handles upload automatically. Use this for WooCommerce products only, not regular WordPress posts. Requires the product ID and optional image URL.

IMPORTANT: If the user asks to do something that requires accessing the WooCommerce database (like creating new products, bulk operations, or advanced database queries), tell them to go to the products page instead.`, {
            productId: a.number().describe("The ID of the WooCommerce product to update (get it from postId parameter)"),
            imageUrl: a.string().url().describe("The URL of the image to set as product featured image. Can be any public image URL - MCP server will handle upload to WordPress media library."),
            filename: a.string().optional().describe("Custom filename for the uploaded image (defaults to extracted from URL)"),
            title: a.string().optional().describe("Title for the media library entry (defaults to filename)"),
            altText: a.string().optional().describe("Alt text for accessibility (defaults to title)")
        }, async ({productId: e, imageUrl: r, filename: o, title: n, altText: s}) => {
            try {
                console.log("[WooCommerce Single Product Edit Server] woo-set-product-image", {
                    productId: e,
                    imageUrl: r,
                    filename: o
                });
                const {root: i} = vr()
                  , d = (await Rr({
                    imageUrl: r,
                    filename: o || "product-image.jpg",
                    title: n || "Product Image",
                    altText: s || "Product Image"
                })).id;
                console.log("[WooCommerce Single Product Edit Server] Product image uploaded with ID:", d);
                const u = {
                    images: d ? [{
                        id: d
                    }] : []
                }
                  , g = await Pt(`${i}${mt}products/${e}`, {
                    method: "PUT",
                    body: JSON.stringify(u)
                });
                if (!g.ok)
                    throw new Error(`Failed to update product image: ${g.statusText}`);
                const c = await g.json();
                return d ? {
                    content: [{
                        type: "text",
                        text: `Product image (ID: ${d}) set for product "${c.name || "Untitled"}" (ID: ${e}).`
                    }]
                } : {
                    content: [{
                        type: "text",
                        text: `Product image removed from product "${c.name || "Untitled"}" (ID: ${e}).`
                    }]
                }
            } catch (i) {
                return console.error("Error in woo-set-product-image:", i),
                {
                    isError: !0,
                    content: [{
                        type: "text",
                        text: `Error setting product image for product ${e}: ${iinstanceof Error ? i.message : String(i)}`
                    }]
                }
            }
        }
        ),
        t
    }
    ;
    function Hv(t) {
        let e = null;
        function r() {
            var s, i, l;
            const n = Number(new URLSearchParams(location.search).get("post"));
            n && ((l = (i = (s = window.angieConfig) == null ? void 0 : s.plugins) == null ? void 0 : i.woocommerce) != null && l.isSingleProductEdit) ? e = {
                currentlyViewedProductId: n,
                productUIInputFields: Vv()
            } : e = null,
            t(e)
        }
        function o() {
            const n = history.pushState
              , s = history.replaceState;
            history.pushState = function(i, l, d) {
                n.call(history, i, l, d),
                r()
            }
            ,
            history.replaceState = function(i, l, d) {
                s.call(history, i, l, d),
                r()
            }
        }
        r(),
        o()
    }
    const Vv = () => {
        try {
            const t = ["title", "_regular_price", "_sale_price", "_sku", "_stock", "_low_stock_amount", "_purchase_note", "product_length", "product_width", "_weight", "product-type"]
              , e = [{
                labelText: "Product description",
                inputName: "product_full_description",
                inputId: "content",
                inputType: "text"
            }, {
                labelText: "Product short description",
                inputName: "product_short_description",
                inputId: "excerpt",
                inputType: "text"
            }]
              , r = document.querySelectorAll("#product_cat-all input[id]")
              , o = Array.from(r).map(i => i.parentElement).filter(i => (i == null ? void 0 : i.tagName.toLowerCase()) === "label");
            return [...[...Array.from(document.querySelectorAll("label[for]")), ...o].map(i => {
                var h, f;
                const l = i.getAttribute("for") || ((h = i.querySelector(":scope > input")) == null ? void 0 : h.id)
                  , d = document.getElementById(l ?? "")
                  , u = Array.from(r).map(y => y.id);
                if (!d || !l || !(t.includes(l) || u.includes(l)))
                    return null;
                const g = d.getAttribute("name")
                  , c = d.getAttribute("type") || d.tagName.toLowerCase()
                  , m = c === "checkbox" ? d.checked : d.value || d.textContent || ""
                  , p = {
                    labelText: ((f = i.textContent) == null ? void 0 : f.trim()) ?? "",
                    inputName: g,
                    inputId: l,
                    inputType: c,
                    inputValue: m,
                    inputOptions: []
                };
                return c === "select" ? p.inputOptions = Array.from(d.options ?? []).map(y => y.value) : delete p.inputOptions,
                p
            }
            ).filter(i => i !== null), ...e]
        } catch (t) {
            return console.error("Error getting current page inputs:", t),
            []
        }
    }
    ;
    let _e = null
      , Sd = !1;
    const Ed = "context://current";
    let ar = null;
    const nn = (t, e) => {
        if (!ar)
            throw new Error("Server not initialized");
        return async r => {
            if (Sd) {
                console.log(`[Context Server] Skipping context update for '${t}' - Angie is processing`);
                return
            }
            if (e && !e()) {
                console.log(`[Context Server] Skipping context update for '${t}' - callback condition not met`);
                return
            }
            if (r === null) {
                console.log(`[Context Server] Deleting context for '${t}'`),
                delete _e[t];
                return
            }
            _e = {
                ..._e,
                [t]: r
            },
            ar == null || ar.server.sendResourceUpdated({
                uri: Ed
            })
        }
    }
    ;
    function Jv() {
        return ar = new He({
            name: "context-server",
            version: "1.0.0"
        },{
            capabilities: {
                resources: {
                    subscribe: !0
                }
            }
        }),
        ar.resource("current-context", Ed, async t => ({
            contents: [{
                uri: t.href,
                mimeType: "application/json",
                text: JSON.stringify(_e)
            }]
        })),
        ar.server.setRequestHandler(Vs, async t => (console.log(`[Context Server] Client subscribed to resource: ${t.params.uri}`),
        zo() && await Kv(nn("editor", zo)),
        Qv(nn("gutenberg", Bo)),
        aw(nn("studio")),
        Mv(nn("wp_admin_fields", ew)),
        ow(nn("general")),
        Hv(nn("woocommerce", tw)),
        {})),
        ar.server.setRequestHandler(Js, async t => (console.log(`[Context Server] Client unsubscribed from resource: ${t.params.uri}`),
        {})),
        Yv(),
        ar
    }
    function Yv() {
        window.addEventListener("message", t => {
            var e;
            if (((e = t.data) == null ? void 0 : e.type) === be.ANGIE_PROCESSING_STATE_CHANGE) {
                const {isProcessing: r} = t.data.payload || {};
                typeof r == "boolean" && (Sd = r,
                console.log(`[Context Server] Angie processing state changed: ${r ? "PROCESSING" : "IDLE"}`))
            }
        }
        )
    }
    function ei() {
        var t, e;
        try {
            if (!((e = (t = window.elementor) == null ? void 0 : t.$previewContents) != null && e[0]))
                return null;
            const r = []
              , o = window.elementor.$previewContents[0].cloneNode(!0);
            o.querySelectorAll(".elementor-editor-element-settings, #elementor-add-new-section").forEach(l => l.remove());
            const n = (l, d=!1) => {
                var u, g;
                if (d = ((u = l.classList) == null ? void 0 : u.contains("elementor-element")) || d,
                l.nodeType === 3 && d) {
                    const c = (g = l.textContent) == null ? void 0 : g.trim().replace(/\s+/g, " ");
                    c && c.length > 2 && r.push(c)
                } else
                    l.childNodes.forEach(c => n(c, d))
            }
            ;
            n(o);
            const s = r.join(" ");
            return s.length > 500 ? s.slice(0, 500) + "..." : s
        } catch {
            return null
        }
    }
    async function Kv(t) {
        var g;
        let e = null
          , r = null
          , o = null;
        async function n() {
            var c, m;
            try {
                const p = {};
                if ((m = (c = window.$e) == null ? void 0 : c.data) != null && m.get) {
                    try {
                        const h = await window.$e.data.get("globals/colors");
                        h != null && h.data && (p.colors = h.data)
                    } catch (h) {
                        console.warn("[Context Server] Could not fetch global colors:", h)
                    }
                    try {
                        const h = await window.$e.data.get("globals/typography");
                        h != null && h.data && (p.typography = h.data)
                    } catch (h) {
                        console.warn("[Context Server] Could not fetch global typography:", h)
                    }
                }
                return p
            } catch (p) {
                return console.warn("[Context Server] Error fetching Elementor globals:", p),
                {}
            }
        }
        function s(c) {
            const m = ["accordion", "tabs", "toggle"];
            return c.filter(p => !p.startsWith("wp-") && !m.includes(p))
        }
        function i() {
            let c = !1;
            window.$e.commands.on("run:before", async (p, h) => {
                h === "editor/documents/close" && (c = !0,
                console.log("[Context Server] Document switching started"))
            }
            ),
            window.$e.commands.on("run:after", async (p, h, f) => {
                if (console.log("[Context Server] Elementor command:", h, f),
                h === "editor/documents/switch") {
                    c = !1,
                    console.log("[Context Server] Document switch completed, updating context");
                    const y = ei();
                    return o = y,
                    m("document/elements/deselect-all", f, y)
                }
                if (c) {
                    console.log("[Context Server] Skipping update during document switch");
                    return
                }
                if (h === "document/save/update") {
                    const y = await n();
                    e && (e = {
                        ...e,
                        globals: y
                    },
                    await t(e));
                    return
                }
                r !== null && clearTimeout(r),
                m(h, f, o),
                r = window.setTimeout(async () => {
                    const y = ei();
                    o = y,
                    await m(h, f, y)
                }
                , 1e3)
            }
            );
            async function m(p, h, f) {
                var w, _, I, k, C;
                const y = await n()
                  , b = gs();
                if (p === "document/elements/deselect-all") {
                    e = {
                        ...e,
                        displayName: b,
                        data: {
                            ...(e == null ? void 0 : e.data) || {},
                            pageTitle: b,
                            elementDisplayName: null,
                            elementType: null,
                            selectedElementId: null,
                            selectedParentId: null,
                            selectedImageUrl: null,
                            selectedWidgetType: null,
                            isSelectedContainer: !1
                        },
                        ...f && {
                            pageContent: f
                        },
                        globals: y
                    },
                    t(e);
                    return
                }
                const x = h.container;
                if (!x || !x.id || p !== "document/elements/select" && p !== "document/elements/settings")
                    return;
                const v = x.label === "Image" ? (_ = (w = x.settings) == null ? void 0 : w.attributes) == null ? void 0 : _.image : null
                  , S = iw(x);
                e = {
                    ...e,
                    displayName: `${b} > ${S}`,
                    data: {
                        ...(e == null ? void 0 : e.data) || {},
                        pageTitle: b,
                        elementDisplayName: S,
                        elementType: x.type || "widget",
                        selectedElementId: x.id,
                        selectedParentId: (I = x.parent) == null ? void 0 : I.id,
                        selectedImageUrl: v == null ? void 0 : v.url,
                        selectedWidgetType: (C = (k = x.model) == null ? void 0 : k.attributes) == null ? void 0 : C.widgetType,
                        isSelectedContainer: x.type === "container"
                    },
                    globals: y,
                    ...f && {
                        pageContent: f
                    }
                },
                console.log("[Context Server] Context updated from Elementor selection:", e, x),
                t(e)
            }
        }
        i();
        const l = ei();
        o = l;
        const d = await n()
          , u = gs();
        e = {
            displayName: u,
            data: {
                pageTitle: u,
                pageContent: l,
                currentlyViewedScreen: "The user is currently viewing the Elementor editor",
                availableWidgetTypes: s(Object.keys(((g = window.elementor) == null ? void 0 : g.widgetsCache) ?? {}))
            },
            globals: d
        },
        t(e)
    }
    function Qv(t) {
        var s, i;
        if (!rw()) {
            t(null);
            return
        }
        console.log("[Context Server] Initializing Gutenberg listener");
        let e = null
          , r = null
          , o = ""
          , n = null;
        ti(t),
        (i = (s = window.wp) == null ? void 0 : s.data) == null || i.subscribe( () => {
            n !== null && clearTimeout(n),
            n = window.setTimeout( () => {
                nw(t, {
                    lastSelectedBlockId: e,
                    lastBlockContent: r,
                    lastBlocksSnapshot: o
                }, l => {
                    e = l.lastSelectedBlockId,
                    r = l.lastBlockContent,
                    o = l.lastBlocksSnapshot
                }
                )
            }
            , 300)
        }
        )
    }
    function Xv() {
        var t, e, r;
        return Bo() || zo() || !!((r = (e = (t = window.angieConfig) == null ? void 0 : t.plugins) == null ? void 0 : e.woocommerce) != null && r.isSingleProductEdit)
    }
    function ew() {
        return !Xv()
    }
    function tw() {
        var t, e, r;
        return !!((r = (e = (t = window.angieConfig) == null ? void 0 : t.plugins) == null ? void 0 : e.woocommerce) != null && r.isSingleProductEdit)
    }
    function rw() {
        var t, e;
        try {
            return !!((e = (t = window.wp) == null ? void 0 : t.data) != null && e.select) && !!window.wp.data.select("core/block-editor")
        } catch {
            return !1
        }
    }
    async function ti(t, e, r) {
        var o, n, s, i, l, d, u;
        try {
            const {blockEditorSelect: g, editorSelect: c} = _d();
            if (!c || !g)
                return;
            const m = c.getCurrentPostType()
              , p = c.getEditedPostAttribute("title")
              , h = c.getEditedPostAttribute("meta")
              , f = c.getEditedPostAttribute("acf")
              , y = (o = document.querySelector(".acf-fields")) == null ? void 0 : o.innerHTML
              , b = g.getBlocks()
              , x = xd(b)
              , v = (typeof p == "string" ? p : null) || gs();
            let S = {
                displayName: v,
                data: {
                    pageTitle: v,
                    postType: m,
                    postTitle: v,
                    currentlyViewedScreen: "The user is currently viewing the Gutenberg editor",
                    allBlocks: x,
                    meta: h,
                    acf: f,
                    acfForm: y
                }
            };
            if (e && r) {
                const w = S.data
                  , _ = lw(e);
                let I = ((i = (s = (n = window.wp) == null ? void 0 : n.blocks) == null ? void 0 : s.getBlockContent) == null ? void 0 : i.call(s, e)) || ""
                  , k = e.innerBlocks ?? e.attributes.content ?? "";
                if (!(k != null && k.length)) {
                    const N = (d = (l = document.querySelector('iframe[name="editor-canvas"]')) == null ? void 0 : l.contentDocument) == null ? void 0 : d.querySelector(`[data-block="${r}"]`);
                    k = (N == null ? void 0 : N.innerText) || k,
                    I = N.innerHTML
                }
                const C = e.name === "core/image" && e.attributes && e.attributes.url || ""
                  , L = x.findIndex(N => N.id === r);
                S = {
                    ...S,
                    displayName: `${v} > ${_}`,
                    data: {
                        ...w,
                        pageTitle: v,
                        elementDisplayName: _,
                        elementType: "block",
                        selectedElementId: r,
                        selectedBlockId: r,
                        selectedBlockName: e.name,
                        selectedBlockType: ((u = e == null ? void 0 : e.name) == null ? void 0 : u.split("/")[1]) || e.name,
                        selectedBlockAttributes: e.attributes,
                        selectedBlockHtml: I,
                        selectedBlockContent: k,
                        selectedImageUrl: C,
                        selectedBlockPosition: L >= 0 ? L : void 0,
                        allBlocks: x
                    }
                }
            }
            console.log("[Context Server] Gutenberg Context updated.", S),
            t(S)
        } catch (g) {
            console.error("[Context Server] Error creating Gutenberg context:", g)
        }
    }
    async function nw(t, e, r) {
        var o, n, s;
        try {
            const {blockEditorSelect: i, editorSelect: l} = _d();
            if (!i || !l)
                return;
            const d = i.getBlocks()
              , u = JSON.stringify(xd(d))
              , g = u !== e.lastBlocksSnapshot
              , c = i.getSelectedBlockClientIds()
              , m = (c == null ? void 0 : c[0]) || null
              , p = m ? i.getBlock(m) : null
              , h = p ? (s = (n = (o = window.wp) == null ? void 0 : o.blocks) == null ? void 0 : n.getBlockContent) == null ? void 0 : s.call(n, p) : null
              , f = m !== e.lastSelectedBlockId || h !== e.lastBlockContent;
            (g || f) && (r({
                lastSelectedBlockId: m,
                lastBlockContent: h || null,
                lastBlocksSnapshot: u
            }),
            p && m ? await ti(t, p, m) : await ti(t))
        } catch (i) {
            console.error("[Context Server] Error in Gutenberg context:", i)
        }
    }
    function xd(t) {
        const e = [];
        let r = 0;
        function o(n) {
            n.clientId && n.name && e.push({
                id: n.clientId,
                name: n.name,
                index: r++
            }),
            n.innerBlocks && n.innerBlocks.length > 0 && n.innerBlocks.forEach(o)
        }
        return t.forEach(o),
        e
    }
    function _d() {
        var t, e, r, o;
        return {
            blockEditorSelect: (e = (t = window.wp) == null ? void 0 : t.data) == null ? void 0 : e.select("core/block-editor"),
            editorSelect: (o = (r = window.wp) == null ? void 0 : r.data) == null ? void 0 : o.select("core/editor")
        }
    }
    function ow(t) {
        var c;
        const e = Intl.DateTimeFormat().resolvedOptions().timeZone
          , r = new URLSearchParams(location.search).get("post")
          , o = r ? Number(r) : null
          , n = gs()
          , s = new URL(window.location.href)
          , i = s.pathname + s.search
          , l = n || "WordPress Admin"
          , d = ((c = window.angieConfig) == null ? void 0 : c.plugins) || {}
          , u = () => {
            const m = new Date;
            return {
                gmt: m.toLocaleString(void 0, {
                    timeZone: "UTC"
                }),
                user: m.toLocaleString(void 0, {
                    timeZone: e,
                    timeZoneName: "long",
                    weekday: "long",
                    day: "numeric",
                    month: "long",
                    year: "numeric",
                    hour: "2-digit",
                    minute: "2-digit"
                })
            }
        }
          , g = {
            displayName: l,
            data: {
                today: u(),
                timezone: e,
                currentPage: {
                    pageName: l,
                    pageTitle: n,
                    menuPath: sw(),
                    pageUrl: i
                },
                plugins: d
            },
            ...o && {
                postId: o
            }
        };
        t(g),
        setInterval( () => {
            const m = {
                ...g,
                data: {
                    ...g.data,
                    today: u()
                }
            };
            t(m)
        }
        , 6e4)
    }
    function sw() {
        var o, n, s;
        const t = document.getElementById("adminmenu");
        if (!t)
            return null;
        const e = []
          , r = t.querySelector("li.wp-has-current-submenu a .wp-menu-name");
        if (r) {
            e.push(((o = r.textContent) == null ? void 0 : o.trim()) || "");
            const i = r.closest("li.wp-has-current-submenu")
              , l = i == null ? void 0 : i.querySelector("ul.wp-submenu li.current a");
            l && e.push(((n = l.textContent) == null ? void 0 : n.trim()) || "")
        } else {
            const i = t.querySelector("li.current a, a.current");
            i && e.push(((s = i.textContent) == null ? void 0 : s.trim()) || "")
        }
        return e.length > 0 ? e.join(" > ").toLowerCase() : null
    }
    function aw(t) {
        let e = null;
        window.addEventListener(be.STUDIO_UI_SESSION_START, () => {
            _e && !e && (e = {
                ..._e
            },
            _e = null),
            t(null)
        }
        ),
        window.addEventListener(be.STUDIO_UI_STATE_UPDATE, r => {
            t(r.detail)
        }
        ),
        window.addEventListener(be.STUDIO_UI_SESSION_END, async () => {
            e && (_e = {
                ...e
            },
            e = null),
            await t(null)
        }
        )
    }
    function gs() {
        var t, e, r, o, n;
        try {
            if ((e = (t = window.elementor) == null ? void 0 : t.documents) != null && e.getCurrent) {
                const i = window.elementor.documents.getCurrent()
                  , l = (n = (o = (r = i == null ? void 0 : i.config) == null ? void 0 : r.settings) == null ? void 0 : o.settings) == null ? void 0 : n.post_title;
                if (l)
                    return l
            }
            let s = document.title || "Page";
            return s = s.split(/\s*[|-]\s*/)[0],
            s.trim() || "Page"
        } catch (s) {
            return console.warn("[Context Server] Could not get page title:", s),
            "Page"
        }
    }
    function iw(t) {
        var e, r;
        try {
            if (t.label)
                return t.label;
            if ((r = (e = t.model) == null ? void 0 : e.attributes) != null && r.widgetType) {
                const o = t.model.attributes.widgetType;
                return (o.charAt(0).toUpperCase() + o.slice(1)).replace(/-/g, " ")
            }
            return t.type === "container" ? "Container" : t.type === "section" ? "Section" : `Element ${t.id}`
        } catch (o) {
            return console.warn("[Context Server] Could not get element display name:", o),
            `Element ${t.id}`
        }
    }
    function lw(t) {
        var e, r, o, n, s;
        try {
            const i = (o = (r = (e = window.wp) == null ? void 0 : e.blocks) == null ? void 0 : r.getBlockType) == null ? void 0 : o.call(r, t.name);
            if (i != null && i.title)
                return i.title;
            const l = ((s = (n = t == null ? void 0 : t.name) == null ? void 0 : n.split("/")[1]) == null ? void 0 : s.replace(/-/g, " ")) || t.name;
            return l.charAt(0).toUpperCase() + l.slice(1)
        } catch (i) {
            return console.warn("[Context Server] Could not get block display name:", i),
            "Block"
        }
    }
    let ri;
    const cw = () => (ri = dw(),
    ri)
      , dw = async () => new Promise( (t, e) => {
        window.elementorCommon.ajax.addRequest("ai_get_remote_config", {
            success: r => {
                const {jwt: o, features: n=[]} = r.config;
                t({
                    jwt: o,
                    features: n
                })
            }
            ,
            error: r => {
                console.log("remoteConfig", r),
                e(r)
            }
        })
    }
    )
      , uw = t => {
        t.style.height = "80px"
    }
      , mw = t => {
        t.style.height = "80px"
    }
      , Lt = (t, e) => {
        t.postMessage({
            status: "success",
            payload: e
        })
    }
      , Td = (t, e) => {
        t.postMessage({
            status: "error",
            payload: e
        })
    }
      , fs = async t => {
        const e = t.origin || "https://editor-static-bucket.elementor.com"
          , r = await ri
          , o = new URL(t.path,e)
          , n = o.pathname.slice(1).replace(/\//, "--") + "-" + Math.random().toString(36).substring(7);
        return new Promise(s => {
            var h, f, y, b, x, v, S, w, _;
            const i = new URL(e);
            i.pathname = o.pathname,
            i.pathname += ".html";
            const l = window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light"
              , d = ((x = (b = (y = (f = (h = window.elementor) == null ? void 0 : h.config) == null ? void 0 : f.settings) == null ? void 0 : y.editorPreferences) == null ? void 0 : b.settings) == null ? void 0 : x.ui_theme) || l;
            if (i.searchParams.append("colorScheme", d),
            i.searchParams.append("isRTL", (S = (v = window.elementorCommon) == null ? void 0 : v.config) != null && S.isRTL ? "true" : "false"),
            i.searchParams.append("version", (_ = (w = window.elementorCommon) == null ? void 0 : w.config) == null ? void 0 : _.version),
            i.searchParams.append("instanceId", n),
            i.searchParams.append("origin", window.location.origin),
            window.location.hostname === "localhost" && window.location.search.includes("debug_error")) {
                const I = new URLSearchParams(window.location.search).get("debug_error");
                I && i.searchParams.append("debug_error", I)
            }
            o.searchParams.forEach( (I, k) => {
                i.searchParams.set(k, I)
            }
            ),
            i.searchParams.set("ver", new Date().getTime().toString());
            const u = t.parent || document
              , g = u.createElement("iframe");
            function c(I) {
                var L, N, A, $, R, q, ee, ne, te, re, Q, Ie, Fe, We, ve, qe, Ke, Te, Ve, rt;
                const k = window.elementor ? (L = window.elementor.config) == null ? void 0 : L.user : (A = (N = window.elementorAdmin) == null ? void 0 : N.config) == null ? void 0 : A.user
                  , C = (ne = (R = ($ = window.elementorFrontend) == null ? void 0 : $.elements) == null ? void 0 : R.$window[0]) == null ? void 0 : ne.getComputedStyle((ee = (q = window.elementorFrontend) == null ? void 0 : q.elements) == null ? void 0 : ee.$body[0]);
                (rt = g.contentWindow) == null || rt.postMessage({
                    type: "referrer/info",
                    instanceId: I,
                    info: {
                        page: {
                            url: window.location.href,
                            editorSessionId: window.EDITOR_SESSION_ID,
                            elementorAiCurrentContext: window.elementorAiCurrentContext,
                            bodyStyle: {
                                backgroundColor: C == null ? void 0 : C.backgroundColor,
                                backgroundImage: C == null ? void 0 : C.backgroundImage
                            }
                        },
                        authToken: r == null ? void 0 : r.jwt,
                        siteKey: t.siteKey,
                        products: {
                            core: {
                                version: (re = (te = window.elementor) == null ? void 0 : te.config) == null ? void 0 : re.version
                            },
                            pro: {
                                isPro: (Ie = (Q = window.elementor) == null ? void 0 : Q.config) == null ? void 0 : Ie.isPro,
                                accessLevel: (We = (Fe = window.elementor) == null ? void 0 : Fe.config) == null ? void 0 : We.accessLevel,
                                accessTier: (qe = (ve = window.elementor) == null ? void 0 : ve.config) == null ? void 0 : qe.accessTier
                            },
                            ai: {
                                config: window.ElementorAiConfig
                            }
                        },
                        user: {
                            isAdmin: (Ve = (Te = (Ke = window.elementor) == null ? void 0 : Ke.config) == null ? void 0 : Te.user) == null ? void 0 : Ve.is_administrator,
                            introduction: k == null ? void 0 : k.introduction
                        }
                    }
                }, i.origin)
            }
            const m = async I => {
                if (I.origin === i.origin)
                    switch (I.data.type) {
                    case "ai_request":
                        const {endpoint: k, data: C, immediately: L, signal: N} = I.data.payload;
                        Object.keys(C).length && (C.context = window.elementorAiCurrentContext),
                        C.editor_session_id = window.EDITOR_SESSION_ID;
                        const A = await window.elementorCommon.ajax.addRequest(k, {
                            success: R => {
                                Lt(I.ports[0], R)
                            }
                            ,
                            error: R => {
                                const ee = {
                                    error: R.error || R.responseText || R.statusText || R.message || (R.toString() === "[object Object]" ? "Unknown error" : R.toString())
                                };
                                R.extra_data && Object.assign(ee, R),
                                Td(I.ports[0], ee)
                            }
                            ,
                            data: C
                        }, L);
                        N && A && "jqXhr"in A && N && N.addEventListener("abort", A.jqXhr.abort);
                        break;
                    case "get/referrer/info":
                        c(I.data.payload.instanceId);
                        break;
                    case "auth-token/refresh":
                        const $ = await cw();
                        I.ports[0].postMessage({
                            status: "success",
                            payload: {
                                jwt: $.jwt
                            }
                        });
                        break;
                    case "element-selector/loaded":
                        s({
                            iframe: g,
                            iframeUrlObject: i
                        });
                        break;
                    case "element-selector/close":
                        (I.data.payload.instanceId === n || !I.data.payload.instanceId) && (g.remove(),
                        window.removeEventListener("message", m));
                        break
                    }
            }
              , p = {
                "background-color": "transparent",
                "color-scheme": "normal",
                ...t.css
            };
            window.addEventListener("message", m),
            g.setAttribute("src", i.href),
            g.id = "editor-static-iframe",
            g.setAttribute("frameborder", "0"),
            g.setAttribute("scrolling", "no"),
            g.setAttribute("allow", "clipboard-read; clipboard-write"),
            g.setAttribute("style", Object.entries(p).map( ([I,k]) => `${I}: ${k}`).join("; ")),
            g.setAttribute("allow", "clipboard-write; clipboard-read"),
            t.insertCallback ? t.insertCallback(g) : u.body.appendChild(g)
        }
        )
    }
    ;
    var on = (t => (t.ELEMENTOR = "elementor",
    t.GUTENBERG = "gutenberg",
    t.WOOCOMMERCE = "woocommerce",
    t.WP_ADMIN = "wp_admin",
    t))(on || {});
    const ys = {
        context: {}
    }
      , pw = async (t=!0) => {
        if (t && Object.keys(ys.context).length)
            return ys.context;
        try {
            const r = await (await fetch(window.wpApiSettings.root)).json();
            return ys.context = {
                name: r.name,
                tagline: r.description,
                homeUrl: r.home
            },
            ys.context
        } catch (e) {
            return console.error(e),
            {
                name: "",
                tagline: "",
                homeUrl: "",
                error: e
            }
        }
    }
      , Pd = async () => {
        var e;
        return {
            ...await pw(),
            wpVersion: (e = window.angieConfig) == null ? void 0 : e.wpVersion,
            siteLang: window.document.documentElement.lang,
            docTitle: window.document.title
        }
    }
      , hw = () => {
        if (_e != null && _e.editor)
            return on.ELEMENTOR;
        if (_e != null && _e.gutenberg)
            return on.GUTENBERG;
        if (_e != null && _e.woocommerce)
            return on.WOOCOMMERCE;
        if (_e != null && _e.general || _e != null && _e.wp_admin_fields)
            return on.WP_ADMIN
    }
      , gw = async () => {
        const t = await Pd()
          , e = hw() || on.WP_ADMIN;
        return {
            ...t,
            platform: e
        }
    }
      , fw = async t => {
        var r, o, n, s, i, l, d;
        if (t.origin === "https://angie.elementor.com")
            switch (t.data.type) {
            case be.INIT_CONTEXT_SERVER:
                const u = t.ports[0]
                  , g = Jv()
                  , c = new Aa(u);
                g.connect(c),
                console.log("Context server initialized");
                break;
            case be.ANGIE_ELEMENT_UPDATE_CUSTOM_CSS:
                const m = t.data.payload.elementId
                  , p = window.elementor.getContainer(m)
                  , h = (o = (r = p.settings) == null ? void 0 : r.attributes) == null ? void 0 : o.custom_css
                  , f = t.data.payload.custom_css
                  , y = h ? `${h}

${f}` : f
                  , b = window.$e.run("document/elements/settings", {
                    container: p,
                    settings: {
                        custom_css: y
                    },
                    options: {
                        external: !0,
                        render: !0
                    }
                });
                window.elementorFrontend.elements.$body.resize(),
                je(t.ports[0], {
                    message: `Settings for element with ID "${m}" updated successfully.`,
                    payload: b
                });
                break;
            case be.ANGIE_ELEMENT_GET_HTML_MARKUP:
                const x = t.data.payload.containerId
                  , S = ((s = (n = window.elementor.getContainer(x).view) == null ? void 0 : n.el) == null ? void 0 : s.outerHTML) || "";
                je(t.ports[0], {
                    message: `HTML markup for container with ID "${x}" retrieved successfully.`,
                    payload: S
                });
                break;
            case be.ANGIE_ELEMENT_GET_CSS:
                try {
                    const w = t.data.payload.elementId
                      , _ = window.elementor.getContainer(w);
                    if (!_) {
                        ke(t.ports[0], {
                            message: `Container with ID "${w}" not found.`
                        });
                        break
                    }
                    const I = ((l = (i = _.settings) == null ? void 0 : i.attributes) == null ? void 0 : l.custom_css) || "";
                    je(t.ports[0], {
                        message: `CSS for element with ID "${w}" retrieved successfully.`,
                        payload: {
                            elementId: w,
                            customCss: I
                        }
                    })
                } catch (w) {
                    ke(t.ports[0], {
                        message: `Error retrieving CSS for element: ${w}`
                    })
                }
                break;
            case be.ANGIE_ELEMENT_INJECT_CSS:
                try {
                    const w = t.data.payload.elementId
                      , _ = t.data.payload.parsedCss;
                    Mf(w, _),
                    je(t.ports[0], {
                        message: `Style element with ID "${w}" injected successfully.`
                    })
                } catch (w) {
                    ke(t.ports[0], {
                        message: `Error injecting style element: ${w}`
                    })
                }
                break;
            case be.ANGIE_ELEMENT_REMOVE_CSS:
                try {
                    const w = t.data.payload.elementId;
                    Ff(w),
                    je(t.ports[0], {
                        message: `Style element with ID "${w}" removed successfully.`
                    })
                } catch (w) {
                    ke(t.ports[0], {
                        message: `Error removing style element: ${w}`
                    })
                }
                break;
            case be.ANGIE_MEDIA_UPLOAD:
                await Vf(t.ports[0], t.data.payload);
                break;
            case be.ANGIE_SETTINGS_UPDATE:
                try {
                    const {settings: w} = t.data.payload;
                    console.log("Updating WordPress settings:", w),
                    await U("/wp/v2/settings", "POST", w),
                    je(t.ports[0], {
                        message: "WordPress settings updated successfully",
                        payload: {
                            settings: w
                        }
                    })
                } catch (w) {
                    console.error("Error updating WordPress settings:", w),
                    ke(t.ports[0], {
                        message: `Error updating WordPress settings: ${w}`
                    })
                }
                break;
            case be.ANGIE_CONTEXT_GET_WEBSITE_CONTEXT:
                try {
                    const w = await gw();
                    je(t.ports[0], {
                        payload: w
                    })
                } catch {
                    ke(t.ports[0], {
                        error: "Failed to get extended website context"
                    })
                }
                break;
            case be.ANGIE_CONTEXT_GET_ANALYTICS_CONTEXT:
                try {
                    const w = await Hf();
                    je(t.ports[0], {
                        payload: w
                    })
                } catch {
                    ke(t.ports[0], {
                        error: "Failed to get analytics context"
                    })
                }
                break;
            case be.ANGIE_CONTEXT_GET_POST_ID:
                try {
                    const _ = new URLSearchParams(window.location.search).get("post");
                    je(t.ports[0], {
                        payload: {
                            postId: _ || null
                        }
                    })
                } catch (w) {
                    ke(t.ports[0], {
                        message: `Error getting post ID: ${w}`
                    })
                }
                break;
            case be.ANGIE_ELEMENT_UPDATE_SETTINGS:
                try {
                    const {id: w, settings: _} = t.data.payload
                      , I = await Dc({
                        id: w,
                        settings: _
                    });
                    je(t.ports[0], {
                        message: `Settings for element with ID "${w}" updated successfully.`,
                        payload: I
                    })
                } catch (w) {
                    console.error("Error updating element settings:", w),
                    ke(t.ports[0], {
                        message: `Error updating element settings: ${w}`
                    })
                }
                break;
            case be.ANGIE_ELEMENT_GET_ELEMENT_ATTRIBUTES:
                try {
                    const {id: w} = t.data.payload
                      , _ = $a(w);
                    je(t.ports[0], {
                        message: `Settings for element with ID "${w}" retrieved successfully.`,
                        payload: {
                            attributes: _.attributes
                        }
                    })
                } catch (w) {
                    console.error("Error getting element settings:", w),
                    ke(t.ports[0], {
                        message: `Error getting element settings: ${w}`
                    })
                }
                break;
            case be.QUERY_WP_DB:
                try {
                    console.log("QUERY_WP_DB: dbQueryPayload", t);
                    const {payload: w} = t.data;
                    if (!w) {
                        console.error("QUERY_WP_DB: Missing payload in request"),
                        ke(t.ports[0], {
                            message: "Missing payload in request"
                        });
                        return
                    }
                    const {endpoint: _, method: I="GET", requestId: k, data: C, includeHeaders: L} = w;
                    if (!_) {
                        console.error("QUERY_WP_DB: Missing endpoint in payload"),
                        ke(t.ports[0], {
                            message: "Missing endpoint in request"
                        });
                        return
                    }
                    const N = await U(_, I, C, {
                        includeHeaders: L
                    });
                    je(t.ports[0], {
                        requestId: k,
                        result: N
                    })
                } catch (w) {
                    console.error("Error in QUERY_WP_DB:", w);
                    const _ = w instanceof Error ? w.message : String(w);
                    ke(t.ports[0], {
                        message: `Error querying WordPress database: ${_}`
                    })
                }
                break;
            case be.ANGIE_GET_MEDIA_BLOB:
                try {
                    const {mediaUrl: w} = t.data.payload;
                    if (console.log("Fetching media blob for URL:", w),
                    !w)
                        throw new Error("Media URL is required");
                    const _ = await fetch(w);
                    if (!_.ok)
                        throw new Error(`Failed to fetch image: ${_.status} ${_.statusText}`);
                    const I = await _.blob()
                      , k = await new Promise( (C, L) => {
                        const N = new FileReader;
                        N.onload = () => {
                            const $ = N.result.split(",")[1];
                            C($)
                        }
                        ,
                        N.onerror = L,
                        N.readAsDataURL(I)
                    }
                    );
                    je(t.ports[0], {
                        message: "Media blob fetched successfully",
                        payload: {
                            blob: k,
                            contentType: I.type,
                            size: I.size
                        }
                    })
                } catch (w) {
                    console.error("Error fetching media blob:", w),
                    ke(t.ports[0], {
                        message: `Error fetching media blob: ${w}`
                    })
                }
                break;
            case be.ANGIE_WP_UPDATE_POST_FEATURED_IMAGE:
                try {
                    const {postId: w, postType: _, mediaId: I} = t.data.payload;
                    console.log("Updating post featured image:", {
                        postId: w,
                        postType: _,
                        mediaId: I
                    });
                    const k = await gr(_)
                      , C = await U(`${k}/${w}`, "PUT", {
                        featured_media: I
                    });
                    je(t.ports[0], {
                        message: `Featured image updated successfully for ${_} ${w}`,
                        payload: C
                    })
                } catch (w) {
                    console.error("Error updating post featured image:", w),
                    ke(t.ports[0], {
                        message: `Error updating post featured image: ${w}`
                    })
                }
                break;
            case be.ANGIE_GUTENBERG_UPDATE_BLOCK:
                try {
                    const {blockId: w, attributes: _} = t.data.payload;
                    console.log("Updating Gutenberg block attributes:", {
                        blockId: w,
                        attributes: _
                    });
                    const I = jf(w, _);
                    je(t.ports[0], {
                        message: `Gutenberg block "${w}" updated successfully`,
                        payload: I
                    })
                } catch (w) {
                    console.error("Error updating Gutenberg block:", w),
                    ke(t.ports[0], {
                        message: `Error updating Gutenberg block: ${w}`
                    })
                }
                break;
            case be.ANGIE_GUTENBERG_PREVIEW_IMAGE:
                try {
                    const {blockId: w, attributes: _, customDimensions: I} = t.data.payload;
                    console.log("Previewing Gutenberg image:", {
                        blockId: w,
                        attributes: _,
                        customDimensions: I
                    }),
                    Gf({
                        blockId: w,
                        imageUrl: _.url,
                        customDimensions: I
                    }),
                    je(t.ports[0], {
                        message: `Gutenberg image preview applied for block "${w}"`,
                        payload: {
                            blockId: w,
                            previewActive: !0
                        }
                    })
                } catch (w) {
                    console.error("Error previewing Gutenberg image:", w),
                    ke(t.ports[0], {
                        message: `Error previewing Gutenberg image: ${w}`
                    })
                }
                break;
            case be.ANGIE_GUTENBERG_REMOVE_PREVIEW:
                try {
                    const {blockId: w} = t.data.payload;
                    console.log("Removing Gutenberg image preview:", {
                        blockId: w
                    }),
                    Bf(w),
                    je(t.ports[0], {
                        message: `Gutenberg image preview removed for block "${w}"`,
                        payload: {
                            blockId: w,
                            previewActive: !1
                        }
                    })
                } catch (w) {
                    console.error("Error removing Gutenberg image preview:", w),
                    ke(t.ports[0], {
                        message: `Error removing Gutenberg image preview: ${w}`
                    })
                }
                break;
            case be.ANGIE_ZOOM_DISPLAY:
                try {
                    If(t.data.payload),
                    je(t.ports[0], {
                        success: !0
                    })
                } catch (w) {
                    console.error("Error showing zoom overlay:", w),
                    ke(t.ports[0], {
                        message: `Error showing zoom overlay: ${w}`
                    })
                }
                break;
            case be.ANGIE_MODAL_DISPLAY:
                try {
                    const {modalType: w, imageUrl: _, elementId: I, ...k} = t.data.payload
                      , {imageId: C, imageUrl: L} = qf(I, "", _)
                      , N = await Jf({
                        modalType: w,
                        imageId: C,
                        imageUrl: L,
                        elementId: I,
                        context: {
                            controlName: "image",
                            elementId: I,
                            elementType: "widget"
                        },
                        ...k
                    });
                    if (N.url && N.id && I)
                        try {
                            await Dc({
                                id: I,
                                settings: {
                                    image: {
                                        url: N.url,
                                        id: N.id || "",
                                        source: N.id ? "id" : "url"
                                    }
                                }
                            }),
                            console.log(` Host successfully updated element ${I}`)
                        } catch (A) {
                            console.error("Error updating element settings:", A)
                        }
                    je(t.ports[0], {
                        message: "Image tools modal triggered successfully",
                        payload: N
                    })
                } catch (w) {
                    console.error("Error triggering image tools modal:", w),
                    ke(t.ports[0], {
                        error: w
                    })
                }
                break;
            case be.ANGIE_BRAND_VOICE_MODAL:
                try {
                    await fs({
                        origin: "https://angie.elementor.com",
                        path: "/brand-voice?source=angie",
                        siteKey: (d = window.angieConfig) == null ? void 0 : d.siteKey,
                        css: {
                            width: "100%",
                            height: "100%",
                            position: "fixed",
                            bottom: 0,
                            right: 0,
                            "z-index": 999999
                        }
                    }),
                    je(t.ports[0], {
                        message: "Brand Voice modal opened successfully",
                        payload: {
                            success: !0
                        }
                    })
                } catch (w) {
                    console.error("Error opening brand voice modal:", w),
                    ke(t.ports[0], {
                        message: `Error opening brand voice modal: ${w}`
                    })
                }
                break;
            case be.STUDIO_UI_SESSION_START:
            case be.STUDIO_UI_STATE_UPDATE:
            case be.STUDIO_UI_SESSION_END:
                await Af(t.data.type, t.ports[0], t.data.payload);
                break
            }
    }
      , yw = () => {
        window.addEventListener("message", async t => {
            try {
                await fw(t)
            } catch (e) {
                console.error("Error handling style element message:", e),
                t.ports && t.ports[0] && ke(t.ports[0], e)
            }
        }
        )
    }
      , kd = "angie_floating_btn_position"
      , Id = 3
      , vw = 100;
    function ww(t) {
        const e = (t == null ? void 0 : t.windowObj) || window
          , r = (t == null ? void 0 : t.documentObj) || document;
        if (e._angieFloatingBtnInjected)
            return () => {}
            ;
        e._angieFloatingBtnInjected = !0;
        function o() {
            return e.self !== e.top
        }
        function n(A) {
            try {
                e.localStorage.setItem(kd, JSON.stringify({
                    top: A
                }))
            } catch {}
        }
        function s() {
            try {
                const A = e.localStorage.getItem(kd);
                if (A) {
                    const $ = JSON.parse(A);
                    if (typeof $ == "object" && typeof $.top == "number")
                        return $
                }
            } catch {}
            return null
        }
        function i() {
            const A = r.createElement("style");
            return A.textContent = `
      .angie-floating-btn-container {
        position: fixed;
        top: 48px;
        inset-inline-start: 0;
        height: 48px;
        width: 8px;
        z-index: 9999;
        display: flex;
        align-items: center;
        justify-content: flex-end;
        border-radius: 0px 12px 12px 0px;
        border: 1px solid var(--_components-divider-divider, rgba(0, 0, 0, 0.12));
        background: linear-gradient(135deg, rgba(255, 255, 255, 0.2) 0%, rgba(255, 255, 255, 0.1) 100%);
        backdrop-filter: blur(5px);
        -webkit-backdrop-filter: blur(5px);
        background-blend-mode: color-dodge, normal;
        box-sizing: border-box;
        cursor: pointer;
        transition: width 0.25s cubic-bezier(.4,0,.2,1), box-shadow 0.2s;
        overflow: visible;
        user-select: none;
        gap: 0;
      }
      
      /* RTL-specific styling */
      [dir="rtl"] .angie-floating-btn-container {
        border-radius: 12px 0px 0px 12px;
      }
      
      .angie-floating-btn-container.angie-open {
        width: 48px;
      }
      body.angie-sidebar-active .angie-floating-btn-container {
        display: none;
      }
      .angie-floating-btn-container.angie-dragging {
        box-shadow: 0 4px 16px rgba(0,0,0,0.18);
        opacity: 0.95;
        cursor: grabbing !important;
        transition: none;
      }
      .angie-floating-btn-icon {
        display: flex;
        width: 20px;
        height: 20px;
        padding: 5px 6px;
        justify-content: center;
        align-items: center;
        border-radius: 2px;
        background: #C00BB9;
        color: #fff;
        font-family: inherit;
        font-size: 1.1rem;
        font-weight: 700;
        line-height: 1;
        user-select: none;
        pointer-events: none;
        box-shadow: none;
        margin: 0;
        margin-inline-end: 16px;
        box-sizing: border-box;
      }

      .angie-floating-btn-icon svg {
        display: block;
        width: 8px;
        height: 8px;
        fill: #fff;
      }
    `,
            r.head.appendChild(A),
            A
        }
        function l() {
            const A = r.createElement("div");
            A.className = "angie-floating-btn-container",
            A.tabIndex = 0,
            A.setAttribute("aria-label", "Open Angie Sidebar");
            const $ = r.createElement("div");
            return $.className = "angie-floating-btn-icon",
            $.innerHTML = `
      <svg xmlns="http://www.w3.org/2000/svg" width="8" height="8" viewBox="0 0 8 8" fill="none">
        <path d="M4.8412 3.11112V3.96215C4.37615 4.03655 3.97622 4.12026 3.64139 4.21327C3.30656 4.29698 3.02754 4.39463 2.80432 4.50624C2.5811 4.60855 2.40903 4.72481 2.28812 4.85502C2.16721 4.97593 2.07885 5.11545 2.02305 5.27356C1.97654 5.42237 1.95329 5.58514 1.95329 5.76185C1.95329 6.01298 1.99515 6.21759 2.07885 6.37571C2.16256 6.52452 2.28347 6.63613 2.44159 6.71054C2.5997 6.78494 2.79037 6.82215 3.01359 6.82215C3.24611 6.82215 3.46002 6.76634 3.65534 6.65473C3.85996 6.54312 4.05528 6.37571 4.24129 6.15249C4.43661 5.91997 4.63193 5.62699 4.82724 5.27356L4.897 6.04088C4.71098 6.43151 4.49707 6.76169 4.25524 7.03141C4.01342 7.29184 3.7344 7.49181 3.41817 7.63132C3.11124 7.76153 2.75781 7.82663 2.35788 7.82663C1.86494 7.82663 1.44175 7.75688 1.08832 7.61737C0.734886 7.46855 0.465163 7.24533 0.279146 6.94771C0.0931302 6.65008 0.00012207 6.2827 0.00012207 5.84556C0.00012207 5.45493 0.0884798 5.11545 0.265195 4.82712C0.441911 4.5388 0.720935 4.28767 1.10227 4.07376C1.4929 3.85984 1.99515 3.67847 2.609 3.52966C3.22285 3.37154 3.96692 3.23203 4.8412 3.11112ZM4.88305 7.67317L4.71563 6.11063L4.61798 6.09668V2.16244C4.61798 1.90202 4.58077 1.6881 4.50637 1.52068C4.43196 1.35327 4.30175 1.23236 4.11573 1.15795C3.93902 1.07424 3.68789 1.03239 3.36237 1.03239C2.88802 1.03239 2.49739 1.0975 2.19046 1.22771C1.88354 1.35792 1.66497 1.50208 1.53476 1.66019C1.48825 1.59509 1.46965 1.52533 1.47895 1.45093C1.48825 1.37652 1.52081 1.30676 1.57661 1.24166C1.63241 1.16725 1.71147 1.1068 1.81378 1.06029C1.91609 1.00449 2.037 0.971935 2.17651 0.962634V2.58098H0.446561V0.837073C0.586073 0.734764 0.790691 0.623154 1.06041 0.502244C1.33944 0.372033 1.68357 0.255772 2.09281 0.153463C2.51134 0.0511542 2.99033 0 3.52978 0C3.99482 0 4.41801 0.046504 4.79934 0.139512C5.18068 0.223219 5.5062 0.358081 5.77593 0.544097C6.04565 0.720813 6.25492 0.957984 6.40373 1.25561C6.55255 1.54393 6.62695 1.88806 6.62695 2.288V6.2641C6.62695 6.36641 6.6595 6.45011 6.72461 6.51522C6.79902 6.57102 6.90133 6.61753 7.03154 6.65473C7.16175 6.68263 7.31986 6.71054 7.50588 6.73844L7.58959 6.76634V7.67317H4.88305Z" fill="white"/>
      </svg>
    `,
            A.appendChild($),
            A
        }
        function d(A, $, R) {
            return Math.max($, Math.min(R, A))
        }
        if (o())
            return () => {}
            ;
        const u = i()
          , g = l();
        r.body.appendChild(g);
        const c = s();
        c && (g.style.top = c.top + "px");
        let m = !1
          , p = !1
          , h = 0
          , f = !1
          , y = 0
          , b = 0;
        function x() {
            return r.body.classList.contains("angie-sidebar-active")
        }
        const v = () => {
            !x() && !p && g.classList.add("angie-open")
        }
          , S = () => {
            p || g.classList.remove("angie-open")
        }
          , w = () => {
            if (p || f) {
                f = !1;
                return
            }
            const A = e;
            typeof A.toggleAngieSidebar == "function" && A.toggleAngieSidebar()
        }
          , _ = A => {
            if (A.key === "Enter" || A.key === " ") {
                A.preventDefault();
                const $ = e;
                typeof $.toggleAngieSidebar == "function" && $.toggleAngieSidebar()
            }
        }
          , I = A => {
            if (x() || p)
                return;
            const $ = g.getBoundingClientRect()
              , R = A.clientY >= $.top && A.clientY <= $.bottom;
            (r.documentElement.dir === "rtl" ? A.clientX >= e.innerWidth - 50 && R : A.clientX <= 50 && R) ? m || (m = !0,
            g.classList.add("angie-open")) : m && (m = !1,
            g.classList.remove("angie-open"))
        }
          , k = A => {
            A.button === 0 && (y = A.clientX,
            b = A.clientY,
            p = !0,
            g.classList.add("angie-dragging"),
            h = A.clientY - g.getBoundingClientRect().top,
            r.body.style.userSelect = "none")
        }
          , C = A => {
            if (!p)
                return;
            const R = g.getBoundingClientRect().height
              , q = e.innerHeight
              , ee = d(A.clientY - h, 0, q - R);
            g.style.top = ee + "px"
        }
          , L = A => {
            if (!p)
                return;
            const $ = Math.abs(A.clientY - b) > Id || Math.abs(A.clientX - y) > Id;
            p = !1,
            g.classList.remove("angie-dragging"),
            r.body.style.userSelect = "";
            const R = g.getBoundingClientRect();
            n(R.top),
            $ && (f = !0,
            setTimeout( () => {
                f = !1
            }
            , vw))
        }
        ;
        return g.addEventListener("mouseenter", v),
        g.addEventListener("mouseleave", S),
        g.addEventListener("click", w),
        g.addEventListener("keydown", _),
        r.addEventListener("mousemove", I),
        g.addEventListener("mousedown", k),
        e.addEventListener("mousemove", C),
        e.addEventListener("mouseup", L),
        () => {
            g.removeEventListener("mouseenter", v),
            g.removeEventListener("mouseleave", S),
            g.removeEventListener("click", w),
            g.removeEventListener("keydown", _),
            r.removeEventListener("mousemove", I),
            g.removeEventListener("mousedown", k),
            e.removeEventListener("mousemove", C),
            e.removeEventListener("mouseup", L),
            g.parentNode && g.parentNode.removeChild(g),
            u.parentNode && u.parentNode.removeChild(u),
            delete e._angieFloatingBtnInjected
        }
    }
    function bw(t) {
        window.addEventListener("load", () => {
            ww(t)
        }
        )
    }
    const Cd = ({isStudio: t}) => {
        Lv("/angie/mcp-gateway", {
            isStudioOpen: t,
            isInnerPage: !t,
            isOpen: !0,
            source: "mcp-gateway-button"
        })
    }
      , Sw = async () => {
        window.location.hash === "#angie-mcp-gateway" && (await new gd().waitForReady(),
        Cd({
            isStudio: !1
        })),
        window.addEventListener("hashchange", () => {
            window.location.hash === "#angie-mcp-gateway" && Cd({
                isStudio: !1
            })
        }
        )
    }
      , Ew = () => typeof window > "u" ? !1 : "userAgentData"in navigator && navigator.userAgentData ? navigator.userAgentData.platform === "macOS" : /mac/i.test(navigator.userAgent)
      , ni = "angie_wp_sidebar_user_intent"
      , oi = "open"
      , xw = "folded"
      , $d = "folded";
    function _w(t, e) {
        const r = e.state;
        if (Ka() !== Fn) {
            kw();
            return
        }
        Tw(r)
    }
    function Tw(t) {
        sessionStorage.setItem(ni, t)
    }
    function Pw() {
        return sessionStorage.getItem(ni)
    }
    function kw() {
        sessionStorage.removeItem(ni)
    }
    function Iw() {
        return window.getUserSetting("mfold") === "f" ? xw : oi
    }
    function Ad() {
        document.body.classList.add($d)
    }
    function Rd() {
        document.body.classList.remove($d)
    }
    function Od() {
        Ka() === Fn ? Pw() === oi ? Rd() : Ad() : Iw() === oi ? Rd() : Ad()
    }
    async function Cw() {
        await Xa(),
        Od();
        const t = window.jQuery(document);
        t.on("wp-collapse-menu", _w),
        t.on("angieSidebarToggle", Od)
    }
    const Or = {
        container: {
            marginTop: "24px"
        },
        title: {
            color: "#0C0D0E",
            fontSize: "16px",
            marginBottom: "20px",
            fontFamily: "Roboto, sans-serif"
        },
        comingSoon: {
            color: "#3F444B",
            fontSize: "13px",
            fontFamily: "Roboto, sans-serif",
            marginTop: "20px"
        },
        list: {
            display: "flex",
            flexWrap: "wrap",
            gap: "12px",
            marginBottom: "16px"
        },
        button: {
            base: `
			background: transparent;
			border: 1px solid rgba(0, 0, 0, 0.12);
			border-radius: 8px;
			padding: 6px 12px;
			font-size: 13px;
			color: rgba(0, 0, 0, 0.87);
			cursor: pointer;
			transition: all 0.2s ease;
			font-family: Roboto, sans-serif;
			font-weight: 400;
			line-height: 20px;
			white-space: nowrap;
			position: relative;
			overflow: hidden;
			display: inline-flex;
			align-items: center;
			justify-content: center;
			vertical-align: middle;
			outline: 0;
			text-decoration: none;
			-webkit-tap-highlight-color: transparent;
		`,
            hover: {
                boxShadow: "0 4px 8px 0 rgba(0, 0, 0, 0.08)",
                gradient: "linear-gradient(92deg, #4F75FF 6.65%, #8480FF 34.39%, #EB8EFB 99.52%)"
            }
        }
    }
      , $w = [{
        display: "Set site title",
        prompt: "Change site title"
    }, {
        display: "Set Language",
        prompt: "Change my site's language"
    }, {
        display: "Set Homepage",
        prompt: "Set my homepage"
    }, {
        display: "Add Page",
        prompt: "Create a new page"
    }, {
        display: "Add Post",
        prompt: "Create a new post"
    }, {
        display: "Check Comments",
        prompt: "Review latest comments on my site and summarize"
    }, {
        display: "Create Image",
        prompt: "Create an image"
    }, {
        display: "Upload Image",
        prompt: "Upload an image to the media library"
    }, {
        display: "Add Plugin",
        prompt: "Install a new plugin"
    }, {
        display: "Update Plugins",
        prompt: "Update all plugins"
    }, {
        display: "Add User",
        prompt: "Add a new user"
    }, {
        display: "Install Theme",
        prompt: "Install theme"
    }, {
        display: "Add Product",
        prompt: "Create a new product using Woocommerce"
    }, {
        display: "Add Coupon",
        prompt: "Create a new coupon"
    }, {
        display: "Suggest palettes",
        prompt: "Suggest color palettes that fit my brand"
    }, {
        display: "Suggest content",
        prompt: "Search for trending articles and suggest content ideas"
    }, {
        display: "Find Keywords",
        prompt: "Find trending keywords in my niche"
    }, {
        display: "Write your own prompt",
        prompt: "Hi Angie "
    }];
    function Aw(t, e) {
        Object.assign(t.style, e)
    }
    function Wn(t, e, r) {
        const o = document.createElement(t);
        return e && (o.className = e),
        r && Aw(o, r),
        o
    }
    function Rw(t) {
        const e = tn();
        if (!(e != null && e.contentWindow)) {
            console.error("Angie iframe not found");
            return
        }
        try {
            const r = e.src ? new URL(e.src).origin : "*";
            e.contentWindow.postMessage({
                type: sr.SDK_TRIGGER_ANGIE,
                payload: {
                    prompt: t.prompt,
                    context: {
                        source: "quick-suggestions",
                        timestamp: new Date().toISOString()
                    }
                }
            }, r)
        } catch (r) {
            console.error("Error sending suggestion to Angie:", r)
        }
    }
    function Ow(t) {
        const e = Wn("button", "angie-suggestion-chip");
        return e.style.cssText = Or.button.base,
        e.textContent = t.display,
        e.addEventListener("mouseenter", function() {
            this.style.boxShadow = Or.button.hover.boxShadow,
            this.style.background = Or.button.hover.gradient,
            this.style.webkitBackgroundClip = "text",
            this.style.webkitTextFillColor = "transparent",
            this.style.backgroundClip = "text"
        }),
        e.addEventListener("mouseleave", function() {
            this.style.boxShadow = "none",
            this.style.background = "transparent",
            this.style.webkitBackgroundClip = "initial",
            this.style.webkitTextFillColor = "initial",
            this.style.backgroundClip = "initial",
            this.style.color = "rgba(0, 0, 0, 0.87)"
        }),
        e.addEventListener("click", function(r) {
            r.preventDefault(),
            Rw(t)
        }),
        e
    }
    function Dw() {
        const t = Wn("div", "angie-quick-suggestions", Or.container)
          , e = Wn("p", void 0, Or.title);
        e.textContent = "Not sure where to start? Try one of these:",
        t.appendChild(e);
        const r = Wn("div", void 0, Or.list);
        t.appendChild(r),
        $w.forEach(n => {
            r.appendChild(Ow(n))
        }
        );
        const o = Wn("p", void 0, Or.comingSoon);
        return o.textContent = "Coming soon: Analytics report, Launch validator, Optimize SEO",
        t.appendChild(o),
        t
    }
    function Dd() {
        if (!window.location.href.includes("page=angie-app"))
            return;
        const e = document.getElementById("angie-app-start");
        if (!e || e.querySelector(".angie-quick-suggestions"))
            return;
        const r = e.querySelector("p");
        if (r) {
            const o = Dw();
            r.insertAdjacentElement("afterend", o)
        }
    }
    function Nw() {
        document.readyState === "complete" ? Nd() : window.addEventListener("load", Nd)
    }
    function Nd() {
        Dd();
        const t = document.getElementById("wpbody") || document.body
          , e = new MutationObserver(Dd);
        t && e.observe(t, {
            childList: !0,
            subtree: !0
        })
    }
    const wr = a.string().describe("WordPress post type. Common types: post, page, attachment, revision, nav_menu_item, wp_block, wp_template, wp_template_part, wp_navigation, product (WooCommerce), shop_order (WooCommerce), shop_coupon (WooCommerce), product_variation (WooCommerce). Can be any custom post type too.")
      , Ld = a.object({
        id: a.number().optional().describe("Unique identifier"),
        title: a.string().optional().describe("Post title"),
        content: a.string().optional().describe("Post content"),
        excerpt: a.string().optional().describe("Post excerpt"),
        status: a.enum(["publish", "future", "draft", "pending", "private", "trash"]).optional().default("draft").describe('A named status for the post. Use "future" for scheduled posts (requires future date), "publish" for immediate publication, "draft" for unpublished content. Valid values: publish, future, draft, pending, private, trash.'),
        type: wr.optional().default("post").describe("Post type (post, page, custom post type). Use the postType parameter in the tool instead to determine the correct endpoint."),
        author: a.number().optional().describe("Author ID"),
        featured_media: a.number().optional().describe("Featured image/media ID"),
        categories: a.array(a.number()).optional().describe("Category IDs to assign"),
        tags: a.array(a.number()).optional().describe("Tag IDs to assign"),
        date: a.string().optional().describe(`The date the post was published, in the site's timezone (ISO8601 format). This is the PUBLICATION DATE, not the last modified date. For scheduling: if this field has a future date, you can set status to "future" to schedule the post. If omitted, WordPress uses the existing date. Current/past dates with status "publish" will publish immediately.`),
        slug: a.string().optional().describe("URL slug (used in permalinks)"),
        format: a.enum(["standard", "aside", "chat", "gallery", "link", "image", "quote", "status", "video", "audio"]).optional().describe("Post format for theme styling"),
        sticky: a.boolean().optional().describe("Pin to top of blog"),
        password: a.string().optional().describe("Password to protect content"),
        parent: a.number().optional().describe("The ID for the parent of the post (for hierarchical post types like pages)"),
        menu_order: a.number().optional().describe("The order of the post in relation to other posts"),
        meta: a.record(a.unknown()).optional().describe("Custom meta fields"),
        comment_status: a.enum(["open", "closed"]).optional().describe("Allow comments"),
        ping_status: a.enum(["open", "closed"]).optional().describe("Allow pingbacks/trackbacks"),
        template: a.string().optional().describe("The theme to use to display the post")
    }).describe("WordPress post data schema")
      , Lw = a.object({
        blogname: a.string().optional().describe("Site title"),
        blogdescription: a.string().optional().describe("Site tagline"),
        siteurl: a.string().optional().describe("Site URL"),
        admin_email: a.string().optional().describe("Admin email address"),
        timezone_string: a.string().optional().describe('Timezone string (e.g., "Europe/Rome")'),
        date_format: a.string().optional().describe("Date format"),
        time_format: a.string().optional().describe("Time format"),
        start_of_week: a.union([a.string(), a.number()]).optional().describe("Day to start the week (0=Sunday, 1=Monday, etc.)"),
        WPLANG: a.string().optional().describe("WordPress locale code"),
        use_smilies: a.union([a.string(), a.boolean()]).optional().describe("Whether to convert emoticons to graphics"),
        default_category: a.union([a.string(), a.number()]).optional().describe("Default post category ID"),
        default_post_format: a.string().optional().describe("Default post format"),
        default_pingback_flag: a.union([a.string(), a.boolean()]).optional().describe("Attempt to notify any blogs linked to from the post"),
        ping_sites: a.string().optional().describe("Update services to ping when publishing new content (URLs separated by newlines)"),
        posts_per_page: a.union([a.string(), a.number()]).optional().describe("Blog pages show at most this many posts"),
        posts_per_rss: a.union([a.string(), a.number()]).optional().describe("Syndication feeds show the most recent posts"),
        rss_use_excerpt: a.union([a.string(), a.boolean()]).optional().describe("For each post in a feed, include full text or excerpt"),
        show_on_front: a.string().optional().describe('Homepage display type: "posts" shows latest blog posts (for blogs), "page" shows a static page (for business sites)'),
        page_on_front: a.union([a.string(), a.number()]).optional().describe('Page ID to use as homepage when show_on_front is "page". Creates a static homepage instead of showing blog posts'),
        page_for_posts: a.union([a.string(), a.number()]).optional().describe("Page ID that displays the blog posts index when using a static homepage"),
        blog_public: a.union([a.string(), a.boolean()]).optional().describe('Search engine visibility: "1" allows search engines to index site, "0" discourages them'),
        default_ping_status: a.string().optional().describe('Default ping status for new posts ("open" or "closed")'),
        default_comment_status: a.string().optional().describe('Default comment status for new posts ("open" or "closed")'),
        comment_registration: a.union([a.string(), a.boolean()]).optional().describe("Users must be registered and logged in to comment"),
        require_name_email: a.union([a.string(), a.boolean()]).optional().describe("Comment author must fill out name and email"),
        comment_previously_approved: a.union([a.string(), a.boolean()]).optional().describe("Comment author must have a previously approved comment"),
        close_comments_for_old_posts: a.union([a.string(), a.boolean()]).optional().describe("Automatically close comments on posts older than X days"),
        close_comments_days_old: a.union([a.string(), a.number()]).optional().describe("Days before comments are closed on old posts"),
        thread_comments: a.union([a.string(), a.boolean()]).optional().describe("Enable threaded (nested) comments"),
        thread_comments_depth: a.union([a.string(), a.number()]).optional().describe("Maximum depth for threaded comments"),
        page_comments: a.union([a.string(), a.boolean()]).optional().describe("Break comments into pages"),
        comments_per_page: a.union([a.string(), a.number()]).optional().describe("Number of top level comments per page"),
        default_comments_page: a.string().optional().describe('Comments page displayed by default ("newest" or "oldest")'),
        comment_order: a.string().optional().describe('Comments order: "asc" (older first) or "desc" (newer first)'),
        comments_notify: a.union([a.string(), a.boolean()]).optional().describe("Email me when someone posts a comment"),
        moderation_notify: a.union([a.string(), a.boolean()]).optional().describe("Email me when a comment is held for moderation"),
        comment_moderation: a.union([a.string(), a.boolean()]).optional().describe("Comment must be manually approved before appearing"),
        comment_max_links: a.union([a.string(), a.number()]).optional().describe("Hold comment for moderation if it contains this many links"),
        show_avatars: a.union([a.string(), a.boolean()]).optional().describe("Show avatars in comments"),
        avatar_rating: a.string().optional().describe("Maximum avatar rating (G, PG, R, X)"),
        avatar_default: a.string().optional().describe("Default avatar type (mystery, blank, gravatar_default, identicon, wavatar, monsterid, retro, robohash)"),
        thumbnail_size_w: a.union([a.string(), a.number()]).optional().describe("Thumbnail width in pixels"),
        thumbnail_size_h: a.union([a.string(), a.number()]).optional().describe("Thumbnail height in pixels"),
        thumbnail_crop: a.union([a.string(), a.boolean()]).optional().describe("Crop thumbnail to exact dimensions"),
        medium_size_w: a.union([a.string(), a.number()]).optional().describe("Medium image width in pixels"),
        medium_size_h: a.union([a.string(), a.number()]).optional().describe("Medium image height in pixels"),
        large_size_w: a.union([a.string(), a.number()]).optional().describe("Large image width in pixels"),
        large_size_h: a.union([a.string(), a.number()]).optional().describe("Large image height in pixels"),
        uploads_use_yearmonth_folders: a.union([a.string(), a.boolean()]).optional().describe("Organize uploads into year/month folders"),
        permalink_structure: a.string().optional().describe("Custom permalink structure (e.g., /%postname%/)"),
        category_base: a.string().optional().describe("Category URL base"),
        tag_base: a.string().optional().describe("Tag URL base"),
        users_can_register: a.union([a.string(), a.boolean()]).optional().describe("Anyone can register"),
        default_role: a.string().optional().describe("New user default role (subscriber, contributor, author, editor, administrator)"),
        wp_page_for_privacy_policy: a.union([a.string(), a.number()]).optional().describe("Privacy policy page ID"),
        site_logo: a.union([a.string(), a.number()]).optional().describe("Site logo media ID"),
        site_icon: a.union([a.string(), a.number()]).optional().describe("Site icon (favicon) media ID")
    }).describe("WordPress site settings object")
      , qn = a.enum(["view", "embed", "edit"]).optional().describe("Scope under which the request is made; determines fields present in response")
      , Gn = a.object({
        page: a.number().optional().describe("Current page of the collection"),
        per_page: a.number().optional().describe("Maximum number of items to be returned in result set"),
        offset: a.number().optional().describe("Offset the result set by a specific number of items")
    })
      , vs = a.object({
        order: a.enum(["asc", "desc"]).optional().describe("Order sort attribute ascending or descending")
    })
      , Bn = a.object({
        search: a.string().optional().describe("Limit results to those matching a string")
    })
      , ws = a.object({
        _fields: a.union([a.string(), a.array(a.string())]).optional().describe("Limit response to specific fields, for instance: _fields=id,title,content. When not asked for Content explicitly, use this to filter out content and save bandwidth. Can be a comma-separated string or array of field names")
    })
      , Uw = a.object({
        context: qn,
        ...Gn.shape,
        ...Bn.shape,
        ...vs.shape,
        ...ws.shape,
        after: a.string().optional().describe("Limit response to posts published after a given ISO8601 compliant date"),
        modified_after: a.string().optional().describe("Limit response to posts modified after a given ISO8601 compliant date"),
        author: a.union([a.number(), a.array(a.number())]).optional().describe("Limit result set to posts assigned to specific authors"),
        author_exclude: a.union([a.number(), a.array(a.number())]).optional().describe("Ensure result set excludes posts assigned to specific authors"),
        before: a.string().optional().describe("Limit response to posts published before a given ISO8601 compliant date"),
        modified_before: a.string().optional().describe("Limit response to posts modified before a given ISO8601 compliant date"),
        exclude: a.union([a.number(), a.array(a.number())]).optional().describe("Ensure result set excludes specific IDs"),
        include: a.union([a.number(), a.array(a.number())]).optional().describe("Limit result set to specific IDs"),
        orderby: a.enum(["author", "date", "id", "include", "modified", "parent", "relevance", "slug", "include_slugs", "title"]).optional().describe("Sort collection by post attribute"),
        search_columns: a.array(a.string()).optional().describe("Array of column names to be searched"),
        slug: a.union([a.string(), a.array(a.string())]).optional().describe("Limit result set to posts with one or more specific slugs"),
        status: a.union([a.enum(["any", "publish", "future", "draft", "pending", "private", "trash", "auto-draft", "inherit"]), a.string()]).optional().describe('Post status filter - defaults to "publish" only. Use "any" for all content including drafts/private, "publish,draft" for specific combinations, or individual statuses like "draft".'),
        tax_relation: a.enum(["AND", "OR"]).optional().describe("Limit result set based on relationship between multiple taxonomies"),
        categories: a.union([a.number(), a.array(a.number())]).optional().describe("Limit result set to items with specific terms assigned in the categories taxonomy"),
        categories_exclude: a.union([a.number(), a.array(a.number())]).optional().describe("Limit result set to items except those with specific terms assigned in the categories taxonomy"),
        tags: a.union([a.number(), a.array(a.number())]).optional().describe("Limit result set to items with specific terms assigned in the tags taxonomy"),
        tags_exclude: a.union([a.number(), a.array(a.number())]).optional().describe("Limit result set to items except those with specific terms assigned in the tags taxonomy"),
        sticky: a.boolean().optional().describe("Limit result set to items that are sticky")
    })
      , si = a.object({
        context: qn,
        ...Gn.shape,
        ...Bn.shape,
        ...vs.shape,
        ...ws.shape,
        exclude: a.union([a.number(), a.array(a.number())]).optional().describe("Ensure result set excludes specific IDs"),
        include: a.union([a.number(), a.array(a.number())]).optional().describe("Limit result set to specific IDs"),
        orderby: a.enum(["id", "include", "name", "slug", "term_group", "description", "count"]).optional().describe("Sort collection by term attribute"),
        hide_empty: a.boolean().optional().describe("Whether to hide terms not assigned to any posts"),
        post: a.number().optional().describe("Limit result set to terms assigned to a specific post"),
        slug: a.union([a.string(), a.array(a.string())]).optional().describe("Limit result set to terms with one or more specific slugs")
    });
    a.object({
        context: qn,
        ...Gn.shape,
        ...Bn.shape,
        ...vs.shape,
        ...ws.shape,
        exclude: a.union([a.number(), a.array(a.number())]).optional().describe("Ensure result set excludes specific IDs"),
        include: a.union([a.number(), a.array(a.number())]).optional().describe("Limit result set to specific IDs"),
        orderby: a.enum(["id", "include", "name", "slug", "term_group", "description", "count"]).optional().describe("Sort collection by term attribute"),
        hide_empty: a.boolean().optional().describe("Whether to hide terms not assigned to any posts"),
        post: a.number().optional().describe("Limit result set to terms assigned to a specific post"),
        slug: a.union([a.string(), a.array(a.string())]).optional().describe("Limit result set to terms with one or more specific slugs")
    });
    const sn = a.string().describe("WordPress taxonomy type. Common types: category, post_tag, product_cat (WooCommerce), product_tag (WooCommerce), product_type (WooCommerce). Can be any custom taxonomy too.")
      , jw = a.object({
        context: qn,
        ...Gn.shape,
        ...Bn.shape,
        ...vs.shape,
        ...ws.shape,
        after: a.string().optional().describe("Limit response to comments published after a given ISO8601 compliant date"),
        author: a.union([a.number(), a.array(a.number())]).optional().describe("Filter by author ID"),
        author_exclude: a.union([a.number(), a.array(a.number())]).optional().describe("Ensure result set excludes comments assigned to specific user IDs"),
        author_email: a.string().optional().describe("Limit result set to that from a specific author email"),
        before: a.string().optional().describe("Limit response to comments published before a given ISO8601 compliant date"),
        exclude: a.union([a.number(), a.array(a.number())]).optional().describe("Ensure result set excludes specific IDs"),
        include: a.union([a.number(), a.array(a.number())]).optional().describe("Limit result set to specific IDs"),
        orderby: a.enum(["date", "date_gmt", "id", "include", "post", "parent", "type"]).optional().describe("Order comments by"),
        parent: a.union([a.number(), a.array(a.number())]).optional().describe("Limit result set to comments of specific parent IDs"),
        parent_exclude: a.union([a.number(), a.array(a.number())]).optional().describe("Ensure result set excludes specific parent IDs"),
        post: a.union([a.number(), a.array(a.number())]).optional().describe("Limit result set to comments assigned to specific post IDs"),
        status: a.string().optional().describe("Limit result set to comments assigned a specific status"),
        type: a.string().optional().describe("Limit result set to comments assigned a specific type"),
        password: a.string().optional().describe("Password for post if it is password protected")
    })
      , Mw = a.object({
        context: qn,
        ...Gn.shape,
        ...Bn.shape,
        status: a.union([a.enum(["active", "inactive"]), a.array(a.enum(["active", "inactive"]))]).optional().describe("Limit result set to themes assigned one or more statuses")
    });
    function Fw() {
        var r;
        const t = new He({
            name: "wp-posts-server",
            version: "1.0.0"
        },{
            capabilities: {
                resources: {
                    subscribe: !0
                }
            }
        });
        ka().catch(o => {
            console.error("[WordPress Posts Server] Post type initialization failed:", o)
        }
        ),
        t.tool("wp-get-posts", 'Retrieves WordPress content items with optional filtering and pagination. Use this when browsing or searching multiple posts/pages by criteria like author, category, or keywords. IMPORTANT: For accurate total counts including drafts/private content, use status="any" and includeHeaders=true. By default returns only published content. Returns array of content objects with metadata and total counts when headers are included.', {
            ...Uw.shape,
            postType: wr.optional().default("post").describe('The post type to retrieve (e.g., "post", "page", "product", "wp_block"). Defaults to "post"'),
            includeHeaders: a.boolean().optional().default(!1).describe("Whether to include pagination headers (X-WP-Total, X-WP-TotalPages) in the response. Set to true when you need to know total counts of items.")
        }, async o => {
            const {postType: n, includeHeaders: s, ...i} = o;
            console.log("[WordPress Posts Server] wp-get-posts", {
                postType: n,
                includeHeaders: s,
                ...i
            });
            try {
                (i.search || s) && !i.status && (i.status = "any");
                const l = Et(await gr(n), i)
                  , d = await U(l, "GET", void 0, {
                    includeHeaders: s
                });
                if (s && d.totalItems !== void 0) {
                    const u = i.status || "publish";
                    return {
                        content: [{
                            type: "text",
                            text: `Total ${n} items with status "${u}": ${d.totalItems} items across ${d.totalPages || 1} pages

Response data:
${JSON.stringify(d, null, 2)}`
                        }]
                    }
                }
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(d, null, 2)
                    }]
                }
            } catch (l) {
                return console.error("[WordPress Posts Server] wp-get-posts error:", l),
                {
                    content: [{
                        type: "text",
                        text: `Error retrieving ${n} items: ${l.message}`
                    }]
                }
            }
        }
        ),
        t.tool("wp-get-post", "Fetches a specific WordPress content item by its ID and post type. Use this tool when you need complete details about a single content item (post, page, product, etc.) that you already know the ID and type for. Supports all registered post types including custom post types. Returns a single content object with its full content and metadata.", {
            id: a.number().describe("The ID of the content item to retrieve"),
            postType: wr.optional().default("post").describe('The post type of the item to retrieve (e.g., "post", "page", "product", "wp_block"). Defaults to "post"')
        }, async ({id: o, postType: n}) => {
            console.log("[WordPress Posts Server] wp-get-post", {
                id: o,
                postType: n
            });
            try {
                const s = await gr(n)
                  , i = await U(`${s}/${o}`, "GET");
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(i, null, 2)
                    }]
                }
            } catch (s) {
                return console.error("[WordPress Posts Server] wp-get-post error:", s),
                {
                    content: [{
                        type: "text",
                        text: `Error retrieving ${n} item ${o}: ${s.message}`
                    }]
                }
            }
        }
        );
        let e = ["post", "page"];
        return (r = window.angieConfig) != null && r.postTypesNames && (e = window.angieConfig.postTypesNames),
        t.tool("wp-fetch-post-meta-schema", "Checks the meta schema for a post type. Use this tool when you need to check the meta schema for a post type before creating posts.", {
            postType: a.enum(e).default("post").describe("The post type to check the meta schema for")
        }, async ({postType: o}) => {
            const n = await Rc(o);
            return {
                content: [{
                    type: "text",
                    text: JSON.stringify(n, null, 2)
                }]
            }
        }
        ),
        t.tool("wp-create-posts-bulk", `Creates multiple WordPress content items of any post type with the provided content and attributes.
All new posts are automatically saved in draft mode for review.
Use this tool when you need to programmatically add multiple content items to the site (posts, pages, etc.).
Supports all registered post types including custom post types.
Returns confirmation of the created content items with their new IDs.
Prefer using the wp-import-posts-from-file tool for uploading posts from files.
Use the most specific post type relevant for the user request, known to exist in WP eco-system, including popular plugins (e.g., "event" for event posts). If missing a known custom post type, suggest the user to install the relevant plugin.
The user may have a specific meta schema for the post type, you must use the fetch-post-meta-schema tool to get the meta schema and fill the meta fields accordingly.
This tool is not for creating product posts, use dedicated WooCommerce tools for that (if WooCommerce is not installed, suggest the user to install it).`, {
            posts: a.array(Ld.extend({
                title: a.string().describe("Post title - should be engaging and visitor-facing, suitable for public consumption. For blog posts, create compelling headlines that would attract readers."),
                content: a.string().describe('Post html content - must be polished, blog post style, and at least 500 words. Formatting rules: (1) If Gutenberg block editor is available, use Gutenberg block HTML format with proper blocks like: <!-- wp:paragraph --><p>Your paragraph text here.</p><!-- /wp:paragraph --> <!-- wp:heading {"level":2} --><h2>Your Heading</h2><!-- /wp:heading --> <!-- wp:list --><ul><li>List item 1</li><li>List item 2</li></ul><!-- /wp:list -->. (2) If Gutenberg is not available (classic editor), use standard HTML formatting like: <p>Your paragraph text here.</p><h2>Your Heading</h2><ul><li>List item 1</li><li>List item 2</li></ul>.'),
                type: a.enum(e).describe(`The post type to create. Should be relevantPostType value. You shouldn't use the generic "post" type if there is a more specific type possible (e.g. "event" for event posts). If the post type is missing, suggest installing the relevant plugin`),
                meta: a.record(a.unknown()).default({}).describe("Custom meta fields. Use the meta schema to determine and fill the relevant meta fields. In case no meta needed, leave it empty."),
                acf: a.record(a.unknown()).default({}).describe("Custom ACF fields. Use the acf schema to determine and fill the relevant ACF fields. In case no ACF needed, leave it empty.")
            })).describe("Must ask the user to provide missing parameters (title and content). Don't invent values."),
            parentId: a.number().optional().describe("The ID of the parent page under which these child pages will be created. Only if post type can be hierarchical and user asked it to be a child, provide the ID of the parent page under which these child pages will be created"),
            wasFetchPostMetaSchemaCalled: a.boolean().describe("indicates if wp-fetch-post-meta-schema tool was called, you must run it before creating posts"),
            relevantPostType: a.string().describe("The most specific post type relevant for the user request, known to exist in WP eco-system (including popular plugins)")
        }, async o => {
            if (!o.wasFetchPostMetaSchemaCalled)
                return {
                    content: [{
                        type: "text",
                        text: "LLM Instruction: You must first call the wp-fetch-post-meta-schema tool for the post type before calling wp-create-posts-bulk. This is required to determine the available meta fields and fill them appropriately for the user's request."
                    }]
                };
            const {posts: n} = o;
            console.log("[WordPress Posts Server] wp-create-post", {
                posts: n
            });
            try {
                const s = []
                  , i = []
                  , l = [];
                (await Promise.allSettled(n.map(async m => {
                    const {type: p, ...h} = m
                      , f = await gr(p, !0);
                    return h.content = h.content || "Add Your Content Here",
                    h.title = h.title || "Untitled",
                    h.status = h.status || "draft",
                    h.meta = h.meta || {},
                    h.acf = h.acf || {},
                    o.parentId && (h.parent = o.parentId),
                    U(f, "POST", h)
                }
                ))).forEach( (m, p) => {
                    m.status === "fulfilled" ? l.push({
                        id: m.value.id,
                        title: n[p].title || "Untitled",
                        type: n[p].type
                    }) : (console.error("[WordPress Posts Server] Error creating post:", m.reason),
                    i.push({
                        title: n[p].title || "Untitled",
                        error: m.reason.message
                    }))
                }
                ),
                l.forEach(m => {
                    s.push({
                        id: m.id,
                        status: "draft",
                        title: m.title,
                        type: m.type
                    })
                }
                );
                const u = s.length > 0 ? `Successfully created ${s.length} posts:
${s.map(m => `- ${m.title} (ID: ${m.id}, Status: ${m.status})`).join(`
`)}` : ""
                  , g = i.length > 0 ? `

Errors encountered:
${i.map(m => `- ${m.title}: ${m.error}`).join(`
`)}` : ""
                  , c = s.length === 1 && s[0].type === "page" ? ", Ask user what editor he would like to use to edit the page that created: Gutenberg, Elementor ?" : 'Suggest the following quick user replies: "Publish it", "Open it in editor", "Try another version"';
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify({
                            successMessage: u,
                            errorMessage: g,
                            editorQuestion: c
                        })
                    }]
                }
            } catch (s) {
                return console.error("[WordPress Posts Server] wp-create-post error:", s),
                {
                    content: [{
                        type: "text",
                        text: `Error creating posts: ${s.message}`
                    }]
                }
            }
        }
        ),
        t.tool("wp-update-post", `Updates existing WordPress content with safety protections that preserve publication status by default.
This tool modifies content that already exists in the database without accidentally changing published posts to drafts.
Use this when you need to edit existing content (posts, pages, products, etc.) while maintaining their current publication state.
To schedule a post for future publication: set both "date" to a future date/time (ISO8601 format) AND "status" to "future"
The tool will return success confirmation and automatically excludes status changes unless explicitly requested via updateStatus parameter.
Supports all registered post types including custom post types - You must specify the correct postType that matches your content (e.g., "page" for pages, "product" for WooCommerce products).
Do not use this tool to update a post that the is currently being edited in the Gutenberg editor.
`, {
            id: a.number().describe("The ID of the content item to update"),
            post: Ld.describe("The updated content data"),
            postType: wr.optional().default("post").describe('The post type of the item to update (e.g., "post", "page", "product", "wp_block"). Defaults to "post"'),
            updateStatus: a.boolean().optional().default(!1).describe("Set to true to update publication status. By default, existing status is preserved to protect live content.")
        }, async ({id: o, post: n, postType: s, updateStatus: i}) => {
            var d, u, g, c, m;
            console.log("[WordPress Posts Server] wp-update-post", {
                id: o,
                post: n,
                postType: s,
                updateStatus: i
            });
            const l = ((g = (u = (d = window.wp) == null ? void 0 : d.data) == null ? void 0 : u.select("core/editor")) == null ? void 0 : g.getCurrentPostId()) || 0;
            if (l === o)
                return {
                    content: [{
                        type: "text",
                        text: `The user is currently editing post ${l}, as an LLM - use other tools for updating on the screen as a draft and not to update the db directly.`
                    }]
                };
            try {
                const p = await gr(s)
                  , h = Of(n, i)
                  , f = await U(`${p}/${o}`, "PUT", h);
                return {
                    content: [{
                        type: "text",
                        text: `${((c = ht[s]) == null ? void 0 : c.name) || s} "${((m = f.title) == null ? void 0 : m.rendered) || "Untitled"}" (ID: ${f.id}) updated successfully.`
                    }]
                }
            } catch (p) {
                return console.error("[WordPress Posts Server] wp-update-post error:", p),
                {
                    content: [{
                        type: "text",
                        text: `Error updating ${s} ${o}: ${p.message}`
                    }]
                }
            }
        }
        ),
        t.tool("wp-get-post-templates", "Retrieves all available templates for any WordPress post type. Use this tool when you need to see what templates are available before setting a template on content items (pages, posts, custom post types, etc.). Returns an object mapping template file names to their display names.", {
            postType: wr.optional().default("page").describe('The post type to get templates for (e.g., "page", "post", "product"). Defaults to "page"')
        }, async ({postType: o}) => {
            console.log("[WordPress Posts Server] wp-get-post-templates", {
                postType: o
            });
            try {
                const n = Et("/angie/v1/page-templates", {
                    post_type: o
                })
                  , s = await U(n, "GET");
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(s, null, 2)
                    }]
                }
            } catch (n) {
                return console.error("[WordPress Posts Server] wp-get-post-templates error:", n),
                {
                    content: [{
                        type: "text",
                        text: `Error retrieving ${o} templates: ${n.message}. Note: This requires the Angie plugin with page templates endpoint.`
                    }]
                }
            }
        }
        ),
        t.tool("wp-set-post-template", "Sets the template for any WordPress content item. Use this tool when you need to change a content item's template (pages, posts, custom post types, etc.). If you get an error about invalid template, the error message will show you the valid template options available on this specific WordPress site. Use the returned mapping to find the correct template id by its name.", {
            id: a.number().describe("The ID of the content item to update"),
            template: a.string().describe("The template slug to apply, or empty string for default template"),
            postType: wr.optional().default("page").describe('The post type of the item to update (e.g., "page", "post", "product"). Defaults to "page"')
        }, async ({id: o, template: n, postType: s}) => {
            var i, l;
            console.log("[WordPress Posts Server] wp-set-post-template", {
                id: o,
                template: n,
                postType: s
            });
            try {
                const d = await gr(s)
                  , u = await U(`${d}/${o}`, "PUT", {
                    template: n
                });
                return {
                    content: [{
                        type: "text",
                        text: `${((i = ht[s]) == null ? void 0 : i.name) || s} template updated successfully. "${((l = u.title) == null ? void 0 : l.rendered) || "Untitled"}" (ID: ${o}) now uses template: "${n || "default"}".`
                    }]
                }
            } catch (d) {
                console.error("[WordPress Posts Server] wp-set-post-template error:", d);
                const u = d.message;
                return {
                    content: [{
                        type: "text",
                        text: `Error setting ${s} template for item ${o}: ${u}`
                    }]
                }
            }
        }
        ),
        t.tool("wp-delete-post", 'Removes a specific WordPress content item (individual post, page, product, etc.) from the site permanently or moves to the trash. Use this tool when you need to delete individual content items, NOT to delete post type definitions themselves. This deletes content instances, not the post type schema. For example, use this to delete "My Blog Post" (a post instance), not to delete the "post" post type itself. Supports all registered post types including custom post types. Returns confirmation that the content item was deleted successfully.', {
            id: a.number().describe("The ID of the specific content item to delete (not the post type definition, but the individual content instance)"),
            postType: wr.optional().default("post").describe('The post type that the content item belongs to (e.g., "post", "page", "product", "wp_block"). This specifies which content type the item is, not which post type definition to delete. Defaults to "post"'),
            confirmationMessage: a.string().describe(`A clear explanation of what will be deleted and its impact (this would be shown to the user before deletion to ensure they understand the consequences of this irreversible action). Example: "You're about to permanently delete the 'About Us' page. This action cannot be undone and will remove all content, potentially breaking links that reference this page."`)
        }, {
            title: "Delete Post",
            destructiveHint: !0
        }, async ({id: o, postType: n}) => {
            var s;
            console.log("[WordPress Posts Server] wp-delete-post", {
                id: o,
                postType: n
            });
            try {
                const l = `${await gr(n)}/${o}`;
                return await U(l, "DELETE"),
                {
                    content: [{
                        type: "text",
                        text: `${((s = ht[n]) == null ? void 0 : s.name) || n} ${o} deleted successfully.`
                    }]
                }
            } catch (i) {
                return console.error("[WordPress Posts Server] wp-delete-post error:", i),
                {
                    content: [{
                        type: "text",
                        text: `Error deleting ${n} ${o}: ${i.message}`
                    }]
                }
            }
        }
        ),
        t.tool("wp-get-post-types", "Retrieves all registered post types on the WordPress site with their complete configuration. Use this tool when you need to discover what content types are available before working with posts, or when you need detailed information about post type capabilities and settings. Returns an object mapping post type names to their complete schema definitions including REST endpoints, taxonomies, and capabilities.", {}, async () => {
            console.log("[WordPress Posts Server] wp-get-post-types");
            try {
                return await ka(),
                {
                    content: [{
                        type: "text",
                        text: JSON.stringify(ht, null, 2)
                    }]
                }
            } catch (o) {
                return console.error("[WordPress Posts Server] wp-get-post-types error:", o),
                {
                    content: [{
                        type: "text",
                        text: `Error retrieving post types: ${o.message}`
                    }]
                }
            }
        }
        ),
        t.tool("wp-add-post-terms", "Assigns taxonomy terms to any WordPress content type. Use this tool when you need to categorize content or add tags to it (posts, pages, products, etc.).By default, appends new terms to existing ones (append=true) to prevent data loss. Set append=false to replace all terms instead. Supports all registered post types that have taxonomies. Returns confirmation that the terms were successfully assigned to the content item. This tool is NOT for WooCommerce so **do NOT use it for WooCommerce products!**. NEVER assume a taxonomy ID, if its unknown use the taxonomy search tool.Note the order of execution if trying to assign new terms", {
            postId: a.number().describe("The content item ID"),
            taxonomy: a.string().describe('The taxonomy slug (e.g., "category", "post_tag", "product_cat")'),
            terms: a.array(a.number()).describe("Array of term IDs to assign to the content item"),
            postType: wr.optional().default("post").describe('The post type of the item to update (e.g., "post", "page", "product"). Defaults to "post"'),
            append: a.boolean().optional().default(!0).describe("Whether to append terms (true) or replace all terms (false). Defaults to true to prevent data loss.")
        }, async ({postId: o, taxonomy: n, terms: s, postType: i, append: l=!0}) => {
            var d;
            console.log("[WordPress Posts Server] wp-add-post-terms", {
                postId: o,
                taxonomy: n,
                terms: s,
                postType: i,
                append: l
            });
            try {
                const [u,g] = await Promise.all([gr(i), Ac(n)])
                  , {valid: c, invalid: m} = await Rf(n, s);
                if (m.length > 0)
                    return {
                        content: [{
                            type: "text",
                            text: `LLM Instruction: The following term IDs do not exist in the "${n}" taxonomy: [${m.join(", ")}]. Please use the wp-search-taxonomies or wp-create-taxonomy tools to find or create the missing terms first.`
                        }]
                    };
                let p = c;
                if (l) {
                    const y = (await U(`${u}/${o}`, "GET"))[g] || [];
                    p = Array.from(new Set([...y, ...c]))
                }
                const h = {
                    [g]: p
                };
                return await U(`${u}/${o}`, "PUT", h),
                {
                    content: [{
                        type: "text",
                        text: `Terms successfully ${l ? "added to" : "replaced in"} ${((d = ht[i]) == null ? void 0 : d.name) || i} ${o} for taxonomy ${n}. Field used: ${g}, Final terms: [${p.join(", ")}]`
                    }]
                }
            } catch (u) {
                return console.error("[WordPress Posts Server] wp-add-post-terms error:", u),
                {
                    content: [{
                        type: "text",
                        text: `Error adding terms to ${i} ${o} for taxonomy ${n}: ${u.message}`
                    }]
                }
            }
        }
        ),
        t.tool("wp-import-posts-from-file", `Importing posts from file into WordPress. 
Use this tool in order to add posts (or pages, products or any other custom post types) to wordpress from file, whether a CSV, XML, or other formats.`, {
            isCsvFile: a.boolean().describe("Is the file a CSV file?")
        }, async ({isCsvFile: o}) => {
            try {
                const n = {
                    importSteps: []
                };
                let s = 1;
                return o && n.importSteps.push({
                    step: s++,
                    action: "Confirm CSV column mapping",
                    description: `Parse the CSV headers yourself, generate a best-guess mapping to WordPress post fields.
Provide the complete mapping to the user and ask him to confirm it.
Do not proceed until the user confirms the mapping.`
                }),
                n.importSteps.push({
                    step: s++,
                    action: "Create missing taxonomies",
                    description: `Create any required taxonomies that don't exist.
You should use the following tools: wp-get-taxonomies, wp-get-taxonomy, wp-create-taxonomy, wp-update-taxonomy, wp-search-taxonomies.`
                }),
                n.importSteps.push({
                    step: s++,
                    action: "Create custom fields",
                    description: "Add missing custom fields. First call get-fields and then create-field tool for each field that does not exist."
                }),
                n.importSteps.push({
                    step: s++,
                    action: "Create the posts",
                    description: "Import all content as posts. Use the wp-create-post tool for each post."
                }),
                n.importSteps.push({
                    step: s++,
                    action: "Handle errors",
                    description: `If error, explain the issue to the user and suggest a solution.
For instance, if the user tries to import custom fields but you are unable to create them using ACF tools, then explain that to the user and suggest installing the ACF plugin.`
                }),
                n.importSteps.push({
                    step: s++,
                    action: "Navigate to posts page",
                    description: "Must **suggest** taking the user to see all imported posts/pages using the navigation tools (suggest only, do not do it without user consent) "
                }),
                {
                    content: [{
                        type: "text",
                        text: `You (not the user) must execute each of the following steps in order to complete the import process:
${JSON.stringify(n, null, 2)}

- You should use the available tools to execute the plan.
- Do not return the plan to the user, just execute it.
`
                    }]
                }
            } catch (n) {
                return console.error("[WordPress Posts Server] wp-import-posts-from-file error:", n),
                {
                    content: [{
                        type: "text",
                        text: `Error creating import plan: ${n.message}`
                    }]
                }
            }
        }
        ),
        t
    }
    function Ww() {
        const t = new He({
            name: "wp-taxonomy-server",
            version: "1.0.0"
        },{
            capabilities: {
                resources: {
                    subscribe: !0
                }
            }
        });
        return Ia().catch(e => {
            console.error("[WordPress Taxonomy Server] Taxonomy initialization failed:", e)
        }
        ),
        t.tool("wp-get-taxonomies", "Retrieves all registered taxonomies on the WordPress site. Use this tool to discover what classification systems (like categories and tags) are available. Returns an object mapping taxonomy names to their schema definitions.", si.shape, async e => {
            console.log("[WordPress Taxonomy Server] wp-get-taxonomies", e);
            try {
                const r = await Ia();
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(r, null, 2)
                    }]
                }
            } catch (r) {
                return console.error("[WordPress Taxonomy Server] wp-get-taxonomies error:", r),
                {
                    content: [{
                        type: "text",
                        text: `Error retrieving taxonomies: ${r.message}`
                    }]
                }
            }
        }
        ),
        t.tool("wp-get-all-taxonomies", "Retrieves all taxonomies of a specific type from the WordPress site. Use this tool when you need to get a complete list of categories, tags, or custom taxonomy terms without filtering by name or search criteria. This is ideal for populating dropdowns, displaying full taxonomy lists, or assigning all taxonomies of a kind to a post. Returns an array of all taxonomy objects for the specified type.", {
            ...si.shape,
            taxonomy: sn.optional().default("post_tag").describe('The taxonomy type to retrieve all items from (e.g., "category", "post_tag", "product_cat", "product_tag", "product_type" by WooCommerce). Defaults to "post_tag"')
        }, async e => {
            const {taxonomy: r, search: o, ...n} = e;
            console.log("[WordPress Taxonomy Server] wp-get-all-taxonomies", {
                taxonomy: r,
                ...n
            });
            try {
                const s = Et(await Ir(r), n)
                  , i = await U(s, "GET");
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(i, null, 2)
                    }]
                }
            } catch (s) {
                return console.error("[WordPress Taxonomy Server] wp-get-all-taxonomies error:", s),
                {
                    content: [{
                        type: "text",
                        text: `Error retrieving all ${r} taxonomies: ${s.message}`
                    }]
                }
            }
        }
        ),
        t.tool("wp-search-taxonomies", "Searches for taxonomies by name. Use this tool when you need to find taxonomies by their name instead of ID. Supports all registered taxonomies including custom taxonomies (e.g. product_type by WooCommerce or other custom taxonomies). Returns an array of matching taxonomy objects. NEVER assume ID, if its unknown use search", {
            ...si.shape,
            taxonomy: sn.optional().default("post_tag").describe('The taxonomy to search within (e.g., "category", "post_tag", "product_cat", "product_tag", "product_type" by WooCommerce). Defaults to "post_tag"'),
            search: a.string().describe("The taxonomy name to search for")
        }, async e => {
            const {taxonomy: r, ...o} = e;
            console.log("[WordPress Taxonomy Server] wp-search-taxonomies", {
                taxonomy: r,
                ...o
            });
            try {
                const n = Et(await Ir(r), o)
                  , s = await U(n, "GET");
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(s, null, 2)
                    }]
                }
            } catch (n) {
                return console.error("[WordPress Taxonomy Server] wp-search-taxonomies error:", n),
                {
                    content: [{
                        type: "text",
                        text: `Error searching ${r} taxonomies: ${n.message}`
                    }]
                }
            }
        }
        ),
        t.tool("wp-get-taxonomy", "Retrieves a specific WordPress taxonomy by its ID. Use this tool when you need details about a particular taxonomy (category, tag, custom taxonomy, etc., e.g. product_type by WooCommerce or other custom taxonomies). Returns a single taxonomy object with its full details.", {
            id: a.number().describe("The ID of the taxonomy to retrieve"),
            taxonomy: sn.optional().default("post_tag").describe('The taxonomy the taxonomy belongs to (e.g., "category", "post_tag", "product_cat", "product_tag", "product_type" by WooCommerce). Defaults to "post_tag"')
        }, async ({id: e, taxonomy: r}) => {
            console.log("[WordPress Taxonomy Server] wp-get-taxonomy", {
                id: e,
                taxonomy: r
            });
            try {
                const o = await Ir(r)
                  , n = await U(`${o}/${e}`, "GET");
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(n, null, 2)
                    }]
                }
            } catch (o) {
                return console.error("[WordPress Taxonomy Server] wp-get-taxonomy error:", o),
                {
                    content: [{
                        type: "text",
                        text: `Error retrieving ${r} taxonomy ${e}: ${o.message}`
                    }]
                }
            }
        }
        ),
        t.tool("wp-create-taxonomy", "Creates a new WordPress taxonomy. Use this tool when you need to add a new taxonomy (categories, tags, custom taxonomies, etc., e.g. product_type by WooCommerce or other custom taxonomies). Supports all registered taxonomies including custom taxonomies. Returns the newly created taxonomy object with its assigned ID.", {
            name: a.string().describe("The name of the taxonomy (required). The slug will be automatically generated from the name if not provided."),
            taxonomy: sn.optional().default("post_tag").describe('The taxonomy to create the taxonomy in (e.g., "category", "post_tag", "product_cat", "product_tag", "product_type" by WooCommerce). Defaults to "post_tag"'),
            description: a.string().optional().describe("The HTML description of the taxonomy"),
            slug: a.string().optional().describe("The URL-friendly slug (alphanumeric identifier). If not provided, WordPress will automatically generate one from the name. Custom slugs should be lowercase, hyphenated, and SEO-friendly."),
            parent: a.number().optional().describe("The parent taxonomy ID (for hierarchical taxonomies like categories)"),
            meta: a.record(a.any()).optional().describe("Meta fields for the taxonomy")
        }, async e => {
            var n;
            const {taxonomy: r, ...o} = e;
            console.log("[WordPress Taxonomy Server] wp-create-taxonomy", {
                taxonomy: r,
                ...o
            });
            try {
                const s = await Ir(r)
                  , i = await U(s, "POST", o);
                return {
                    content: [{
                        type: "text",
                        text: `${((n = Ft[r]) == null ? void 0 : n.name) || r} taxonomy "${i.name}" created successfully. ID: ${i.id}`
                    }]
                }
            } catch (s) {
                return console.error("[WordPress Taxonomy Server] wp-create-taxonomy error:", s),
                {
                    content: [{
                        type: "text",
                        text: `Error creating ${r} taxonomy: ${s.message}`
                    }]
                }
            }
        }
        ),
        t.tool("wp-update-taxonomy", "Modifies an existing WordPress taxonomy. Use this tool when you need to edit a taxonomy's name, description, or other attributes (categories, tags, custom taxonomies, etc., e.g. product_type by WooCommerce or other custom taxonomies). Supports all registered taxonomies including custom taxonomies. Returns the updated taxonomy object.", {
            id: a.number().describe("The ID of the taxonomy to update"),
            taxonomy: sn.optional().default("post_tag").describe('The taxonomy the taxonomy belongs to (e.g., "category", "post_tag", "product_cat", "product_tag", "product_type" by WooCommerce). Defaults to "post_tag"'),
            name: a.string().optional().describe("The updated name of the taxonomy. When updating the name, either update the slug or at least suggest to the user to update the slug to maintain URL consistency and SEO benefits."),
            description: a.string().optional().describe("The updated HTML description of the taxonomy"),
            slug: a.string().optional().describe("The updated URL-friendly slug (alphanumeric identifier). It should ALWAYS match the name for consistency (unless if explicitly stated otherwise). WordPress automatically generates slugs from names, but you can provide a custom one."),
            parent: a.number().optional().describe("The updated parent taxonomy ID (for hierarchical taxonomies)"),
            meta: a.record(a.any()).optional().describe("Updated meta fields for the taxonomy")
        }, async ({id: e, taxonomy: r, ...o}) => {
            var n;
            console.log("[WordPress Taxonomy Server] wp-update-taxonomy", {
                id: e,
                taxonomy: r,
                ...o
            });
            try {
                const s = await Ir(r)
                  , i = await U(`${s}/${e}`, "POST", o);
                return {
                    content: [{
                        type: "text",
                        text: `${((n = Ft[r]) == null ? void 0 : n.name) || r} taxonomy "${i.name}" updated successfully. ID: ${i.id}`
                    }]
                }
            } catch (s) {
                return console.error("[WordPress Taxonomy Server] wp-update-taxonomy error:", s),
                {
                    content: [{
                        type: "text",
                        text: `Error updating ${r} taxonomy ${e}: ${s.message}`
                    }]
                }
            }
        }
        ),
        t.tool("wp-delete-taxonomy", "Removes a WordPress taxonomy from the site. Use this tool when you need to delete an obsolete or mistakenly created taxonomy (categories, tags, custom taxonomies, etc., e.g. product_type by WooCommerce or other custom taxonomies). Supports all registered taxonomies including custom taxonomies. Returns confirmation that the taxonomy was deleted successfully.", {
            id: a.number().describe("The ID of the taxonomy to delete"),
            taxonomy: sn.optional().default("post_tag").describe('The taxonomy the taxonomy belongs to (e.g., "category", "post_tag", "product_cat", "product_tag", "product_type" by WooCommerce). Defaults to "post_tag"'),
            confirmationMessage: a.string().describe(`A clear explanation of what will be deleted and its impact (this would be shown to the user before deletion to ensure they understand the consequences of this irreversible action). Example: "You're about to permanently delete the 'WordPress' tag. This action cannot be undone and will remove this tag from all associated posts."`)
        }, {
            title: "Delete Taxonomy",
            destructiveHint: !0
        }, async ({id: e, taxonomy: r}) => {
            var o;
            console.log("[WordPress Taxonomy Server] wp-delete-taxonomy", {
                id: e,
                taxonomy: r
            });
            try {
                const n = await Ir(r);
                return await U(`${n}/${e}?force=true`, "DELETE"),
                {
                    content: [{
                        type: "text",
                        text: `${((o = Ft[r]) == null ? void 0 : o.name) || r} taxonomy ${e} deleted successfully.`
                    }]
                }
            } catch (n) {
                return console.error("[WordPress Taxonomy Server] wp-delete-taxonomy error:", n),
                {
                    content: [{
                        type: "text",
                        text: `Error deleting ${r} taxonomy ${e}: ${n.message}`
                    }]
                }
            }
        }
        ),
        t
    }
    function Ye(t) {
        if (!t.includes("/wp-content/uploads/"))
            throw new Error("The image URL must be from the WordPress media library (containing /wp-content/uploads/). Please select an image element first to get the correct media library URL, or use an image that has been uploaded to your WordPress media library.")
    }
    var Se = (t => (t.RESIZE_IMAGE = "resize-image",
    t.UPSCALE_IMAGE = "upscale-image",
    t.GENERATE_IMAGE = "generate-image",
    t.CUSTOM_CSS_APPROVAL = "custom-css-approval",
    t.GENERATE_LOGO = "generate-logo",
    t.GENERATE_IMAGE_VARIATIONS = "generate-image-variations",
    t.CONSENT_DIALOG = "consent-dialog",
    t.GENERATE_FEATURED_IMAGE = "generate-featured-image",
    t.MOTION_EFFECTS = "motion-effects",
    t.REMOVE_BACKGROUND = "remove-background",
    t.IMAGE_GALLERY = "image-gallery",
    t.PREVIEW_SITE_GLOBALS = "preview-site-globals",
    t.REPLACE_BACKGROUND = "replace-background",
    t.ISOLATE_OBJECT = "isolate-object",
    t.IMAGE_TOOLS_MODAL = "image-tools-modal",
    t))(Se || {});
    function qw() {
        const t = new He({
            name: "wp-media-server",
            version: "1.0.0"
        },{
            capabilities: {
                resources: {
                    subscribe: !0
                }
            }
        });
        return t.tool("wp-get-media", 'Retrieves WordPress media items with optional filtering. Use this tool when you need to browse or search for images, videos, or other uploaded files. When searching for specific images by description (e.g., "cat image"), this tool will first search by the specific term, and if no results are found, automatically fall back to showing recent images that the user might be referring to. Returns an array of media objects with their URLs and metadata.', {
            search: a.string().optional().describe('Search term for media (e.g., "cat", "logo", "product")'),
            parent: a.number().optional().describe("Filter by parent post ID"),
            mediaType: a.enum(["image", "video", "audio", "application"]).optional().describe("Filter by media type"),
            mimeType: a.string().optional().describe("Filter by MIME type"),
            page: a.number().optional().describe("Page number"),
            per_page: a.number().optional().describe("Number of media items per page"),
            orderby: a.enum(["date", "id", "include", "title", "slug"]).optional().describe("Order media by"),
            order: a.enum(["asc", "desc"]).optional().describe("Order direction")
        }, async e => {
            console.log("[WordPress Media Server] wp-get-media", e);
            try {
                const r = Et("/wp/v2/media", e)
                  , o = await U(r, "GET");
                if (e.search && Array.isArray(o) && o.length === 0) {
                    const s = await Gw(e.search, e);
                    if (s)
                        return s
                }
                const n = Nc(o);
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(n, null, 2)
                    }]
                }
            } catch (r) {
                return console.error("[WordPress Media Server] wp-get-media error:", r),
                {
                    content: [{
                        type: "text",
                        text: `Error retrieving media: ${r.message}`
                    }]
                }
            }
        }
        ),
        t.tool("wp-get-media-by-id", "Gets WordPress media library item details by media ID, including the source URL that can be used for image processing. Use this when you have a media ID and need to get the image URL for processing operations like remove background, upscale, etc.", {
            mediaId: a.number().describe("The WordPress media library ID of the image to get details for")
        }, async ({mediaId: e}) => {
            var r, o, n;
            console.log("[WordPress Media Server] wp-get-media-by-id", {
                mediaId: e
            });
            try {
                const s = await U(`/wp/v2/media/${e}`, "GET");
                if (!s || !s.source_url)
                    throw new Error(`Media item with ID ${e} not found or has no source URL`);
                const i = {
                    id: s.id,
                    title: ((r = s.title) == null ? void 0 : r.rendered) || s.slug || "Untitled",
                    alt_text: s.alt_text || "",
                    source_url: s.source_url,
                    media_type: s.media_type,
                    mime_type: s.mime_type,
                    date: s.date,
                    caption: ((o = s.caption) == null ? void 0 : o.rendered) || "",
                    description: ((n = s.description) == null ? void 0 : n.rendered) || "",
                    media_details: s.media_details
                };
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(i, null, 2)
                    }]
                }
            } catch (s) {
                return console.error("[WordPress Media Server] wp-get-media-by-id error:", s),
                {
                    content: [{
                        type: "text",
                        text: `Error retrieving media by ID ${e}: ${s.message}`
                    }]
                }
            }
        }
        ),
        t.tool("wp-upload-media", `Uploads a media file to WordPress from an external URL. Use this tool when you need to add images or other media to the site from another web location.
Also use as a fallback when an image is generated but without an explicit intent for it. Minimum viable action is uploading the image to the media library..
Returns the newly created media object with its URL and ID.`, {
            url: a.string().url().describe("The URL of the media to upload"),
            filename: a.string().optional().describe("Custom filename for the uploaded media (including extension)"),
            title: a.string().optional().describe("The title for the media item"),
            caption: a.string().optional().describe("The caption for the media item"),
            altText: a.string().optional().describe("The alt text for the media item (for images)"),
            description: a.string().optional().describe("The description for the media item")
        }, async ({url: e, filename: r, ...o}) => {
            console.log("[WordPress Media Server] wp-upload-media", {
                url: e,
                filename: r,
                ...o
            });
            try {
                const n = await Rr({
                    imageUrl: e,
                    filename: r,
                    title: o.title,
                    altText: o.altText,
                    description: o.description,
                    caption: o.caption
                });
                return {
                    content: [{
                        type: "text",
                        text: `Media "${n.title}" uploaded successfully. ID: ${n.id}, URL: ${n.url}`
                    }]
                }
            } catch (n) {
                return console.error("[WordPress Media Server] wp-upload-media error:", n),
                {
                    content: [{
                        type: "text",
                        text: `Error uploading media from URL ${e}: ${n.message}`
                    }]
                }
            }
        }
        ),
        t.tool("wp-update-media", "Modifies an existing WordPress media item. Use this tool when you need to update titles, captions, alt text, or other attributes of uploaded files. Returns confirmation that the media was updated successfully.", {
            id: a.number().describe("The ID of the media item to update"),
            title: a.object({
                raw: a.string().optional().describe("The updated title")
            }).optional().describe("The updated title"),
            caption: a.object({
                raw: a.string().optional().describe("The updated caption")
            }).optional().describe("The updated caption"),
            alt_text: a.string().optional().describe("The updated alt text (for images)"),
            description: a.object({
                raw: a.string().optional().describe("The updated description")
            }).optional().describe("The updated description")
        }, async ({id: e, ...r}) => {
            var o;
            console.log("[WordPress Media Server] wp-update-media", {
                id: e,
                ...r
            });
            try {
                const n = await U(`/wp/v2/media/${e}`, "PUT", r);
                return {
                    content: [{
                        type: "text",
                        text: `Media "${((o = n.title) == null ? void 0 : o.rendered) || "Untitled"}" (ID: ${n.id}) updated successfully.`
                    }]
                }
            } catch (n) {
                return console.error("[WordPress Media Server] wp-update-media error:", n),
                {
                    content: [{
                        type: "text",
                        text: `Error updating media ${e}: ${n.message}`
                    }]
                }
            }
        }
        ),
        t.tool("wp-delete-media", "Removes a media item from the WordPress library. Use this tool when you need to delete unwanted images or files. Returns confirmation that the media was deleted successfully.", {
            id: a.number().describe("The ID of the media item to delete"),
            force: a.boolean().optional().default(!1).describe("Whether to bypass trash and force deletion"),
            confirmationMessage: a.string().describe(`A clear explanation of what will be deleted and its impact (this would be shown to the user before deletion to ensure they understand the consequences of this irreversible action). Example: "You're about to permanently delete the 'hero-banner.jpg' image. This action cannot be undone and will break any pages or posts that display this image."`)
        }, {
            title: "Delete Media",
            destructiveHint: !0
        }, async ({id: e, force: r}) => {
            console.log("[WordPress Media Server] wp-delete-media", {
                id: e,
                force: r
            });
            try {
                const o = `/wp/v2/media/${e}${r ? "?force=1" : ""}`;
                return await U(o, "DELETE"),
                {
                    content: [{
                        type: "text",
                        text: `Media ${e} deleted successfully.`
                    }]
                }
            } catch (o) {
                return console.error("[WordPress Media Server] wp-delete-media error:", o),
                {
                    content: [{
                        type: "text",
                        text: `Error deleting media ${e}: ${o.message}`
                    }]
                }
            }
        }
        ),
        t.tool("wp-set-featured-image", `Sets or removes the WordPress post featured image from an image URL. Use this tool when the user asks to set a featured image for a post, whether if he is in wordpress admin, elementor, or gutenberg. 
If the user asks to generate an image which is meant to be a featured image, use the generate-image tool for generation and then use this tool to set the generated image as featured image.
Do NOT use for other non-featured images.
Returns confirmation that the featured image was set or removed successfully. `, {
            postId: a.number().describe("The ID of the post to update"),
            imageUrl: a.string().url().optional().describe("The URL of the image to set as featured image (omit to remove featured image). Can be any public image URL - MCP server will handle upload to WordPress media library."),
            filename: a.string().optional().describe("Custom filename for the uploaded image (defaults to extracted from URL)"),
            title: a.string().optional().describe("Title for the media library entry (defaults to filename)"),
            altText: a.string().optional().describe("Alt text for accessibility (defaults to title)")
        }, async ({postId: e, imageUrl: r, filename: o, title: n, altText: s}) => {
            var i, l;
            console.log("[WordPress Media Server] wp-set-featured-image", {
                postId: e,
                imageUrl: r,
                filename: o
            });
            try {
                if (!r)
                    return {
                        content: [{
                            type: "text",
                            text: `Featured image removed from post "${((i = (await U(`/wp/v2/posts/${e}`, "PUT", {
                                featured_media: 0
                            })).title) == null ? void 0 : i.rendered) || "Untitled"}" (ID: ${e}).`
                        }]
                    };
                const u = (await Rr({
                    imageUrl: r,
                    filename: o,
                    title: n,
                    altText: s
                })).id;
                console.log("[WordPress Media Server] Featured image uploaded with ID:", u);
                const g = await U(`/wp/v2/posts/${e}`, "PUT", {
                    featured_media: u
                });
                return {
                    content: [{
                        type: "text",
                        text: `Featured image (ID: ${u}) set for post "${((l = g.title) == null ? void 0 : l.rendered) || "Untitled"}" (ID: ${e}).`
                    }]
                }
            } catch (d) {
                return console.error("[WordPress Media Server] wp-set-featured-image error:", d),
                {
                    content: [{
                        type: "text",
                        text: `Error setting featured image for post ${e}: ${d.message}`
                    }]
                }
            }
        }
        ),
        t.tool("remove-background-from-image", "This tool removes the background from existing images and uploads the result to the WordPress media library. Use this when users want to remove the background from a photo, product image, or any image to isolate the main subject and save it as a new media file. The tool processes the image and uploads the background-removed version to the media library without applying it to any specific element.", {
            imageUrl: a.string().url().describe("The URL of the existing image from the WordPress media library to remove background from. Must be a media library URL (containing /wp-content/uploads/). If you don't have the media library URL, ask the user to select an image element first so you have the correct context."),
            platform: a.enum(["elementor", "gutenberg", "wordpress"]).describe("The platform where the image is located")
        }, async ({imageUrl: e, platform: r}) => {
            try {
                if (console.log("[WordPress Media Server] Processing background removal request for:", e),
                r !== "wordpress")
                    throw new Error(`This tool can only be used on WordPress, please use the appropriate tool meant for ${r} instead`);
                Ye(e);
                const o = {
                    name: Se.REMOVE_BACKGROUND,
                    imageUrl: e,
                    context: "wp",
                    supportsPreview: !1
                }
                  , n = await xe(o);
                return console.log("[WordPress Media Server] Background removal result:", n),
                {
                    content: [{
                        type: "text",
                        text: JSON.stringify(n)
                    }]
                }
            } catch (o) {
                return console.error("[WordPress Media Server] Error removing background:", o),
                {
                    content: [{
                        type: "text",
                        text: `Error removing background from image: ${oinstanceof Error ? o.message : String(o)}`
                    }]
                }
            }
        }
        ),
        t.tool("upscale-image", "This tool upscales and resizes existing images using AI to increase resolution and improve quality, then uploads the result to the WordPress media library. Use this when users want to: upscale images, resize images to larger dimensions, enhance image quality, increase resolution, make images bigger/larger, scale up images, enlarge images, improve image sharpness, or change image size to specific dimensions. Supports any resolution from 512px to 2048px in 256px steps.", {
            imageUrl: a.string().url().describe("The URL of the existing image from the WordPress media library to upscale. Must be a media library URL (containing /wp-content/uploads/). If you don't have the media library URL, ask the user to select an image element first so you have the correct context."),
            resolution: a.number().min(512).max(2048).describe("REQUIRED: The exact resolution for the upscaled image. Choose from: 512, 768, 1024, 1280, 1536, 1792, 2048. Higher resolutions create larger, more detailed images."),
            platform: a.enum(["elementor", "gutenberg", "wordpress"]).describe("The platform where the image is located")
        }, async ({imageUrl: e, resolution: r, platform: o}) => {
            try {
                if (console.log("[WordPress Media Server] Processing image upscale request for:", e),
                o !== "wordpress")
                    throw new Error(`This tool can only be used on WordPress, please use the appropriate tool meant for ${o} instead`);
                Ye(e);
                const n = {
                    name: Se.UPSCALE_IMAGE,
                    imageUrl: e,
                    resolution: r,
                    context: "wp",
                    supportsPreview: !1
                }
                  , s = await xe(n);
                return console.log("[WordPress Media Server] Image upscale result:", s),
                {
                    content: [{
                        type: "text",
                        text: JSON.stringify(s)
                    }]
                }
            } catch (n) {
                return console.error("[WordPress Media Server] Error upscaling image:", n),
                {
                    content: [{
                        type: "text",
                        text: `Error upscaling image: ${ninstanceof Error ? n.message : String(n)}`
                    }]
                }
            }
        }
        ),
        t.tool("replace-background-from-image", "This tool replaces the background of existing images with a new AI-generated background based on a text prompt and uploads the result to the WordPress media library. Use this when users want to change or manipulate the background scene of a photo while keeping the main subject intact.", {
            imageUrl: a.string().url().describe("The URL of the existing image from the WordPress media library to replace or manipulate the background of. Must be a media library URL (containing /wp-content/uploads/). If you don't have the media library URL, ask the user to select an image element first so you have the correct context."),
            backgroundPrompt: a.string().describe('A description of the new background to generate (e.g., "a beautiful sunset over mountains", "modern office space", "tropical beach")'),
            platform: a.enum(["elementor", "gutenberg", "wordpress"]).describe("The platform where the image is located")
        }, async ({imageUrl: e, backgroundPrompt: r, platform: o}) => {
            try {
                if (console.log("[WordPress Media Server] Processing background replacement request for:", e),
                o !== "wordpress")
                    throw new Error(`This tool can only be used on WordPress, please use the appropriate tool meant for ${o} instead`);
                Ye(e);
                const n = {
                    name: Se.REPLACE_BACKGROUND,
                    imageUrl: e,
                    backgroundPrompt: r,
                    context: "wp",
                    supportsPreview: !1
                }
                  , s = await xe(n);
                return console.log("[WordPress Media Server] Background replacement result:", s),
                {
                    content: [{
                        type: "text",
                        text: JSON.stringify(s)
                    }]
                }
            } catch (n) {
                return console.error("[WordPress Media Server] Error replacing background:", n),
                {
                    content: [{
                        type: "text",
                        text: `Error replacing background from image: ${ninstanceof Error ? n.message : String(n)}`
                    }]
                }
            }
        }
        ),
        t.tool("generate-variation-for-existing-image", 'This tool transforms and modifies existing images based on user instructions and uploads the result to the WordPress media library. Use this when users want to change, modify, or transform an image they already have - whether they want style variations, color changes (like "make this black and white"), artistic transformations, or different creative interpretations of the same subject. This is the go-to tool for any image modification request where the user has an existing image and wants it altered in some way.', {
            prompt: a.string().describe(`Instructions for how to modify the image based on what the user actually wants to achieve. Understand the user's intent and perspective - if they want something "grim and dark," describe the visual elements that create that feeling. The prompt should capture the essence of their request, not just repeat their exact words. Focus on translating their vision into clear visual directions for the image transformation.`),
            imageUrl: a.string().url().describe("The URL of the existing image from the WordPress media library to create variations from. Must be a media library URL (containing /wp-content/uploads/). If you don't have the media library URL, ask the user to select an image element first so you have the correct context."),
            platform: a.enum(["elementor", "gutenberg", "wordpress"]).describe("The platform where the image is located")
        }, async ({imageUrl: e, prompt: r, platform: o}) => {
            try {
                if (console.log("[WordPress Media Server] Processing image variations request for:", e),
                o !== "wordpress")
                    throw new Error(`This tool can only be used on WordPress, please use the appropriate tool meant for ${o} instead`);
                Ye(e);
                const n = {
                    name: Se.GENERATE_IMAGE_VARIATIONS,
                    imageUrl: e,
                    prompt: r,
                    supportsPreview: !1,
                    context: "wp"
                }
                  , s = await xe(n);
                return console.log("[WordPress Media Server] Image variations result:", s),
                {
                    content: [{
                        type: "text",
                        text: JSON.stringify(s)
                    }]
                }
            } catch (n) {
                return console.error("[WordPress Media Server] Error generating image variations:", n),
                {
                    content: [{
                        type: "text",
                        text: `Error generating image variations: ${ninstanceof Error ? n.message : String(n)}`
                    }]
                }
            }
        }
        ),
        t.tool("wp-set-site-logo", `Sets or removes the WordPress site logo from an image URL. Use this tool when the user asks to set a site logo, company logo, or brand logo for their WordPress site. 
		If the user asks to generate a logo which is meant to be the site logo:
		1. Use the generate-image tool for generation with prompt: 'Create a logo for "\${ brandName }" which is a \${ sitePurpose }. Use \${ colorPreferences } color scheme. \${ additionalDetails || '' }'
		2. Then use this tool to set the generated image as site logo.
		Returns confirmation that the site logo was set or removed successfully.`, {
            imageUrl: a.string().url().describe("The URL of the image to set as site logo (omit to remove site logo). Can be any public image URL - MCP server will handle upload to WordPress media library."),
            filename: a.string().optional().describe("Custom filename for the uploaded image (defaults to extracted from URL)"),
            title: a.string().optional().describe('Title for the media library entry (defaults to "Site Logo")'),
            altText: a.string().optional().describe('Alt text for accessibility (defaults to "Site Logo")')
        }, async ({imageUrl: e, filename: r, title: o, altText: n}) => {
            console.log("[WordPress Media Server] wp-set-site-logo", {
                imageUrl: e,
                filename: r
            });
            try {
                const i = (await Rr({
                    imageUrl: e,
                    filename: r || "site-logo.png",
                    title: o || "Site Logo",
                    altText: n || "Site Logo"
                })).id;
                return console.log("[WordPress Media Server] Site logo uploaded with ID:", i),
                await U("/angie/v1/wp-options", "POST", {
                    options: {
                        site_logo: i
                    }
                }),
                {
                    content: [{
                        type: "text",
                        text: `Site logo set successfully. Image (ID: ${i}) is now your site logo.`
                    }]
                }
            } catch (s) {
                throw console.error("[WordPress Media Server] wp-set-site-logo error:", s),
                new Error(`Failed to set site logo: ${sinstanceof Error ? s.message : String(s)}`)
            }
        }
        ),
        t
    }
    async function Gw(t, e) {
        try {
            console.log(`[WordPress Media Server] No results for search term "${t}", fetching last uploaded media`);
            const r = {
                ...e,
                search: void 0,
                mediaType: "image",
                per_page: 5,
                orderby: "date",
                order: "desc"
            }
              , o = Et("/wp/v2/media", r)
              , n = await U(o, "GET");
            if (Array.isArray(n) && n.length > 0) {
                const s = Nc(n);
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify({
                            searchTerm: t,
                            found: 0,
                            fallbackStrategy: "recent_images",
                            fallbackResults: Array.isArray(s) ? s.length : 1,
                            message: `No images found matching "${t}". Here are the most recent images that might match what you're looking for:`,
                            media: s
                        }, null, 2)
                    }]
                }
            }
        } catch (r) {
            console.error("[WordPress Media Server] Fallback search failed:", r)
        }
        return null
    }
    function Bw() {
        const t = new He({
            name: "wp-users-server",
            version: "1.0.0"
        },{
            capabilities: {
                resources: {
                    subscribe: !0
                }
            }
        });
        return t.tool("wp-get-users", "Retrieves a list of WordPress users with optional filtering. Use this tool when you need to browse or search for users on the site. Returns an array of user objects with their profiles and metadata.", {
            search: a.string().optional().describe("Search term for users"),
            role: a.string().optional().describe("User role to filter by"),
            page: a.number().optional().describe("Page number"),
            per_page: a.number().optional().describe("Number of users per page"),
            orderby: a.enum(["id", "name", "registered_date", "email"]).optional().describe("Order users by"),
            order: a.enum(["asc", "desc"]).optional().describe("Order direction")
        }, async e => {
            console.log("[WordPress Users Server] wp-get-users", e);
            try {
                const r = Et("/wp/v2/users", e)
                  , o = await U(r, "GET");
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(o, null, 2)
                    }]
                }
            } catch (r) {
                return console.error("[WordPress Users Server] wp-get-users error:", r),
                {
                    content: [{
                        type: "text",
                        text: `Error retrieving users: ${r.message}`
                    }]
                }
            }
        }
        ),
        t.tool("wp-create-user", "Creates a new WordPress user account. Use this tool when you need to add a new user to the site with specific roles and credentials. Returns the newly created user object with its assigned ID.", {
            username: a.string().describe("The username for the new user"),
            email: a.string().email().describe("The email address for the new user"),
            password: a.string().describe("The password for the new user"),
            name: a.string().optional().describe("The display name for the new user"),
            first_name: a.string().optional().describe("The first name for the new user"),
            last_name: a.string().optional().describe("The last name for the new user"),
            roles: a.array(a.string().toLowerCase()).optional().describe("The roles to assign to the new user")
        }, async e => {
            console.log("[WordPress Users Server] wp-create-user", {
                ...e,
                password: "[REDACTED]"
            });
            try {
                const r = await U("/wp/v2/users", "POST", e);
                return {
                    content: [{
                        type: "text",
                        text: `User "${r.name}" created successfully. ID: ${r.id}`
                    }]
                }
            } catch (r) {
                return console.error("[WordPress Users Server] wp-create-user error:", r),
                {
                    content: [{
                        type: "text",
                        text: `Error creating user: ${r.message}`
                    }]
                }
            }
        }
        ),
        t.tool("wp-update-user", "Modifies an existing WordPress user account. Use this tool when you need to update a user's profile information, email, or roles. Returns confirmation that the user was updated successfully.", {
            id: a.number().describe("The ID of the user to update"),
            email: a.string().email().optional().describe("The updated email address"),
            name: a.string().optional().describe("The updated display name"),
            first_name: a.string().optional().describe("The updated first name"),
            last_name: a.string().optional().describe("The updated last name"),
            roles: a.array(a.string().toLowerCase()).optional().describe("The updated roles")
        }, async ({id: e, ...r}) => {
            const o = {
                ...r
            };
            "password"in o && (o.password = "[REDACTED]"),
            console.log("[WordPress Users Server] wp-update-user", {
                id: e,
                ...o
            });
            try {
                if ((await U("/wp/v2/users/me", "GET")).id === e && r.roles)
                    return {
                        content: [{
                            type: "text",
                            text: "Error: Cannot change your own role. Users cannot modify their own role permissions."
                        }]
                    };
                const s = await U(`/wp/v2/users/${e}`, "PUT", r);
                return {
                    content: [{
                        type: "text",
                        text: `User "${s.name}" (ID: ${s.id}) updated successfully.`
                    }]
                }
            } catch (n) {
                return console.error("[WordPress Users Server] wp-update-user error:", n),
                {
                    content: [{
                        type: "text",
                        text: `Error updating user ${e}: ${n.message}`
                    }]
                }
            }
        }
        ),
        t.tool("wp-get-comments", "Retrieves WordPress comments with optional filtering. Use this tool when you need to browse or search for comments on posts. Returns an array of comment objects with their content and metadata.", jw.shape, async e => {
            console.log("[WordPress Users Server] wp-get-comments", e);
            try {
                const r = Et("/wp/v2/comments", e)
                  , o = await U(r, "GET");
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(o, null, 2)
                    }]
                }
            } catch (r) {
                return console.error("[WordPress Users Server] wp-get-comments error:", r),
                {
                    content: [{
                        type: "text",
                        text: `Error retrieving comments: ${r.message}`
                    }]
                }
            }
        }
        ),
        t.tool("wp-create-comment", "Creates a new comment on a WordPress post. Use this tool when you need to programmatically add feedback or responses to content. Returns the newly created comment object with its assigned ID.", {
            post: a.number().describe("The post ID to add the comment to"),
            content: a.string().describe("The comment content"),
            author: a.number().optional().describe("The author ID (if authenticated)"),
            authorName: a.string().optional().describe("The author name (if not authenticated)"),
            authorEmail: a.string().email().optional().describe("The author email (if not authenticated)"),
            authorUrl: a.string().url().optional().describe("The author URL (if not authenticated)"),
            parent: a.number().optional().describe("The parent comment ID (for replies)")
        }, async e => {
            console.log("[WordPress Users Server] wp-create-comment", e);
            try {
                return {
                    content: [{
                        type: "text",
                        text: `Comment created successfully. ID: ${(await U("/wp/v2/comments", "POST", e)).id}`
                    }]
                }
            } catch (r) {
                return console.error("[WordPress Users Server] wp-create-comment error:", r),
                {
                    content: [{
                        type: "text",
                        text: `Error creating comment: ${r.message}`
                    }]
                }
            }
        }
        ),
        t.tool("wp-update-comment", "Modifies an existing WordPress comment. Use this tool when you need to edit comment content or change its approval status. Returns confirmation that the comment was updated successfully.", {
            id: a.number().describe("The ID of the comment to update"),
            content: a.string().optional().describe("The updated comment content"),
            status: a.enum(["approved", "hold", "spam", "trash"]).optional().describe("The updated comment status")
        }, async ({id: e, ...r}) => {
            console.log("[WordPress Users Server] wp-update-comment", {
                id: e,
                ...r
            });
            try {
                return {
                    content: [{
                        type: "text",
                        text: `Comment ID: ${(await U(`/wp/v2/comments/${e}`, "PUT", r)).id} updated successfully.`
                    }]
                }
            } catch (o) {
                return console.error("[WordPress Users Server] wp-update-comment error:", o),
                {
                    content: [{
                        type: "text",
                        text: `Error updating comment ${e}: ${o.message}`
                    }]
                }
            }
        }
        ),
        t.tool("wp-delete-comment", "Removes a WordPress comment from a post. Use this tool when you need to delete inappropriate or spam comments. Returns confirmation that the comment was deleted successfully.", {
            id: a.number().describe("The ID of the comment to delete"),
            force: a.boolean().optional().default(!1).describe("Whether to bypass trash and force deletion"),
            confirmationMessage: a.string().describe(`A clear explanation of what will be deleted and its impact (this would be shown to the user before deletion to ensure they understand the consequences of this irreversible action). Example: "You're about to permanently delete a comment by John Smith. This action cannot be undone and will remove the comment from the discussion thread."`)
        }, {
            title: "Delete Comment",
            destructiveHint: !0
        }, async ({id: e, force: r}) => {
            console.log("[WordPress Users Server] wp-delete-comment", {
                id: e,
                force: r
            });
            try {
                const o = `/wp/v2/comments/${e}${r ? "&force=true" : ""}`;
                return await U(o, "DELETE"),
                {
                    content: [{
                        type: "text",
                        text: `Comment ${e} deleted successfully.`
                    }]
                }
            } catch (o) {
                return console.error("[WordPress Users Server] wp-delete-comment error:", o),
                {
                    content: [{
                        type: "text",
                        text: `Error deleting comment ${e}: ${o.message}`
                    }]
                }
            }
        }
        ),
        t.tool("wp-delete-user", "Permanently removes a WordPress user account from the site. Use this tool when you need to delete a user account that is no longer needed. This action will remove the user and optionally reassign their content to another user. Returns confirmation that the user was deleted successfully.", {
            id: a.number().describe("The ID of the user to delete"),
            reassign: a.number().nullable().describe("The ID of the user to reassign content to (optional)"),
            confirmationMessage: a.string().optional().describe(`A clear explanation of what will be deleted and its impact (this would be shown to the user before proceeding to ensure they understand the consequences of this action). Example: "You're about to permanently delete the user 'John Smith'. This action cannot be undone and will remove their account and all associated data."`)
        }, {
            title: "Delete User",
            destructiveHint: !0
        }, async ({id: e, reassign: r}) => {
            console.log("[WordPress Users Server] wp-delete-user", {
                id: e,
                reassign: r
            });
            try {
                if ((await U("/wp/v2/users/me", "GET")).id === e)
                    return {
                        content: [{
                            type: "text",
                            text: "Error: Cannot delete current user. You cannot delete your own account while logged in."
                        }]
                    };
                const s = `/wp/v2/users/${e}?reassign=${r !== null ? r : !1}&force=true`;
                return await U(s, "DELETE"),
                {
                    content: [{
                        type: "text",
                        text: `User ${e} deleted successfully.`
                    }]
                }
            } catch (o) {
                return console.error("[WordPress Users Server] wp-delete-user error:", o),
                {
                    content: [{
                        type: "text",
                        text: `Error deleting user ${e}: ${o.message}`
                    }]
                }
            }
        }
        ),
        t
    }
    function zw() {
        const t = new He({
            name: "wp-admin-server",
            version: "1.0.0"
        },{
            capabilities: {
                resources: {
                    subscribe: !0
                }
            }
        });
        return t.tool("wp-get-settings", "Retrieves WordPress site settings. Use this tool when you need to access configuration values like site title, description, timezone, etc. Returns all available site settings in a single response.", {}, async () => {
            try {
                const e = await U("/angie/v1/wp-options", "GET");
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify({
                            settings: e
                        }, null, 2)
                    }]
                }
            } catch (e) {
                throw console.error("[WordPress Admin Server] wp-get-settings error:", e),
                e
            }
        }
        ),
        t.tool("wp-update-settings", "Updates WordPress site settings across all admin categories. Use this tool when you need to modify any configuration accessible through the WordPress Settings tab, including general site settings (title, tagline, admin email), reading settings (posts per page, RSS settings), discussion settings (comments, pingbacks), media settings (image sizes, upload organization), permalink structure, user registration settings, and privacy options. This tool can update multiple settings simultaneously in a single operation. Returns confirmation of successful updates.", {
            ...Lw.shape,
            confirmationMessage: a.string().optional().describe(`If WPLANG is changed then provide a clear explanation of what will be changed and its impact (this would be shown to the user before proceeding to ensure they understand the consequences of this action). Example: "You're about to change the site language to Spanish. This action will affect how the website looks and behaves for all users."`)
        }, {
            title: "Update Site Settings",
            destructiveHint: !0
        }, async ({confirmationMessage: e, ...r}) => {
            console.log("[WordPress Admin Server] wp-update-settings", {
                settings: r,
                confirmationMessage: e
            });
            try {
                return r.WPLANG === "en_US" && (r.WPLANG = ""),
                await U("/angie/v1/wp-options", "POST", {
                    options: r
                }),
                {
                    content: [{
                        type: "text",
                        text: "Site settings updated successfully."
                    }]
                }
            } catch (o) {
                throw console.error("[WordPress Admin Server] wp-update-settings error:", o),
                o
            }
        }
        ),
        t.tool("wp-get-site-health", "Retrieves WordPress Site Health Status information from Tools > Site Health. This tool provides a comprehensive health check of the WordPress installation, identifying critical issues that may impact performance or security, recommended improvements for better site operation, and passed tests. Use this when you need to diagnose site problems, check for security vulnerabilities, verify proper WordPress configuration, or get an overall health score. The tool returns categorized issues with their severity levels (critical/recommended), affected areas (Performance/Security), and detailed descriptions of each problem.", {}, async () => {
            console.log("[WordPress Admin Server] wp-get-site-health");
            try {
                const e = await U("/angie/v1/wp-options/health", "GET");
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(e, null, 2)
                    }]
                }
            } catch (e) {
                throw console.error("[WordPress Admin Server] wp-get-site-health error:", e),
                e
            }
        }
        ),
        t
    }
    function Zw() {
        const t = new He({
            name: "theme-installation-server",
            version: "1.0.0"
        },{
            capabilities: {
                resources: {
                    subscribe: !0
                }
            }
        });
        return t.tool("wp-get-themes", "Retrieves a list of WordPress themes with optional filtering. Use this tool when you need to see what themes are available or active on the site.", Mw.shape, async e => {
            console.log("[Theme Installation Server] wp-get-themes", e);
            try {
                const r = Et("/wp/v2/themes", e)
                  , o = await U(r, "GET");
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(o, null, 2)
                    }]
                }
            } catch (r) {
                return console.error("[Theme Installation Server] wp-get-themes error:", r),
                {
                    content: [{
                        type: "text",
                        text: `Error retrieving themes: ${r.message}`
                    }]
                }
            }
        }
        ),
        t.tool("wp-get-theme", "Fetches a specific WordPress theme by its stylesheet name. Use this tool when you need complete details about a single theme. Returns a single theme object with its full details and status.", {
            stylesheet: a.string().describe("The stylesheet name of the theme to retrieve")
        }, async ({stylesheet: e}) => {
            console.log("[Theme Installation Server] wp-get-theme", {
                stylesheet: e
            });
            try {
                const r = await U(`/wp/v2/themes/${e}`, "GET");
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(r, null, 2)
                    }]
                }
            } catch (r) {
                return console.error("[Theme Installation Server] wp-get-theme error:", r),
                {
                    content: [{
                        type: "text",
                        text: `Error retrieving theme ${e}: ${r.message}`
                    }]
                }
            }
        }
        ),
        t.tool("wp-search-themes", "Searches the WordPress.org theme repository for themes. Use this tool when you need to find themes that are available for installation. Returns a list of themes matching the search criteria.", {
            search: a.string().describe("Search term to filter themes by name"),
            page: a.number().optional().describe("Page number of the collection"),
            per_page: a.number().optional().describe("Number of themes to return per page")
        }, async e => {
            console.log("[Theme Installation Server] wp-search-themes", e);
            try {
                const r = Et("/angie/v1/themes/search", e)
                  , o = await U(r, "GET");
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(o, null, 2)
                    }]
                }
            } catch (r) {
                return console.error("[Theme Installation Server] wp-search-themes error:", r),
                {
                    content: [{
                        type: "text",
                        text: `Error searching themes: ${r.message}`
                    }]
                }
            }
        }
        ),
        t.tool("wp-get-theme-info", "Fetches information about a theme from WordPress.org. Use this tool when you need details about a theme before installing it. Returns comprehensive information about the theme.", {
            slug: a.string().describe("The slug of the theme to get information about")
        }, async ({slug: e}) => {
            console.log("[Theme Installation Server] wp-get-theme-info", {
                slug: e
            });
            try {
                const r = await U(`/angie/v1/themes/info/${e}`, "GET");
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(r, null, 2)
                    }]
                }
            } catch (r) {
                return console.error("[Theme Installation Server] wp-get-theme-info error:", r),
                {
                    content: [{
                        type: "text",
                        text: `Error getting theme info for ${e}: ${r.message}`
                    }]
                }
            }
        }
        ),
        t.tool("wp-get-theme-update-info", "Fetches information about available updates for any installed theme. Use this tool when you need to see if a given theme has any updates available. If no slug is provided, it will return information about all installed themes.", {
            slug: a.string().optional().describe("The slug of the theme to get update information about")
        }, async ({slug: e}) => {
            console.log("[Theme Installation Server] wp-get-theme-update-info", {
                slug: e
            });
            try {
                const r = await U("/angie/v1/themes/update-info", "GET", {
                    slug: e
                });
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(r, null, 2)
                    }]
                }
            } catch (r) {
                return console.error("[Theme Installation Server] wp-get-theme-update-info error:", r),
                {
                    content: [{
                        type: "text",
                        text: `Error getting theme update info for ${e}: ${r.message}`
                    }]
                }
            }
        }
        ),
        t.tool("wp-install-theme", "Installs a WordPress theme from the WordPress.org theme directory or a provided ZIP URL. Use this tool when you need to add a new theme to the site. Returns confirmation of the installed theme with its details.", {
            slug: a.string().describe("The slug of the theme to install from WordPress.org")
        }, async ({slug: e}) => {
            console.log("[Theme Installation Server] wp-install-theme", {
                slug: e
            });
            try {
                return {
                    content: [{
                        type: "text",
                        text: `Theme "${(await U("/angie/v1/themes/install", "POST", {
                            slug: e
                        })).name || e}" installed successfully.`
                    }]
                }
            } catch (r) {
                return console.error("[Theme Installation Server] wp-install-theme error:", r),
                {
                    content: [{
                        type: "text",
                        text: `Error installing theme: ${r.message}`
                    }]
                }
            }
        }
        ),
        t.tool("wp-activate-theme", "Activates an installed WordPress theme. Use this tool when you need to switch the active theme on the site. Returns confirmation that the theme was activated successfully.", {
            stylesheet: a.string().describe("The stylesheet name of the theme to activate")
        }, async ({stylesheet: e}) => {
            console.log("[Theme Installation Server] wp-activate-theme", {
                stylesheet: e
            });
            try {
                return {
                    content: [{
                        type: "text",
                        text: `Theme "${(await U("/angie/v1/themes/activate", "POST", {
                            stylesheet: e
                        })).name || e}" activated successfully.`
                    }]
                }
            } catch (r) {
                return console.error("[Theme Installation Server] wp-activate-theme error:", r),
                {
                    content: [{
                        type: "text",
                        text: `Error activating theme ${e}: ${r.message}`
                    }]
                }
            }
        }
        ),
        t.tool("wp-deactivate-theme", "Deactivates the current theme and switches to the default theme. Use this tool when you need to reset the active theme. Returns confirmation that the theme was deactivated successfully.", {}, async () => {
            console.log("[Theme Installation Server] wp-deactivate-theme");
            try {
                return await U("/angie/v1/themes/deactivate", "POST"),
                {
                    content: [{
                        type: "text",
                        text: "Current theme deactivated successfully. Switched to default theme."
                    }]
                }
            } catch (e) {
                return console.error("[Theme Installation Server] wp-deactivate-theme error:", e),
                {
                    content: [{
                        type: "text",
                        text: `Error deactivating theme: ${e.message}`
                    }]
                }
            }
        }
        ),
        t.tool("wp-update-theme", "Updates an installed WordPress theme. Use this tool when you need to update a theme to the latest version. Returns confirmation that the theme was updated successfully.", {
            themes: a.array(a.string()).describe("The slugs of the themes to update"),
            confirmationMessage: a.string().describe(`A clear explanation of what will be updated and its potential impact (this would be shown to the user before proceeding to ensure they understand the consequences of this action). Example: "You're about to update the 'Astra' theme to the latest version. This action may change your site's appearance or functionality and could potentially break custom modifications."`)
        }, {
            title: "Update Theme",
            destructiveHint: !0
        }, async ({themes: e}) => {
            console.log("[Theme Installation Server] wp-update-theme", {
                themes: e
            });
            try {
                const r = await U("/angie/v1/themes/update", "POST", {
                    themes: e
                });
                return console.log("[Theme Installation Server] wp-update-theme result", r),
                {
                    content: [{
                        type: "text",
                        text: JSON.stringify(r.data)
                    }]
                }
            } catch (r) {
                return console.error("[Theme Installation Server] wp-update-theme error:", r),
                {
                    content: [{
                        type: "text",
                        text: `Error updating theme(s): ${r.message}`
                    }]
                }
            }
        }
        ),
        t.tool("wp-delete-theme", "Deletes an installed WordPress theme. Use this tool when you need to remove a theme from the site. Returns confirmation that the theme was deleted successfully.", {
            stylesheet: a.string().describe("The stylesheet name of the theme to delete"),
            confirmationMessage: a.string().optional().describe(`A clear explanation of what will be deleted and its potential impact (this would be shown to the user before proceeding to ensure they understand the consequences of this action). Example: "You're about to delete the 'Astra' theme permanently. This action cannot be undone and will remove all theme files from your site."`)
        }, {
            title: "Delete Theme",
            destructiveHint: !0
        }, async ({stylesheet: e}) => {
            console.log("[Theme Installation Server] wp-delete-theme", {
                stylesheet: e
            });
            try {
                return await U("/angie/v1/themes/delete", "POST", {
                    stylesheet: e
                }),
                {
                    content: [{
                        type: "text",
                        text: `Theme "${e}" deleted successfully.`
                    }]
                }
            } catch (r) {
                return console.error("[Theme Installation Server] wp-delete-theme error:", r),
                {
                    content: [{
                        type: "text",
                        text: `Error deleting theme ${e}: ${r.message}`
                    }]
                }
            }
        }
        ),
        t
    }
    function Hw() {
        const t = new He({
            name: "plugin-installation-server",
            version: "1.0.0"
        },{
            capabilities: {
                resources: {
                    subscribe: !0
                }
            }
        });
        return t.tool("plugins", 'This tool manages WordPress plugins through search, installation, activation, updates, and removal. Use this when you need to add new functionality to a site, enable/disable plugin features, or maintain plugin versions. For plugin operations on installed plugins (activate/deactivate/delete/get), first use "list" action to get the exact plugin basename. For plugin installation, search first using the "search" action to find the correct plugin slug, then use the "install" action with the exact slug found. Returns structured JSON with operation status and guidance - noting that newly installed plugins require activation to become functional. For suggesting plugins first call the suggest-plugins tool to get recommendations based on the user request.', {
            action: a.enum(["list", "get", "install", "get-update-info", "update", "activate", "deactivate", "delete", "search"]).describe('Specific operation to perform: "list" (retrieve all plugins), "get" (fetch single plugin details), "search" (find plugins in WordPress.org repository), "install" (add new plugin - starts inactive), "activate"/"deactivate" (change plugin state), "update" (upgrade to latest version), "delete" (permanently remove), "get-update-info" (check available updates)'),
            plugins: a.array(a.string()).optional().describe('Plugin identifiers required for get/install/activate/deactivate/delete/update actions. For installed plugin operations, use the exact basename from the "list" action (e.g. "send-app/send-app", "woocommerce/woocommerce"). For install action, provide just the slug (e.g. "woocommerce")'),
            listFilters: a.object({
                status: a.enum(["active", "inactive"]).optional().describe("Filter by activation state to find only enabled or disabled plugins"),
                search: a.string().optional().describe("Text search to find plugins by name or description keywords"),
                per_page: a.number().optional().describe("Limit results for pagination (default varies by WordPress configuration)"),
                page: a.number().optional().describe("Page number for paginated results when per_page is set")
            }).optional().describe('Optional filtering criteria used only with "list" action to narrow down plugin results'),
            searchFilters: a.object({
                search: a.string().describe("Search term to find plugins in WordPress.org repository by name, description, or author"),
                per_page: a.number().optional().describe("Number of results per page (default 10)"),
                page: a.number().optional().describe("Page number for paginated search results")
            }).optional().describe('Search criteria required for "search" action to discover plugins in WordPress.org repository before installation'),
            confirmationMessage: a.string().optional().describe(`If action is "delete" then provide a clear explanation of what will be deleted and its impact (this would be shown to the user before proceeding to ensure they understand the consequences of this action). Example: "You're about to permanently delete the 'Contact Form 7' plugin. This action cannot be undone and will remove all plugin files and data from your site."`),
            wasListActionCalled: a.boolean().describe('Indicates if a "list" action was previously called. This needed to get exact plugin basename for operations on installed plugins (activate/deactivate/delete/get). Must include a value even for unrelated actions'),
            wasSearchActionCalled: a.boolean().describe('Indicates if a "search" action was previously called. This is needed to confirm the correct plugin slug before installation. Must include a value even for unrelated actions'),
            isSearchingForSuggestions: a.boolean().describe("Indicates if the current search is being performed to get plugin suggestions based on user request. Must include a value even for unrelated actions"),
            wasSuggestPluginActionCalled: a.boolean().describe('Indicates if a "suggest-plugins" tool was previously called. This is needed to get recommended plugins before suggesting. Must include a value even for unrelated actions')
        }, {
            title: "WordPress Plugin Operations",
            destructiveHint: !0
        }, async e => {
            if (console.log("[Plugin Installation Server] plugins", e),
            ["get", "activate", "deactivate", "delete", "get-update-info"].includes(e.action) && !e.wasListActionCalled)
                throw new Error(`LLM Instructions: The "${e.action}" action requires a prior "list" action to retrieve the exact plugin basename. Please perform a "list" action first to get the correct plugin identifier.`);
            if (e.action === "install" && !e.wasSearchActionCalled)
                throw new Error('LLM Instructions: The "install" action requires a prior "search" action to confirm the correct plugin slug. Please perform a "search" action first to find the desired plugin.');
            if (e.isSearchingForSuggestions && !e.wasSuggestPluginActionCalled)
                throw new Error('LLM Instructions: To get plugin suggestions based on the user request, use the "suggest-plugins" tool first to receive tailored recommendations.');
            try {
                switch (e.action) {
                case "list":
                    return await Vw(e);
                case "get":
                    return await Jw(e);
                case "search":
                    return await Yw(e);
                case "install":
                    return await Kw(e);
                case "update":
                    return await Qw(e);
                case "activate":
                    return await Xw(e);
                case "deactivate":
                    return await eb(e);
                case "delete":
                    return await tb(e);
                case "get-update-info":
                    return await Ud()
                }
            } catch (r) {
                return console.error("[Plugin Installation Server] plugins error:", r),
                {
                    content: [{
                        type: "text",
                        text: `Error performing ${e.action} action: ${r.message}`
                    }]
                }
            }
        }
        ),
        t
    }
    async function Vw(t) {
        const e = Et("/wp/v2/plugins", t.listFilters || {})
          , r = await U(e, "GET")
          , o = {
            total_plugins: Array.isArray(r) ? r.length : 0,
            active_plugins: Array.isArray(r) ? r.filter(n => n.status === "active").length : 0,
            inactive_plugins: Array.isArray(r) ? r.filter(n => n.status === "inactive").length : 0,
            plugins: r
        };
        return ir(o)
    }
    async function Jw(t) {
        if (!Array.isArray(t.plugins))
            throw new Error("Plugins array is required for get action");
        const e = await Go(t.plugins[0], U)
          , r = await U(`/wp/v2/plugins/${e}`, "GET");
        return ir(r)
    }
    async function Yw(t) {
        if (!t.searchFilters)
            throw new Error("SearchFilters are required for search action");
        const e = new URLSearchParams;
        e.append("search", t.searchFilters.search),
        t.searchFilters.per_page && e.append("per_page", t.searchFilters.per_page.toString()),
        t.searchFilters.page && e.append("page", t.searchFilters.page.toString());
        const r = `/angie/v1/plugins/search?${e.toString()}`
          , o = await U(r, "GET");
        return {
            content: [{
                type: "text",
                text: JSON.stringify(o, null, 2)
            }]
        }
    }
    async function Kw(t) {
        if (!Array.isArray(t.plugins))
            throw new Error("Plugins array is required for install action");
        const e = await U("/wp/v2/plugins", "POST", {
            slug: t.plugins[0].split("/")[0]
        });
        if (!e || typeof e != "object")
            throw new Error("Invalid response from plugin installation API");
        const r = e.name || t.plugins[0];
        return e.status === "active" ? {
            content: [{
                type: "text",
                text: JSON.stringify({
                    success: !0,
                    message: `Plugin "${r}" installed and activated successfully.`,
                    pluginName: r,
                    status: "active",
                    ready: !0
                }, null, 2)
            }]
        } : {
            content: [{
                type: "text",
                text: JSON.stringify({
                    success: !0,
                    message: `Plugin "${r}" installed successfully but is not yet active.`,
                    pluginName: r,
                    status: "inactive",
                    ready: !1,
                    nextStep: `The plugin needs to be activated to start working. You should activate "${r}" using the activate action.`,
                    pluginBasename: e.plugin || `${t.plugins[0].split("/")[0]}/${t.plugins[0].split("/")[0]}.php`,
                    instructions: [`The plugin "${r}" was installed but is not active yet.`, "Newly installed plugins are typically inactive by default.", "To make the plugin functional, you need to activate it.", `Use the plugins tool with action "activate" and plugins: ["${e.plugin || `${t.plugins[0].split("/")[0]}/${t.plugins[0].split("/")[0]}.php`}"] to activate it.`, "Note: Plugin activation requires the full basename (folder/main-file.php), not just the slug."]
                }, null, 2)
            }]
        }
    }
    async function Qw(t) {
        let e;
        if (!t.plugins || t.plugins.length === 0) {
            const o = await Ud(!0);
            if (!o || !o.updates_available || (e = Object.keys(o.updates_available),
            e.length === 0))
                return jd()
        } else
            e = t.plugins;
        const r = await U("/angie/v1/plugins/update", "POST", {
            plugins: e.map(o => o.includes(".php") ? o : o + ".php")
        });
        return console.log("[Plugin Installation Server] wp-update-plugin result", r),
        ir(r)
    }
    async function Xw(t) {
        if (!Array.isArray(t.plugins))
            throw new Error("Plugins array is required for activate action");
        const e = await Go(t.plugins[0], U)
          , r = await U(`/wp/v2/plugins/${e}`, "POST", {
            status: "active"
        });
        return ir(`Plugin "${r.name || t.plugins[0]}" activated successfully.`)
    }
    async function eb(t) {
        if (!Array.isArray(t.plugins))
            throw new Error("Plugins array is required for deactivate action");
        const e = await Go(t.plugins[0], U)
          , r = await U(`/wp/v2/plugins/${e}`, "POST", {
            status: "inactive"
        });
        return ir(`Plugin "${r.name || t.plugins[0]}" deactivated successfully.`)
    }
    async function tb(t) {
        if (!Array.isArray(t.plugins))
            throw new Error("Plugins array is required for delete action");
        const e = await Go(t.plugins[0], U);
        try {
            await U(`/wp/v2/plugins/${e}`, "DELETE")
        } catch (r) {
            if (console.log(`[Plugin Delete] Delete failed for ${e}, error:`, r),
            r.message.includes("rest_cannot_delete_active_plugin"))
                return console.log("[Plugin Delete] Plugin is active, deactivating first..."),
                await U(`/wp/v2/plugins/${e}`, "POST", {
                    status: "inactive"
                }),
                await U(`/wp/v2/plugins/${e}`, "DELETE"),
                ir(`Plugin "${t.plugins[0]}" deactivated and deleted successfully.`);
            throw r
        }
        return ir(`Plugin "${t.plugins[0]}" deleted successfully.`)
    }
    async function Ud(t=!1) {
        const e = await U("/angie/v1/plugins/update-info", "GET");
        return t ? e : ir(e)
    }
    function jd() {
        return ir({
            success: !0,
            message: "All plugins are up to date. No updates available.",
            updated_plugins: [],
            update_count: 0
        })
    }
    function ir(t) {
        return {
            content: [{
                type: "text",
                text: typeof t == "string" ? t : JSON.stringify(t, null, 2)
            }]
        }
    }
    async function rb() {
        const t = e => (e[6] && typeof e[6] == "string" && e[6].startsWith("data:image/") && (e[6] = "[base64-image-filtered]"),
        e);
        try {
            const e = await U("/angie/v1/menu-items", "GET");
            if (console.log("menuResponse", e),
            e.menu)
                for (const [r,o] of Object.entries(e.menu))
                    e.menu[r] = t(o);
            return e
        } catch (e) {
            console.warn("Error accessing WordPress menu structure:", e)
        }
        return null
    }
    function nb() {
        if (window.onbeforeunload)
            try {
                const r = {
                    type: "beforeunload",
                    returnValue: "",
                    preventDefault: () => {}
                    ,
                    defaultPrevented: !1
                };
                if (window.onbeforeunload.call(window, r) || r.returnValue)
                    return console.log("[Navigation Server] onbeforeunload would show dialog"),
                    !0
            } catch (r) {
                console.warn("[Navigation Server] Error testing onbeforeunload:", r)
            }
        let t = !1;
        const e = new Event("beforeunload",{
            cancelable: !0
        });
        return Object.defineProperty(e, "returnValue", {
            get: () => "",
            set: r => {
                r && (t = !0)
            }
            ,
            configurable: !0
        }),
        window.dispatchEvent(e),
        console.log("[Navigation Server] Unsaved changes detected:", t),
        t
    }
    async function ob() {
        var e, r, o, n, s, i;
        const t = [];
        if (window.elementor && typeof window.$e < "u")
            try {
                const l = await window.$e.run("document/save/update");
                t.push("Elementor page saved successfully"),
                console.log("[Navigation Server] Elementor save result:", l)
            } catch (l) {
                console.warn("[Navigation Server] Elementor save failed:", l),
                t.push("Elementor save failed: " + l.message)
            }
        if ((r = (e = window.wp) == null ? void 0 : e.data) != null && r.select && ((n = (o = window.wp) == null ? void 0 : o.data) != null && n.dispatch))
            try {
                const l = window.wp.data.dispatch("core/editor")
                  , d = window.wp.data.select("core/editor");
                if (l && d && typeof l.savePost == "function")
                    if (((s = d.isSavingPost) == null ? void 0 : s.call(d)) || !1)
                        t.push("Gutenberg post is already being saved");
                    else {
                        await l.savePost();
                        const g = ((i = d.getEditedPostAttribute) == null ? void 0 : i.call(d, "title")) || "Untitled";
                        t.push(`Gutenberg post "${g}" saved successfully`)
                    }
            } catch (l) {
                console.warn("[Navigation Server] Gutenberg save failed:", l),
                t.push("Gutenberg save failed: " + l.message)
            }
        if (window.location.pathname.includes("post.php") && window.location.search.includes("post_type=product"))
            try {
                const l = document.getElementById("post");
                if (l) {
                    const d = document.createElement("input");
                    d.type = "hidden",
                    d.name = "auto_save",
                    d.value = "1",
                    l.appendChild(d);
                    const u = document.getElementById("save-post");
                    u && (u.click(),
                    t.push("WooCommerce product saved successfully"))
                }
            } catch (l) {
                console.warn("[Navigation Server] WooCommerce save failed:", l),
                t.push("WooCommerce save failed: " + l.message)
            }
        if (t.length === 0)
            try {
                const l = document.querySelectorAll('form[method="post"]')
                  , d = document.querySelectorAll('input[type="submit"][name="save"], input[type="submit"][value*="Save"], button[type="submit"]');
                l.length > 0 && d.length > 0 ? (d[0].click(),
                t.push("WordPress admin form saved successfully")) : t.push("No save context detected - no action taken")
            } catch (l) {
                console.warn("[Navigation Server] Generic save failed:", l),
                t.push("Generic save failed: " + l.message)
            }
        if (t.length === 0 || t.some(l => l.includes("failed")))
            try {
                const l = navigator.platform.toUpperCase().indexOf("MAC") >= 0
                  , d = l ? "metaKey" : "ctrlKey"
                  , u = new KeyboardEvent("keydown",{
                    key: "s",
                    code: "KeyS",
                    [d]: !0,
                    bubbles: !0,
                    cancelable: !0
                })
                  , g = [document.querySelector(":focus") || document.body, document.body, document];
                let c = !1;
                for (const m of g)
                    if (m && !m.dispatchEvent(u)) {
                        c = !0;
                        break
                    }
                if (c)
                    t.push(`Keyboard shortcut save triggered (${l ? "Cmd+S" : "Ctrl+S"})`);
                else {
                    const m = new KeyboardEvent("keyup",{
                        key: "s",
                        code: "KeyS",
                        [d]: !0,
                        bubbles: !0,
                        cancelable: !0
                    });
                    document.dispatchEvent(m),
                    t.push(`Keyboard shortcut attempted (${l ? "Cmd+S" : "Ctrl+S"}) - may have triggered background save`)
                }
            } catch (l) {
                console.warn("[Navigation Server] Keyboard shortcut save failed:", l),
                t.push("Keyboard shortcut save failed: " + l.message)
            }
        return t
    }
    function sb() {
        const t = new He({
            name: "wp-navigation-server",
            version: "1.0.0"
        },{
            capabilities: {
                resources: {}
            }
        });
        return t.tool("get-navigation-menu-and-urls", `Discover Available WordPress admin menu Navigation Destinations -
This tool retrieves the complete WordPress admin menu structure to help determine where users can navigate next. `, {}, async () => {
            console.log("[Navigation Server] get-navigation-options");
            try {
                const e = await rb();
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(e, null, 2)
                    }]
                }
            } catch (e) {
                return console.error("[Navigation Server] get-wp-admin-locations error:", e),
                {
                    content: [{
                        type: "text",
                        text: `Error retrieving admin locations: ${e.message}`
                    }]
                }
            }
        }
        ),
        t.tool("navigate-to-wordpress-destination", `This tool provides instant navigation to any destination, page, editor, or admin area from any current screen at any time. Use this when users need to go to specific WordPress admin pages, edit content, or access any WordPress feature. The tool automatically handles unsaved changes by prompting for save confirmation before navigation, ensuring no data loss. It works universally across all WordPress admin contexts - whether the user is currently editing a page, viewing the dashboard, managing plugins, or anywhere else in WordPress admin. The tool will redirect the browser to the specified destination and handle the navigation seamlessly.
Use this tool to navigate to any wordpress destination.
Avoid from guiding users to manually navigate avoid telling them how to navigate manually.
Use this tool for automatically navigate users to their to any intendant wp screen.
ALWAYS call "get-navigation-menu-and-urls" tool as a pre-step before using this tool, in order to get the correct URL for the destination.`, {
            url: a.string().describe("The exact destination URL to navigate to within WordPress admin. This should be a relative admin URL path that identifies the specific admin page or functionality needed to fulfill the user's request. The URL determines which WordPress admin screen will be loaded and what capabilities will be available to the user. may be menu items, posts, pages, products, etc. Pay attention to specific entity Ids that may be present in the URL."),
            isSaveConfirmed: a.boolean().describe("Boolean flag indicating whether any required save operations have been confirmed by the user before navigation. This parameter prevents data loss by ensuring unsaved changes are handled appropriately before leaving the current page. Should only be set to true after explicit user confirmation of save operations."),
            wasGetNavigationMenuToolCalled: a.boolean().describe("Whether the `get-navigation-menu-and-urls` tool was called before this navigation command. This ensures the correct URLs are available for navigation. If false, the tool will not proceed with navigation and will return instructions to call the prerequisite tool first.")
        }, async ({url: e, isSaveConfirmed: r, wasGetNavigationMenuToolCalled: o}) => {
            if (console.log("[Navigation Server] navigate-to", {
                url: e,
                isSaveConfirmed: r,
                wasGetNavigationMenuToolCalled: o
            }),
            !o)
                throw new Error('You must call the "get-navigation-menu-and-urls" tool first to retrieve the available navigation destinations and correct URLs before attempting to navigate. This ensures you have accurate URL paths for the requested destination. Note: This is not required for direct post/page editing URLs (post.php?post=ID&action=edit).');
            e.includes("elementor") && await Df();
            const n = nb();
            try {
                if (n) {
                    if (!r)
                        return {
                            content: [{
                                type: "text",
                                text: 'UNSAVED CHANGES DETECTED: You must immediately ask the user for confirmation to save their changes before navigating. i.e. ask "You have unsaved changes. Do you want to save your changes before navigating?" and wait for user confirmation before proceeding to call this navigate-to-edit-content tool again.'
                            }]
                        };
                    try {
                        const i = await ob()
                          , l = i.length > 0 ? i.join("; ") : "No active editing context detected";
                        console.log("[Navigation Server] Save completed:", l),
                        await new Promise(d => setTimeout(d, 1e3))
                    } catch (i) {
                        return console.error("[Navigation Server] Save operation failed:", i),
                        {
                            content: [{
                                type: "text",
                                text: `Save operation failed: ${i.message}. Navigation cancelled for safety.`
                            }]
                        }
                    }
                }
                let s = e;
                return !e.startsWith("http") && !e.startsWith("/") && (s = (window.ajaxurl ? window.ajaxurl.replace("/wp-admin/admin-ajax.php", "/wp-admin/") : "/wp-admin/") + e),
                console.log("[Navigation Server] Navigating to:", s),
                window.location.assign(s),
                {
                    content: [{
                        type: "text",
                        text: `Successfully initiated navigation to "${s}"`
                    }]
                }
            } catch (s) {
                return console.error("[Navigation Server] navigate-to error:", s),
                {
                    content: [{
                        type: "text",
                        text: `Error navigating to "${e}": ${s.message}`
                    }]
                }
            }
        }
        ),
        t.tool("get-current-location", 'This tool identifies the current WordPress admin location and context to provide location-aware assistance. Use this when users make contextual requests like "edit this page" or "modify this content" where you need to understand their current location, or when providing help without clear context. The tool returns the current URL, admin page type, and available WordPress context variables to help determine if navigation is needed or if the user is already in the right place.', {}, async () => {
            console.log("[Navigation Server] get-current-location");
            try {
                const e = {
                    currentUrl: window.location.href,
                    pathname: window.location.pathname,
                    search: window.location.search
                };
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(e, null, 2)
                    }]
                }
            } catch (e) {
                return console.error("[Navigation Server] get-current-location error:", e),
                {
                    content: [{
                        type: "text",
                        text: `Error getting current location: ${e.message}`
                    }]
                }
            }
        }
        ),
        t
    }
    function ab() {
        const t = new He({
            name: "wp-menu-server",
            version: "1.0.0"
        },{
            capabilities: {
                resources: {
                    subscribe: !0
                }
            }
        });
        return t.tool("wp-get-menus", "Retrieves all navigation menus on the WordPress site with their locations and item counts. Use this tool when you need to list existing menus to understand the current navigation structure, check which menus are assigned to specific locations, or get an overview of all available menus before creating, updating, or managing them.", {
            includeLocations: a.boolean().optional().default(!0).describe("Whether to include location assignments for each menu"),
            includeCount: a.boolean().optional().default(!0).describe("Whether to include the number of items in each menu")
        }, async ({includeLocations: e, includeCount: r}) => {
            console.log("[WordPress Menu Server] wp-get-menus", {
                includeLocations: e,
                includeCount: r
            });
            try {
                const n = (await U("/wp/v2/menus", "GET")).map(s => {
                    const i = {
                        id: s.id,
                        name: s.name,
                        slug: s.slug,
                        description: s.description
                    };
                    return e && (i.locations = s.locations),
                    r && (i.count = s.count),
                    i
                }
                );
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(n, null, 2)
                    }]
                }
            } catch (o) {
                return console.error("[WordPress Menu Server] wp-get-menus error:", o),
                {
                    content: [{
                        type: "text",
                        text: `Error retrieving menus: ${o.message}`
                    }]
                }
            }
        }
        ),
        t.tool("wp-create-menu", "Creates a new navigation menu with the specified name and optionally assigns it to theme locations. Use this tool when you need to create a new navigation menu structure. The menu will be created empty and you can then add menu items using wp-create-menu-item. You can optionally assign the menu to specific theme locations during creation.", {
            name: a.string().describe("The name of the menu to create"),
            description: a.string().optional().describe("Optional description for the menu"),
            locations: a.array(a.string()).optional().describe('Array of theme location names to assign this menu to (e.g., ["primary", "footer"])'),
            autoAdd: a.boolean().optional().default(!1).describe("Whether to automatically add new top-level pages to this menu")
        }, async ({name: e, description: r, locations: o, autoAdd: n}) => {
            console.log("[WordPress Menu Server] wp-create-menu", {
                name: e,
                description: r,
                locations: o,
                autoAdd: n
            });
            try {
                const s = {
                    name: e,
                    auto_add: n
                };
                r && (s.description = r),
                o && o.length > 0 && (s.locations = o);
                const i = await U("/wp/v2/menus", "POST", s);
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify({
                            success: !0,
                            message: "Menu created successfully",
                            menu: {
                                id: i.id,
                                name: i.name,
                                slug: i.slug,
                                description: i.description || "",
                                locations: o || [],
                                auto_add: i.auto_add
                            }
                        }, null, 2)
                    }]
                }
            } catch (s) {
                return console.error("[WordPress Menu Server] wp-create-menu error:", s),
                {
                    content: [{
                        type: "text",
                        text: `Error creating menu: ${s.message}`
                    }]
                }
            }
        }
        ),
        t.tool("wp-update-menu", "Updates an existing navigation menu's name, description, or location assignments. Use this tool when you need to modify menu properties like changing the menu name, updating its description, or reassigning it to different theme locations. This does not modify the menu items themselves.", {
            id: a.number().describe("The ID of the menu to update"),
            name: a.string().optional().describe("New name for the menu"),
            description: a.string().optional().describe("New description for the menu"),
            locations: a.array(a.string()).optional().describe("Array of theme location names to assign this menu to (replaces existing locations)"),
            autoAdd: a.boolean().optional().describe("Whether to automatically add new top-level pages to this menu")
        }, async ({id: e, name: r, description: o, locations: n, autoAdd: s}) => {
            console.log("[WordPress Menu Server] wp-update-menu", {
                id: e,
                name: r,
                description: o,
                locations: n,
                autoAdd: s
            });
            try {
                const i = {};
                r !== void 0 && (i.name = r),
                o !== void 0 && (i.description = o),
                n !== void 0 && (i.locations = n),
                s !== void 0 && (i.auto_add = s);
                const l = await U(`/wp/v2/menus/${e}`, "PUT", i);
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify({
                            success: !0,
                            message: "Menu updated successfully",
                            menu: {
                                id: l.id,
                                name: l.name,
                                slug: l.slug,
                                description: l.description || "",
                                locations: l.locations || [],
                                auto_add: l.auto_add
                            }
                        }, null, 2)
                    }]
                }
            } catch (i) {
                return console.error("[WordPress Menu Server] wp-update-menu error:", i),
                {
                    content: [{
                        type: "text",
                        text: `Error updating menu ${e}: ${i.message}`
                    }]
                }
            }
        }
        ),
        t.tool("wp-delete-menu", "Permanently removes a navigation menu and all its menu items from the WordPress site. Use this tool when you need to completely remove a menu that is no longer needed. This action cannot be undone and will also remove all menu items associated with the menu.", {
            id: a.number().describe("The ID of the menu to delete"),
            force: a.boolean().optional().default(!0).describe("Whether to bypass trash and force deletion. Menus require force=true for deletion."),
            confirmationMessage: a.string().describe(`A clear explanation of what will be deleted and its impact (this would be shown to the user before deletion to ensure they understand the consequences of this irreversible action). Example: "You're about to permanently delete the 'Main Navigation' menu. This action cannot be undone and will remove all menu items, affecting your site's navigation structure."`)
        }, {
            Title: "Delete Menu",
            destructiveHint: !0
        }, async ({id: e, force: r}) => {
            console.log("[WordPress Menu Server] wp-delete-menu", {
                id: e,
                force: r
            });
            try {
                const o = await U(`/wp/v2/menus/${e}`, "GET")
                  , n = `/wp/v2/menus/${e}${r ? "?force=true" : ""}`;
                return await U(n, "DELETE"),
                {
                    content: [{
                        type: "text",
                        text: JSON.stringify({
                            success: !0,
                            message: "Menu deleted successfully",
                            deleted_menu: {
                                id: e,
                                name: o.name
                            }
                        }, null, 2)
                    }]
                }
            } catch (o) {
                return console.error("[WordPress Menu Server] wp-delete-menu error:", o),
                {
                    content: [{
                        type: "text",
                        text: `Error deleting menu ${e}: ${o.message}`
                    }]
                }
            }
        }
        ),
        t.tool("wp-get-menu-items", "Retrieves all menu items for a specific navigation menu with their hierarchy and ordering information. Use this tool when you need to see the current structure of a menu, understand the parent-child relationships between menu items, or get detailed information about individual menu items before making modifications.", {
            menuId: a.number().describe("The ID of the menu to retrieve items from"),
            includeHierarchy: a.boolean().optional().default(!0).describe("Whether to include parent-child hierarchy information")
        }, async ({menuId: e, includeHierarchy: r}) => {
            console.log("[WordPress Menu Server] wp-get-menu-items", {
                menuId: e,
                includeHierarchy: r
            });
            try {
                const o = await U(`/wp/v2/menu-items?menus=${e}&per_page=100&orderby=menu_order&order=asc`, "GET");
                if (r) {
                    const n = new Map
                      , s = [];
                    return o.forEach(i => {
                        const l = {
                            ...i,
                            children: []
                        };
                        n.set(i.id, l)
                    }
                    ),
                    o.forEach(i => {
                        const l = n.get(i.id);
                        if (i.parent === 0)
                            s.push(l);
                        else {
                            const d = n.get(i.parent);
                            d && d.children.push(l)
                        }
                    }
                    ),
                    {
                        content: [{
                            type: "text",
                            text: JSON.stringify(s, null, 2)
                        }]
                    }
                }
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(o, null, 2)
                    }]
                }
            } catch (o) {
                return console.error("[WordPress Menu Server] wp-get-menu-items error:", o),
                {
                    content: [{
                        type: "text",
                        text: `Error retrieving menu items for menu ${e}: ${o.message}`
                    }]
                }
            }
        }
        ),
        t.tool("wp-create-menu-item", "Adds a new menu item to a specific navigation menu. Use this tool to add pages, posts, custom links, or category links to a menu. You can specify the menu item type (page, post, custom link, etc.), its position in the menu, and parent-child relationships for sub-menus.", {
            menuId: a.number().describe("The ID of the menu to add the item to"),
            title: a.string().describe("Display title for the menu item"),
            type: a.enum(["post_type", "taxonomy", "custom"]).describe("Type of menu item: post_type for pages/posts, taxonomy for categories/tags, custom for custom links"),
            object: a.string().optional().describe('Object type: "page", "post", "category", "tag", etc. Required for post_type and taxonomy items'),
            objectId: a.number().optional().describe("ID of the object (page ID, post ID, category ID, etc.). Required for post_type and taxonomy items"),
            url: a.string().optional().describe("Custom URL for the menu item. Required for custom type items"),
            description: a.string().optional().describe("Description text for the menu item"),
            parent: a.number().optional().default(0).describe("Parent menu item ID for creating sub-menu items. Use 0 for top-level items"),
            menuOrder: a.number().optional().describe("Order position of the item in the menu. If not specified, will be added at the end"),
            target: a.string().optional().describe('Link target: "_blank" for new window, "_self" for same window'),
            classes: a.array(a.string()).optional().describe("CSS classes to add to the menu item"),
            attrTitle: a.string().optional().describe("Title attribute for the link (tooltip text)"),
            xfn: a.string().optional().describe("XFN relationship attributes for the link")
        }, async ({menuId: e, title: r, type: o, object: n, objectId: s, url: i, description: l, parent: d, menuOrder: u, target: g, classes: c, attrTitle: m, xfn: p}) => {
            var h;
            console.log("[WordPress Menu Server] wp-create-menu-item", {
                menuId: e,
                title: r,
                type: o,
                object: n,
                objectId: s,
                url: i
            });
            try {
                const f = {
                    title: r,
                    type: o,
                    menus: e,
                    status: "publish",
                    parent: d || 0
                };
                if (o === "post_type" || o === "taxonomy") {
                    if (!n || s === void 0)
                        throw new Error(`object and objectId are required for ${o} menu items`);
                    f.object = n,
                    f.object_id = s
                } else if (o === "custom") {
                    if (!i)
                        throw new Error("url is required for custom menu items");
                    f.url = i
                }
                l && (f.description = l),
                u !== void 0 && (f.menu_order = u),
                g && (f.target = g),
                c && c.length > 0 && (f.classes = c),
                m && (f.attr_title = m),
                p && (f.xfn = p);
                const y = await U("/wp/v2/menu-items", "POST", f);
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify({
                            success: !0,
                            message: "Menu item created successfully",
                            menu_item: {
                                id: y.id,
                                title: ((h = y.title) == null ? void 0 : h.rendered) || r,
                                menu_id: e,
                                type: o,
                                url: y.url || i,
                                parent: y.parent,
                                menu_order: y.menu_order
                            }
                        }, null, 2)
                    }]
                }
            } catch (f) {
                return console.error("[WordPress Menu Server] wp-create-menu-item error:", f),
                {
                    content: [{
                        type: "text",
                        text: `Error creating menu item: ${f.message}`
                    }]
                }
            }
        }
        ),
        t.tool("wp-update-menu-item", "Modifies an existing menu item's properties such as title, URL, order, or parent relationship. Use this tool when you need to edit menu items, change their display text, update links, reorder items, or modify parent-child relationships to create or modify sub-menus.", {
            id: a.number().describe("The ID of the menu item to update"),
            title: a.string().optional().describe("New display title for the menu item"),
            url: a.string().optional().describe("New URL for the menu item (for custom links)"),
            description: a.string().optional().describe("New description text for the menu item"),
            parent: a.number().optional().describe("New parent menu item ID for changing sub-menu relationships"),
            menuOrder: a.number().optional().describe("New order position of the item in the menu"),
            target: a.string().optional().describe('New link target: "_blank" for new window, "_self" for same window'),
            classes: a.array(a.string()).optional().describe("New CSS classes to add to the menu item"),
            attrTitle: a.string().optional().describe("New title attribute for the link (tooltip text)"),
            xfn: a.string().optional().describe("New XFN relationship attributes for the link")
        }, async ({id: e, title: r, url: o, description: n, parent: s, menuOrder: i, target: l, classes: d, attrTitle: u, xfn: g}) => {
            var c;
            console.log("[WordPress Menu Server] wp-update-menu-item", {
                id: e,
                title: r,
                url: o,
                parent: s,
                menuOrder: i
            });
            try {
                const m = {};
                r !== void 0 && (m.title = r),
                o !== void 0 && (m.url = o),
                n !== void 0 && (m.description = n),
                s !== void 0 && (m.parent = s),
                i !== void 0 && (m.menu_order = i),
                l !== void 0 && (m.target = l),
                d !== void 0 && (m.classes = d),
                u !== void 0 && (m.attr_title = u),
                g !== void 0 && (m.xfn = g);
                const p = await U(`/wp/v2/menu-items/${e}`, "PUT", m);
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify({
                            success: !0,
                            message: "Menu item updated successfully",
                            menu_item: {
                                id: p.id,
                                title: (c = p.title) == null ? void 0 : c.rendered,
                                url: p.url,
                                parent: p.parent,
                                menu_order: p.menu_order,
                                type: p.type
                            }
                        }, null, 2)
                    }]
                }
            } catch (m) {
                return console.error("[WordPress Menu Server] wp-update-menu-item error:", m),
                {
                    content: [{
                        type: "text",
                        text: `Error updating menu item ${e}: ${m.message}`
                    }]
                }
            }
        }
        ),
        t.tool("wp-delete-menu-item", "Permanently removes a menu item from a navigation menu. Use this tool when you need to remove menu items that are no longer needed. This action cannot be undone. If the menu item has sub-items, you should handle them separately as they may become orphaned.", {
            id: a.number().describe("The ID of the menu item to delete"),
            confirmationMessage: a.string().describe(`A clear explanation of what will be deleted and its impact (this would be shown to the user before deletion to ensure they understand the consequences of this irreversible action). Example: "You're about to permanently delete the 'Contact Us' menu item. This action cannot be undone and will remove this link from your navigation menu."`)
        }, {
            Title: "Delete Menu Item",
            destructiveHint: !0
        }, async ({id: e}) => {
            var r;
            console.log("[WordPress Menu Server] wp-delete-menu-item", {
                id: e
            });
            try {
                const o = await U(`/wp/v2/menu-items/${e}`, "GET");
                return await U(`/wp/v2/menu-items/${e}`, "DELETE"),
                {
                    content: [{
                        type: "text",
                        text: JSON.stringify({
                            success: !0,
                            message: "Menu item deleted successfully",
                            deleted_menu_item: {
                                id: e,
                                title: (r = o.title) == null ? void 0 : r.rendered
                            }
                        }, null, 2)
                    }]
                }
            } catch (o) {
                return console.error("[WordPress Menu Server] wp-delete-menu-item error:", o),
                {
                    content: [{
                        type: "text",
                        text: `Error deleting menu item ${e}: ${o.message}`
                    }]
                }
            }
        }
        ),
        t.tool("wp-reorder-menu-items", "Updates the order and hierarchy of multiple menu items in a navigation menu. Use this tool when you need to reorder menu items, restructure the menu hierarchy, or make bulk changes to menu item positions and parent-child relationships.", {
            menuId: a.number().describe("The ID of the menu containing the items to reorder"),
            items: a.array(a.object({
                id: a.number().describe("Menu item ID"),
                menuOrder: a.number().describe("New order position"),
                parent: a.number().optional().default(0).describe("Parent menu item ID (0 for top-level)")
            })).describe("Array of menu item updates with new order and parent relationships")
        }, async ({menuId: e, items: r}) => {
            console.log("[WordPress Menu Server] wp-reorder-menu-items", {
                menuId: e,
                items: r
            });
            try {
                const o = r.map(n => U(`/wp/v2/menu-items/${n.id}`, "PUT", {
                    menu_order: n.menuOrder,
                    parent: n.parent || 0
                }));
                return await Promise.all(o),
                {
                    content: [{
                        type: "text",
                        text: JSON.stringify({
                            success: !0,
                            message: "Menu items reordered successfully",
                            menu_id: e,
                            items_updated: r.length,
                            updated_items: r
                        }, null, 2)
                    }]
                }
            } catch (o) {
                return console.error("[WordPress Menu Server] wp-reorder-menu-items error:", o),
                {
                    content: [{
                        type: "text",
                        text: `Error reordering menu items: ${o.message}`
                    }]
                }
            }
        }
        ),
        t.tool("wp-get-menu-locations", "Retrieves all available theme-defined menu locations and their current menu assignments. Use this tool when you need to understand which menu locations are available in the current theme, see which menus are assigned to specific locations, or prepare for assigning menus to locations.", {}, async () => {
            console.log("[WordPress Menu Server] wp-get-menu-locations");
            try {
                const e = await U("/wp/v2/menu-locations", "GET");
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(e, null, 2)
                    }]
                }
            } catch (e) {
                return console.error("[WordPress Menu Server] wp-get-menu-locations error:", e),
                {
                    content: [{
                        type: "text",
                        text: `Error retrieving menu locations: ${e.message}`
                    }]
                }
            }
        }
        ),
        t.tool("wp-assign-menu-location", "Assigns a navigation menu to a specific theme location. Use this tool when you need to assign a menu to appear in a specific location on the website (like primary navigation, footer menu, etc.). The available locations depend on the active theme. By default, this adds the location to existing assignments unless replace is set to true.", {
            menuId: a.number().describe("The ID of the menu to assign to the location"),
            location: a.string().describe('The theme location name (e.g., "primary", "footer", "sidebar")'),
            replace: a.boolean().optional().default(!1).describe("Whether to replace all existing location assignments (true) or add to existing ones (false)")
        }, async ({menuId: e, location: r, replace: o}) => {
            console.log("[WordPress Menu Server] wp-assign-menu-location", {
                menuId: e,
                location: r,
                replace: o
            });
            try {
                let n;
                if (o)
                    n = [r];
                else {
                    const l = (await U(`/wp/v2/menus/${e}`, "GET")).locations || [];
                    n = l.includes(r) ? l : [...l, r]
                }
                const s = await U(`/wp/v2/menus/${e}`, "PUT", {
                    locations: n
                });
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify({
                            success: !0,
                            message: o ? "Menu location assignment replaced successfully" : "Menu assigned to location successfully",
                            menu: {
                                id: e,
                                name: s.name,
                                locations: s.locations || []
                            },
                            assigned_location: r,
                            replace_mode: o
                        }, null, 2)
                    }]
                }
            } catch (n) {
                return console.error("[WordPress Menu Server] wp-assign-menu-location error:", n),
                {
                    content: [{
                        type: "text",
                        text: `Error assigning menu ${e} to location ${r}: ${n.message}`
                    }]
                }
            }
        }
        ),
        t.tool("wp-get-site-hierarchy", "Analyzes the website structure to understand page relationships, content hierarchy, and menu-relevant information. Use this tool when you need to understand the site structure before creating menus, identify important pages that should be included in navigation, or analyze parent-child relationships between pages.", {
            postTypes: a.array(a.string()).optional().default(["page", "post"]).describe("Post types to include in the hierarchy analysis"),
            includePosts: a.boolean().optional().default(!1).describe("Whether to include blog posts in the analysis"),
            maxDepth: a.number().optional().default(3).describe("Maximum depth level to analyze in the hierarchy")
        }, async ({postTypes: e, includePosts: r, maxDepth: o}) => {
            console.log("[WordPress Menu Server] wp-get-site-hierarchy", {
                postTypes: e,
                includePosts: r,
                maxDepth: o
            });
            try {
                const n = {};
                for (const l of e) {
                    if (l === "post" && !r)
                        continue;
                    const d = await U(`/wp/v2/${l === "page" ? "pages" : l}?per_page=100&status=publish&orderby=menu_order&order=asc&_fields=id,title,slug,parent,menu_order,status`, "GET")
                      , u = new Map;
                    d.forEach(m => {
                        const p = {
                            id: m.id,
                            title: m.title.rendered,
                            slug: m.slug,
                            parent: m.parent,
                            menu_order: m.menu_order,
                            status: m.status,
                            type: l,
                            level: 0,
                            children: []
                        };
                        u.set(m.id, p)
                    }
                    );
                    const g = (m, p=0) => p >= o ? [] : m.map(h => {
                        h.level = p;
                        const f = Array.from(u.values()).filter(y => y.parent === h.id);
                        return h.children = g(f, p + 1),
                        h
                    }
                    )
                      , c = Array.from(u.values()).filter(m => m.parent === 0);
                    n[l] = g(c)
                }
                const s = {
                    total_post_types: e.length,
                    hierarchy_depth: o,
                    post_type_counts: {}
                };
                return Object.keys(n).forEach(l => {
                    const d = u => u.reduce( (g, c) => g + 1 + d(c.children), 0);
                    s.post_type_counts[l] = d(n[l])
                }
                ),
                {
                    content: [{
                        type: "text",
                        text: JSON.stringify({
                            summary: s,
                            hierarchy: n
                        }, null, 2)
                    }]
                }
            } catch (n) {
                return console.error("[WordPress Menu Server] wp-get-site-hierarchy error:", n),
                {
                    content: [{
                        type: "text",
                        text: `Error analyzing site hierarchy: ${n.message}`
                    }]
                }
            }
        }
        ),
        t
    }
    async function ib(t) {
        const e = [{
            name: "wp-posts",
            createFn: Fw,
            description: "WordPress Posts API"
        }, {
            name: "wp-taxonomy",
            createFn: Ww,
            description: "WordPress Taxonomy API"
        }, {
            name: "wp-users",
            createFn: Bw,
            description: "WordPress Users API"
        }, {
            name: "wp-admin",
            createFn: zw,
            description: "WordPress Admin API"
        }, {
            name: "wp-theme",
            createFn: Zw,
            description: "WordPress Theme API"
        }, {
            name: "wp-plugin",
            createFn: Hw,
            description: "WordPress Plugin API"
        }, {
            name: "wp-navigation",
            createFn: sb,
            description: "WordPress Navigation API"
        }, {
            name: "wp-menu",
            createFn: ab,
            description: "WordPress Menu Management API"
        }, {
            name: "wp-media",
            createFn: qw,
            description: "WordPress Media API"
        }];
        await t.waitForReady(),
        e.forEach(r => {
            try {
                t.registerServer({
                    name: r.name,
                    version: "1.0.0",
                    description: r.description,
                    server: r.createFn(),
                    capabilities: {
                        tools: {}
                    }
                }),
                console.log(`Successfully registered ${r.name}`)
            } catch (o) {
                console.error(`Failed to register ${r.name}:`, o)
            }
        }
        )
    }
    const zn = a.object({
        key: a.string().optional(),
        label: a.string(),
        name: a.string(),
        type: a.string(),
        instructions: a.string().optional(),
        required: a.union([a.literal(0), a.literal(1), a.boolean()]).optional(),
        default_value: a.any().optional(),
        placeholder: a.string().optional(),
        prepend: a.string().optional(),
        append: a.string().optional(),
        parent: a.string().optional(),
        choices: a.record(a.string(), a.string()).optional(),
        min: a.number().optional(),
        max: a.number().optional(),
        step: a.number().optional(),
        multiple: a.boolean().optional(),
        allow_null: a.boolean().optional(),
        return_format: a.string().optional(),
        sub_fields: a.array(a.lazy( () => zn)).optional(),
        layouts: a.array(a.object({
            key: a.string().optional(),
            name: a.string(),
            label: a.string(),
            display: a.string().optional(),
            sub_fields: a.array(a.lazy( () => zn))
        })).optional(),
        library: a.string().optional(),
        mime_types: a.string().optional(),
        center_lat: a.number().optional(),
        center_lng: a.number().optional(),
        zoom: a.number().optional(),
        height: a.number().optional(),
        media_upload: a.boolean().optional(),
        delay: a.number().optional(),
        ui: a.boolean().optional(),
        ui_on_text: a.string().optional(),
        ui_off_text: a.string().optional(),
        date_format: a.string().optional(),
        time_format: a.string().optional(),
        week_starts_on: a.number().optional()
    }).catchall(a.any())
      , Md = a.object({
        key: a.string().optional(),
        title: a.string(),
        fields: a.array(zn).optional(),
        location: a.array(a.array(a.object({
            param: a.string(),
            operator: a.string(),
            value: a.string()
        }))).optional(),
        menu_order: a.number().optional(),
        position: a.string().optional(),
        style: a.string().optional(),
        label_placement: a.string().optional(),
        instruction_placement: a.string().optional(),
        hide_on_screen: a.array(a.string()).optional(),
        active: a.boolean().optional(),
        description: a.string().optional(),
        show_in_rest: a.boolean().optional(),
        acfe_display_title: a.string().optional(),
        acfe_autosync: a.array(a.string()).optional(),
        acfe_permissions: a.array(a.string()).optional(),
        acfe_form: a.boolean().optional(),
        acfe_meta: a.record(a.string(), a.any()).optional(),
        acfe_note: a.string().optional()
    }).catchall(a.any())
      , lb = a.object({
        name: a.string(),
        singular_name: a.string()
    })
      , Fd = a.object({
        post_type: a.string(),
        title: a.string(),
        labels: lb.required(),
        description: a.string().optional(),
        supports: a.array(a.string()).optional(),
        hierarchical: a.boolean().optional(),
        public: a.boolean().optional(),
        show_ui: a.boolean().optional(),
        show_in_menu: a.boolean().optional(),
        menu_position: a.number().optional(),
        menu_icon: a.string().optional(),
        show_in_nav_menus: a.boolean().optional(),
        publicly_queryable: a.boolean().optional(),
        exclude_from_search: a.boolean().optional(),
        has_archive: a.boolean().optional(),
        query_var: a.union([a.boolean(), a.string()]).optional(),
        can_export: a.boolean().optional(),
        delete_with_user: a.boolean().optional(),
        show_in_rest: a.boolean().optional(),
        rest_base: a.string().optional(),
        rest_controller_class: a.string().optional(),
        map_meta_cap: a.boolean().optional(),
        capability_type: a.string().optional(),
        capabilities: a.record(a.string(), a.string()).optional(),
        rewrite: a.union([a.boolean(), a.object({
            slug: a.string().optional(),
            with_front: a.boolean().optional(),
            feeds: a.boolean().optional(),
            pages: a.boolean().optional(),
            ep_mask: a.number().optional()
        })]).optional(),
        taxonomies: a.array(a.string()).optional()
    }).catchall(a.any())
      , Wd = a.object({
        taxonomy: a.string(),
        object_type: a.array(a.string()),
        label: a.string(),
        labels: a.record(a.string(), a.string()).optional(),
        description: a.string().optional(),
        hierarchical: a.boolean().optional(),
        public: a.boolean().optional(),
        publicly_queryable: a.boolean().optional(),
        show_ui: a.boolean().optional(),
        show_in_menu: a.boolean().optional(),
        show_in_nav_menus: a.boolean().optional(),
        show_tagcloud: a.boolean().optional(),
        show_in_quick_edit: a.boolean().optional(),
        show_admin_column: a.boolean().optional(),
        meta_box_cb: a.union([a.string(), a.boolean()]).optional(),
        meta_box_sanitize_cb: a.string().optional(),
        capabilities: a.record(a.string(), a.string()).optional(),
        show_in_rest: a.boolean().optional(),
        rest_base: a.string().optional(),
        rest_controller_class: a.string().optional(),
        rewrite: a.union([a.boolean(), a.object({
            slug: a.string().optional(),
            with_front: a.boolean().optional(),
            hierarchical: a.boolean().optional(),
            ep_mask: a.number().optional()
        })]).optional(),
        update_count_callback: a.string().optional(),
        default_term: a.union([a.string(), a.object({
            name: a.string().optional(),
            slug: a.string().optional(),
            description: a.string().optional()
        })]).optional(),
        sort: a.boolean().optional()
    }).catchall(a.any());
    async function Be(t, e, r) {
        var d;
        const o = window.location.origin + "/index.php"
          , n = new URL(o);
        n.searchParams.set("rest_route", `/acf/v1/${t}`);
        const s = n.toString()
          , i = {
            "Content-Type": "application/json",
            "X-WP-Nonce": ((d = window.wpApiSettings) == null ? void 0 : d.nonce) || ""
        }
          , l = {
            method: e,
            headers: i,
            credentials: "same-origin"
        };
        r && (e === "POST" || e === "PUT") && (l.body = JSON.stringify(r));
        try {
            console.log("[ACF API] Making request:", {
                url: s,
                method: e,
                headers: i,
                endpoint: t
            });
            const u = await fetch(s, l);
            if (!u.ok)
                throw new Error(`HTTP error ${u.status}: ${await u.text()}`);
            return u.status === 204 || u.headers.get("content-length") === "0" ? (console.log("ACF API returned empty response (204 No Content or empty body)"),
            null) : await u.json()
        } catch (u) {
            throw console.error("ACF API call failed:", u),
            u
        }
    }
    function cb() {
        const t = new He({
            name: "acf-server",
            version: "1.0.0"
        },{
            capabilities: {
                resources: {
                    subscribe: !0
                }
            }
        });
        return t.tool("get-field-groups", "Retrieves all ACF field groups from the WordPress site. Use this to see what field groups already exist and their configurations.", {}, async () => {
            console.log("[ACF Server] get-field-groups");
            try {
                const e = await Be("field-groups", "GET");
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(e, null, 2)
                    }]
                }
            } catch (e) {
                return console.error("[ACF Server] get-field-groups error:", e),
                {
                    content: [{
                        type: "text",
                        text: `Error retrieving field groups: ${e.message}`
                    }]
                }
            }
        }
        ),
        t.tool("get-field-group", "Retrieves a specific ACF field group by ID. Use this to examine the structure and settings of a particular field group.", {
            groupId: a.string().describe('The ID of the field group to retrieve (e.g., "group_12345abcde")')
        }, async ({groupId: e}) => {
            console.log("[ACF Server] get-field-group", {
                groupId: e
            });
            try {
                const r = await Be(`field-groups/${e}`, "GET");
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(r, null, 2)
                    }]
                }
            } catch (r) {
                return console.error("[ACF Server] get-field-group error:", r),
                {
                    content: [{
                        type: "text",
                        text: `Error retrieving field group ${e}: ${r.message}`
                    }]
                }
            }
        }
        ),
        t.tool("create-field-group", "Creates a new ACF field group. Before creating check if the field group already exists.", {
            fieldGroup: Md.describe("The field group configuration")
        }, async ({fieldGroup: e}) => {
            console.log("[ACF Server] create-field-group", {
                fieldGroup: e
            });
            try {
                const r = await Be("field-groups", "POST", e);
                return {
                    content: [{
                        type: "text",
                        text: `Field group "${e.title}" created successfully. ID: ${r.key || r.id}`
                    }]
                }
            } catch (r) {
                return console.error("[ACF Server] create-field-group error:", r),
                {
                    content: [{
                        type: "text",
                        text: `Error creating field group: ${r.message}`
                    }]
                }
            }
        }
        ),
        t.tool("update-field-group", "Updates an existing ACF field group. Use this to modify the settings or fields of an existing field group.", {
            groupId: a.string().describe('The ID of the field group to update (e.g., "group_12345abcde")'),
            fieldGroup: Md.describe("The updated field group configuration")
        }, async ({groupId: e, fieldGroup: r}) => {
            console.log("[ACF Server] update-field-group", {
                groupId: e,
                fieldGroup: r
            });
            try {
                return await Be(`field-groups/${e}`, "PUT", r),
                {
                    content: [{
                        type: "text",
                        text: `Field group "${r.title}" updated successfully.`
                    }]
                }
            } catch (o) {
                return console.error("[ACF Server] update-field-group error:", o),
                {
                    content: [{
                        type: "text",
                        text: `Error updating field group ${e}: ${o.message}`
                    }]
                }
            }
        }
        ),
        t.tool("delete-field-group", "Deletes an ACF field group. Use this to remove a field group that is no longer needed.", {
            groupId: a.string().describe('The ID of the field group to delete (e.g., "group_12345abcde")'),
            confirmationMessage: a.string().optional().describe(`A clear explanation of what will be deleted and its impact (this would be shown to the user before proceeding to ensure they understand the consequences of this action). Example: "You're about to permanently delete the 'Contact Information' field group and all its associated fields. This action cannot be undone and may affect content that uses these fields."`)
        }, {
            title: "Delete Field Group",
            destructiveHint: !0
        }, async ({groupId: e}) => {
            console.log("[ACF Server] delete-field-group", {
                groupId: e
            });
            try {
                return await Be(`field-groups/${e}`, "DELETE"),
                {
                    content: [{
                        type: "text",
                        text: `Field group ${e} deleted successfully.`
                    }]
                }
            } catch (r) {
                return console.error("[ACF Server] delete-field-group error:", r),
                {
                    content: [{
                        type: "text",
                        text: `Error deleting field group ${e}: ${r.message}`
                    }]
                }
            }
        }
        ),
        t.tool("get-fields", "Retrieves all ACF fields from the WordPress site. Use this to see what fields already exist across all field groups.", {}, async () => {
            console.log("[ACF Server] get-fields");
            try {
                const e = await Be("fields", "GET");
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(e, null, 2)
                    }]
                }
            } catch (e) {
                return console.error("[ACF Server] get-fields error:", e),
                {
                    content: [{
                        type: "text",
                        text: `Error retrieving fields: ${e.message}`
                    }]
                }
            }
        }
        ),
        t.tool("get-field", "Retrieves a specific ACF field by ID. Use this to examine the structure and settings of a particular field.", {
            fieldId: a.string().describe('The ID of the field to retrieve (e.g., "field_12345abcde")')
        }, async ({fieldId: e}) => {
            console.log("[ACF Server] get-field", {
                fieldId: e
            });
            try {
                const r = await Be(`fields/${e}`, "GET");
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(r, null, 2)
                    }]
                }
            } catch (r) {
                return console.error("[ACF Server] get-field error:", r),
                {
                    content: [{
                        type: "text",
                        text: `Error retrieving field ${e}: ${r.message}`
                    }]
                }
            }
        }
        ),
        t.tool("get-fields-by-group", "Retrieves all fields belonging to a specific field group. Use this to see the structure of fields within a group.", {
            groupId: a.string().describe('The ID of the field group (e.g., "group_12345abcde")')
        }, async ({groupId: e}) => {
            console.log("[ACF Server] get-fields-by-group", {
                groupId: e
            });
            try {
                const r = await Be(`field-groups/${e}/fields`, "GET");
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(r, null, 2)
                    }]
                }
            } catch (r) {
                return console.error("[ACF Server] get-fields-by-group error:", r),
                {
                    content: [{
                        type: "text",
                        text: `Error retrieving fields for group ${e}: ${r.message}`
                    }]
                }
            }
        }
        ),
        t.tool("create-field", "Creates a new ACF field within a field group. Use this to add a custom field to an existing group.", {
            field: zn.describe("The field configuration"),
            parentId: a.string().describe('The ID of the parent field group (e.g., "group_12345abcde")')
        }, async ({field: e, parentId: r}) => {
            console.log("[ACF Server] create-field", {
                field: e,
                parentId: r
            });
            try {
                const o = {
                    ...e,
                    parent: r
                }
                  , n = await Be("fields", "POST", o);
                return {
                    content: [{
                        type: "text",
                        text: `Field "${e.label}" created successfully. ID: ${n.key || n.id}`
                    }]
                }
            } catch (o) {
                return console.error("[ACF Server] create-field error:", o),
                {
                    content: [{
                        type: "text",
                        text: `Error creating field: ${o.message}`
                    }]
                }
            }
        }
        ),
        t.tool("update-field", "Updates an existing ACF field. Use this to modify the settings of an existing field.", {
            fieldId: a.string().describe('The ID of the field to update (e.g., "field_12345abcde")'),
            field: zn.describe("The updated field configuration")
        }, async ({fieldId: e, field: r}) => {
            console.log("[ACF Server] update-field", {
                fieldId: e,
                field: r
            });
            try {
                return await Be(`fields/${e}`, "PUT", r),
                {
                    content: [{
                        type: "text",
                        text: `Field "${r.label}" updated successfully.`
                    }]
                }
            } catch (o) {
                return console.error("[ACF Server] update-field error:", o),
                {
                    content: [{
                        type: "text",
                        text: `Error updating field ${e}: ${o.message}`
                    }]
                }
            }
        }
        ),
        t.tool("delete-field", "Deletes an ACF field. Use this to remove a field that is no longer needed.", {
            fieldId: a.string().describe('The ID of the field to delete (e.g., "field_12345abcde")'),
            confirmationMessage: a.string().optional().describe(`A clear explanation of what will be deleted and its impact (this would be shown to the user before proceeding to ensure they understand the consequences of this action). Example: "You're about to permanently delete the 'Email Address' custom field. This action cannot be undone and will remove the field from all content that uses it."`)
        }, {
            title: "Delete Field",
            destructiveHint: !0
        }, async ({fieldId: e}) => {
            console.log("[ACF Server] delete-field", {
                fieldId: e
            });
            try {
                return await Be(`fields/${e}`, "DELETE"),
                {
                    content: [{
                        type: "text",
                        text: `Field ${e} deleted successfully.`
                    }]
                }
            } catch (r) {
                return console.error("[ACF Server] delete-field error:", r),
                {
                    content: [{
                        type: "text",
                        text: `Error deleting field ${e}: ${r.message}`
                    }]
                }
            }
        }
        ),
        t.tool("get-post-types", "Retrieves all custom post types from the WordPress site. Use this to see what post types already exist.", {}, async () => {
            console.log("[ACF Server] get-post-types");
            try {
                const e = await Be("post-types", "GET");
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(e, null, 2)
                    }]
                }
            } catch (e) {
                return console.error("[ACF Server] get-post-types error:", e),
                {
                    content: [{
                        type: "text",
                        text: `Error retrieving post types: ${e.message}`
                    }]
                }
            }
        }
        ),
        t.tool("get-post-type", "Retrieves a specific custom post type by ID. Use this to examine the configuration of a particular post type.", {
            postType: a.string().describe('The ID of the post type to retrieve (e.g., "product")')
        }, async ({postType: e}) => {
            console.log("[ACF Server] get-post-type", {
                postType: e
            });
            try {
                const r = await Be(`post-types/${e}`, "GET");
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(r, null, 2)
                    }]
                }
            } catch (r) {
                return console.error("[ACF Server] get-post-type error:", r),
                {
                    content: [{
                        type: "text",
                        text: `Error retrieving post type ${e}: ${r.message}`
                    }]
                }
            }
        }
        ),
        t.tool("create-post-type", "Creates a new custom post type in WordPress. Before creating check if the post type already exists.", {
            postType: Fd.describe("The post type configuration")
        }, async ({postType: e}) => {
            console.log("[ACF Server] create-post-type", {
                postType: e
            });
            try {
                return await Be("post-types", "POST", e),
                {
                    content: [{
                        type: "text",
                        text: `Post type "${e.title}" (${e.post_type}) created successfully.`
                    }]
                }
            } catch (r) {
                return console.error("[ACF Server] create-post-type error:", r),
                {
                    content: [{
                        type: "text",
                        text: `Error creating post type: ${r.message}`
                    }]
                }
            }
        }
        ),
        t.tool("update-post-type", "Updates an existing custom post type. Use this to modify the settings of an existing post type.", {
            postTypeId: a.string().describe('The ID of the post type to update (e.g., "product")'),
            postType: Fd.describe("The updated post type configuration")
        }, async ({postTypeId: e, postType: r}) => {
            console.log("[ACF Server] update-post-type", {
                postTypeId: e,
                postType: r
            });
            try {
                return await Be(`post-types/${e}`, "PUT", r),
                {
                    content: [{
                        type: "text",
                        text: `Post type "${r.title}" updated successfully.`
                    }]
                }
            } catch (o) {
                return console.error("[ACF Server] update-post-type error:", o),
                {
                    content: [{
                        type: "text",
                        text: `Error updating post type ${e}: ${o.message}`
                    }]
                }
            }
        }
        ),
        t.tool("delete-post-type", "Deletes a custom post type. Use this to remove a post type that is no longer needed.", {
            postTypeId: a.string().describe('The ID of the post type to delete (e.g., "product")'),
            confirmationMessage: a.string().optional().describe(`A clear explanation of what will be deleted and its impact (this would be shown to the user before proceeding to ensure they understand the consequences of this action). Example: "You're about to permanently delete the 'Product' custom post type. This action cannot be undone and will affect all content of this type."`)
        }, {
            title: "Delete Post Type",
            destructiveHint: !0
        }, async ({postTypeId: e}) => {
            console.log("[ACF Server] delete-post-type", {
                postTypeId: e
            });
            try {
                return await Be(`post-types/${e}`, "DELETE"),
                {
                    content: [{
                        type: "text",
                        text: `Post type ${e} deleted successfully.`
                    }]
                }
            } catch (r) {
                return console.error("[ACF Server] delete-post-type error:", r),
                {
                    content: [{
                        type: "text",
                        text: `Error deleting post type ${e}: ${r.message}`
                    }]
                }
            }
        }
        ),
        t.tool("get-taxonomies", "Retrieves all custom taxonomies from the WordPress site. Use this to see what taxonomies already exist.", {}, async () => {
            console.log("[ACF Server] get-taxonomies");
            try {
                const e = await Be("taxonomies", "GET");
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(e, null, 2)
                    }]
                }
            } catch (e) {
                return console.error("[ACF Server] get-taxonomies error:", e),
                {
                    content: [{
                        type: "text",
                        text: `Error retrieving taxonomies: ${e.message}`
                    }]
                }
            }
        }
        ),
        t.tool("get-taxonomy", "Retrieves a specific custom taxonomy by ID. Use this to examine the configuration of a particular taxonomy.", {
            taxonomyId: a.string().describe('The ID of the taxonomy to retrieve (e.g., "product_category")')
        }, async ({taxonomyId: e}) => {
            console.log("[ACF Server] get-taxonomy", {
                taxonomyId: e
            });
            try {
                const r = await Be(`taxonomies/${e}`, "GET");
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(r, null, 2)
                    }]
                }
            } catch (r) {
                return console.error("[ACF Server] get-taxonomy error:", r),
                {
                    content: [{
                        type: "text",
                        text: `Error retrieving taxonomy ${e}: ${r.message}`
                    }]
                }
            }
        }
        ),
        t.tool("create-taxonomy", "Creates a new custom taxonomy in WordPress. Before creating check if the taxonomy already exists.", {
            taxonomy: Wd.describe("The taxonomy configuration")
        }, async ({taxonomy: e}) => {
            console.log("[ACF Server] create-taxonomy", {
                taxonomy: e
            });
            try {
                return await Be("taxonomies", "POST", e),
                {
                    content: [{
                        type: "text",
                        text: `Taxonomy "${e.label}" (${e.taxonomy}) created successfully.`
                    }]
                }
            } catch (r) {
                return console.error("[ACF Server] create-taxonomy error:", r),
                {
                    content: [{
                        type: "text",
                        text: `Error creating taxonomy: ${r.message}`
                    }]
                }
            }
        }
        ),
        t.tool("update-taxonomy", "Updates an existing custom taxonomy. Use this to modify the settings of an existing taxonomy.", {
            taxonomyId: a.string().describe('The ID of the taxonomy to update (e.g., "product_category")'),
            taxonomy: Wd.describe("The updated taxonomy configuration")
        }, async ({taxonomyId: e, taxonomy: r}) => {
            console.log("[ACF Server] update-taxonomy", {
                taxonomyId: e,
                taxonomy: r
            });
            try {
                return await Be(`taxonomies/${e}`, "PUT", r),
                {
                    content: [{
                        type: "text",
                        text: `Taxonomy "${r.label}" updated successfully.`
                    }]
                }
            } catch (o) {
                return console.error("[ACF Server] update-taxonomy error:", o),
                {
                    content: [{
                        type: "text",
                        text: `Error updating taxonomy ${e}: ${o.message}`
                    }]
                }
            }
        }
        ),
        t.tool("delete-taxonomy", "Deletes a custom taxonomy. Use this to remove a taxonomy that is no longer needed.", {
            taxonomyId: a.string().describe('The ID of the taxonomy to delete (e.g., "product_category")'),
            confirmationMessage: a.string().optional().describe(`A clear explanation of what will be deleted and its impact (this would be shown to the user before proceeding to ensure they understand the consequences of this action). Example: "You're about to permanently delete the 'Product Category' custom taxonomy. This action cannot be undone and will remove all associated terms and categorization."`)
        }, {
            title: "Delete Taxonomy",
            destructiveHint: !0
        }, async ({taxonomyId: e}) => {
            console.log("[ACF Server] delete-taxonomy", {
                taxonomyId: e
            });
            try {
                return await Be(`taxonomies/${e}`, "DELETE"),
                {
                    content: [{
                        type: "text",
                        text: `Taxonomy ${e} deleted successfully.`
                    }]
                }
            } catch (r) {
                return console.error("[ACF Server] delete-taxonomy error:", r),
                {
                    content: [{
                        type: "text",
                        text: `Error deleting taxonomy ${e}: ${r.message}`
                    }]
                }
            }
        }
        ),
        t.tool("check-acf-status", "Checks if the ACF plugin is installed and active on the WordPress site. Use this to verify compatibility before using other ACF tools.", {}, async () => {
            var e;
            console.log("[ACF Server] check-acf-status");
            try {
                return {
                    content: [{
                        type: "text",
                        text: (await fetch(`${window.location.origin}?rest_route=/acf/v1`, {
                            method: "GET",
                            headers: {
                                "Content-Type": "application/json",
                                "X-WP-Nonce": ((e = window.wpApiSettings) == null ? void 0 : e.nonce) || ""
                            },
                            credentials: "same-origin"
                        })).status !== 404 ? "ACF plugin is installed and active." : "ACF plugin is not installed or not active. Please install and activate the Advanced Custom Fields plugin to use these tools."
                    }]
                }
            } catch (r) {
                return console.error("[ACF Server] check-acf-status error:", r),
                {
                    content: [{
                        type: "text",
                        text: `Error checking ACF status: ${r.message}. ACF plugin may not be installed or the REST API may be disabled.`
                    }]
                }
            }
        }
        ),
        t.tool("suggest-field-structure", "Suggests a field group structure for a specific post type based on common use cases. Use this to get recommendations for your content structure.", {
            postType: a.string().describe('The post type to suggest fields for (e.g., "course", "product", "event")'),
            purpose: a.string().describe('The purpose or industry for this content (e.g., "education", "ecommerce", "real estate")')
        }, async ({postType: e, purpose: r}) => {
            console.log("[ACF Server] suggest-field-structure", {
                postType: e,
                purpose: r
            });
            let o;
            switch (e.toLowerCase()) {
            case "course":
                o = {
                    title: "Course Details",
                    fields: [{
                        label: "Duration",
                        name: "duration",
                        type: "text",
                        instructions: 'Course duration (e.g., "8 weeks")'
                    }, {
                        label: "Difficulty Level",
                        name: "difficulty_level",
                        type: "select",
                        choices: {
                            beginner: "Beginner",
                            intermediate: "Intermediate",
                            advanced: "Advanced"
                        }
                    }, {
                        label: "Prerequisites",
                        name: "prerequisites",
                        type: "textarea"
                    }, {
                        label: "Instructor",
                        name: "instructor",
                        type: "text"
                    }, {
                        label: "Start Date",
                        name: "start_date",
                        type: "date_picker"
                    }, {
                        label: "Syllabus",
                        name: "syllabus",
                        type: "wysiwyg"
                    }],
                    location: [[{
                        param: "post_type",
                        operator: "==",
                        value: "course"
                    }]]
                };
                break;
            case "product":
                o = {
                    title: "Product Information",
                    fields: [{
                        label: "Price",
                        name: "price",
                        type: "number",
                        instructions: "Product price in $"
                    }, {
                        label: "Sale Price",
                        name: "sale_price",
                        type: "number",
                        instructions: "Sale price (if applicable)"
                    }, {
                        label: "SKU",
                        name: "sku",
                        type: "text"
                    }, {
                        label: "Weight",
                        name: "weight",
                        type: "number"
                    }, {
                        label: "Dimensions",
                        name: "dimensions",
                        type: "group",
                        sub_fields: [{
                            label: "Length",
                            name: "length",
                            type: "number"
                        }, {
                            label: "Width",
                            name: "width",
                            type: "number"
                        }, {
                            label: "Height",
                            name: "height",
                            type: "number"
                        }]
                    }, {
                        label: "Features",
                        name: "features",
                        type: "repeater",
                        sub_fields: [{
                            label: "Feature",
                            name: "feature",
                            type: "text"
                        }]
                    }],
                    location: [[{
                        param: "post_type",
                        operator: "==",
                        value: "product"
                    }]]
                };
                break;
            case "event":
                o = {
                    title: "Event Details",
                    fields: [{
                        label: "Start Date/Time",
                        name: "start_datetime",
                        type: "date_time_picker"
                    }, {
                        label: "End Date/Time",
                        name: "end_datetime",
                        type: "date_time_picker"
                    }, {
                        label: "Location",
                        name: "location",
                        type: "text"
                    }, {
                        label: "Address",
                        name: "address",
                        type: "textarea"
                    }, {
                        label: "Map",
                        name: "map",
                        type: "google_map"
                    }, {
                        label: "Organizer",
                        name: "organizer",
                        type: "text"
                    }, {
                        label: "Cost",
                        name: "cost",
                        type: "number"
                    }, {
                        label: "Registration Link",
                        name: "registration_link",
                        type: "url"
                    }],
                    location: [[{
                        param: "post_type",
                        operator: "==",
                        value: "event"
                    }]]
                };
                break;
            default:
                o = {
                    title: `${e.charAt(0).toUpperCase() + e.slice(1)} Details`,
                    fields: [{
                        label: "Additional Information",
                        name: "additional_information",
                        type: "wysiwyg"
                    }],
                    location: [[{
                        param: "post_type",
                        operator: "==",
                        value: e
                    }]]
                }
            }
            return {
                content: [{
                    type: "text",
                    text: `Suggested field structure for "${e}" post type:

${JSON.stringify(o, null, 2)}`
                }]
            }
        }
        ),
        t
    }
    const qd = a.object({
        length: a.string().optional(),
        width: a.string().optional(),
        height: a.string().optional()
    })
      , Gd = a.object({
        id: a.number().optional(),
        name: a.string().optional()
    })
      , db = a.object({
        name: a.string().describe('The attribute name (e.g., "Size", "Color", "Material") - will check for existing global attributes first'),
        options: a.array(a.string()).describe('Available options for this attribute (e.g., ["Small", "Medium", "Large"] for Size)'),
        variation: a.boolean().default(!0).describe("Whether this attribute should be used for variations (should be true for variable products)"),
        visible: a.boolean().default(!0).describe("Whether this attribute is visible on the product page")
    })
      , ub = a.object({
        name: a.string().describe('The attribute name (e.g., "Size", "Color") - must match exactly with an attribute name from the attributes array'),
        option: a.string().describe('The specific option value (e.g., "Large", "Red") - must be one of the options defined for this attribute')
    })
      , mb = a.object({
        attributes: a.array(ub).describe("The combination of attribute values that defines this variation"),
        regularPrice: a.string().optional().describe("Regular price for this specific variation"),
        salePrice: a.string().optional().describe("Sale price for this specific variation"),
        sku: a.string().optional().describe("Unique SKU for this variation"),
        weight: a.string().optional().describe("Weight for this specific variation"),
        dimensions: qd.optional().describe("Dimensions for this specific variation"),
        stockQuantity: a.number().optional().describe("Stock quantity for this variation"),
        manageStock: a.boolean().optional().describe("Whether to manage stock for this variation"),
        description: a.string().optional().describe("Description for this specific variation")
    })
      , pb = a.object({
        name: a.string().describe("The product name/title that will be displayed to customers"),
        type: a.enum(["simple", "variable"]).default("simple").describe('Product type: "simple" for single products, "variable" for products with variations (size, color, etc.)'),
        description: a.string().optional().describe("Detailed product description in HTML format that appears on the product page"),
        short_description: a.string().optional().describe("Brief product summary that appears in product listings and excerpts"),
        regular_price: a.string().optional().describe('The regular selling price for simple products (without currency symbol, e.g., "29.99") - not used for variable products'),
        sale_price: a.string().optional().describe('The discounted price for simple products (without currency symbol, e.g., "19.99") - not used for variable products'),
        sku: a.string().optional().describe("Stock Keeping Unit - unique identifier for inventory management"),
        status: a.enum(["draft", "pending", "private", "publish"]).default("draft").describe('Product publication status - use "draft" unless asked directly otherwise'),
        catalog_visibility: a.enum(["visible", "catalog", "search", "hidden"]).optional().describe('Where the product appears: "visible" (catalog and search), "catalog" (only in catalog), "search" (only in search), "hidden" (nowhere)'),
        featured: a.boolean().optional().describe("Whether this product should be marked as featured for promotional purposes"),
        virtual: a.boolean().optional().describe("Set to true for digital/downloadable products that do not require shipping"),
        downloadable: a.boolean().optional().describe("Set to true if this product includes downloadable files for customers"),
        weight: a.string().optional().describe('Product weight for shipping calculations for simple products (e.g., "1.5" for 1.5 kg) - variations can override this'),
        dimensions: qd.optional().describe("Product dimensions for shipping for simple products - variations can override this"),
        categories: a.array(Gd).optional().describe("Product categories - provide either existing category IDs or names for new categories (names will be created if they don't exist)"),
        tags: a.array(Gd).optional().describe("Product tags for better searchability - provide either existing tag IDs or names"),
        manage_stock: a.boolean().optional().describe("Whether to enable stock quantity tracking for simple products - variations handle their own stock"),
        stock_quantity: a.number().optional().describe("Current stock quantity for simple products (only used when manage_stock is true)"),
        low_stock_amount: a.number().optional().describe("Threshold quantity that triggers low stock notifications"),
        backorders: a.enum(["no", "notify", "yes"]).optional().describe('Backorder policy: "no" (not allowed), "notify" (allowed with notification), "yes" (allowed)'),
        attributes: a.array(db).optional().describe("Product attributes for variable products - the tool will check for existing global attributes and reuse them to avoid duplicates"),
        variations: a.array(mb).optional().describe("Product variations - each represents one combination of attributes with specific pricing/stock data")
    });
    function Bd(t) {
        const {root: e} = vr();
        let r = t.replace(/^\/+/, "");
        return r.startsWith(`${mt.slice(0, mt.length - 1)}`) || (r = `${mt}${r}`),
        `${e}${r}`
    }
    const hb = async () => {
        const t = new He({
            name: "woocommerce-server",
            version: "1.0.0"
        });
        wd(t);
        async function e() {
            try {
                const {root: v} = vr()
                  , S = await Pt(`${v}${mt}`);
                if (!S.ok) {
                    let k = "";
                    try {
                        const C = await S.json();
                        k = C.message || JSON.stringify(C)
                    } catch (C) {
                        console.warn("Failed to parse error response as JSON:", C)
                    }
                    throw new Error(`Failed to fetch WooCommerce API index: ${S.statusText}
				Error details: ${k}.`)
                }
                const w = await S.json()
                  , _ = w.routes || w
                  , I = Object.entries(_).map( ([k,C]) => ({
                    path: k,
                    methods: C.methods || []
                }));
                return {
                    content: [{
                        type: "text",
                        text: ` WooCommerce REST API Endpoints:
"""
${JSON.stringify(I, null, 2)}
"""`
                    }]
                }
            } catch (v) {
                return console.error("Error in list-endpoints:", v),
                {
                    isError: !0,
                    content: [{
                        type: "text",
                        text: `Error listing endpoints: ${vinstanceof Error ? v.message : String(v)}`
                    }]
                }
            }
        }
        t.tool("list-functionalities", `Lists all available functionalities for WooCommerce. 
Use this when you need to discover how to interact with WooCommerce features, so that you can perform actions in WooCommerce.
Best for preforming CRUD actions on WooCommerce entities like products/categories/orders, etc...
The tool will return all woo REST API endpoints, including their path patterns and supported HTTP methods.

# WooCommerce Guidelines:
- The first time you call the WooCommerce API in the conversation, you must call the 'list-functionalities' tool to get the available endpoints.
- The first time you call a specific endpoint of WooCommerce in the conversation, you must call the 'get-endpoints-params' tool for the endpoint. Try to get the params for multiple endpoints in one call.
- You must plan ahead and call "get-endpoints-params" only once with all the routes you will need in order to fulfill the request.
- Prefer to use "call-endpoint-with-params" in parallel for efficiency.
- For adding products no need to call this tool.`, {}, async () => await e());
        async function r(v, S) {
            var w, _, I;
            try {
                if (!v) {
                    const L = `You must first call the list-functionalities tool to get the list of available WooCommerce endpoints and their methods.
I took the liberty to do it for you so you wouldn't need.
Here's the list of available endpoints and methods: ${(_ = (w = (await e()).content) == null ? void 0 : w[0]) == null ? void 0 : _.text}.

Now that you have the required knowledge you can recall this tool (get-endpoints-params). Make sure to set wasListFunctionalitiesCalled to true.`;
                    throw new Error(L)
                }
                const k = [];
                for (const {route: C, method: L} of S)
                    try {
                        const N = Bd(C)
                          , A = await Pt(N, {
                            method: "OPTIONS"
                        });
                        if (!A.ok) {
                            let q = "";
                            try {
                                const ee = await A.json();
                                q = ee.message || JSON.stringify(ee)
                            } catch (ee) {
                                console.warn("Failed to parse error response as JSON:", ee)
                            }
                            k.push({
                                route: C,
                                method: L,
                                error: `Failed to fetch endpoint parameters: ${A.statusText}. Error details: ${q}.`
                            });
                            continue
                        }
                        const R = (I = (await A.json()).endpoints) == null ? void 0 : I.find(q => q.methods.includes(L.toUpperCase()));
                        R ? k.push({
                            route: C,
                            method: L,
                            schema: R.args
                        }) : k.push({
                            route: C,
                            method: L,
                            error: `Method ${L.toUpperCase()} not found for endpoint ${C}`
                        })
                    } catch (N) {
                        k.push({
                            route: C,
                            method: L,
                            error: `Error fetching schema: ${Ninstanceof Error ? N.message : String(N)}`
                        })
                    }
                return {
                    content: [{
                        type: "text",
                        text: `woo_endpoint_zod_schemas:
"""
${JSON.stringify(k, null, 2)}
"""
You can now call the call-endpoint-with-params tool with these schemas.`
                    }]
                }
            } catch (k) {
                return console.error("Error in get-endpoints-params:", k),
                {
                    isError: !0,
                    content: [{
                        type: "text",
                        text: `Error getting endpoint params: ${kinstanceof Error ? k.message : String(k)}`
                    }]
                }
            }
        }
        t.tool("get-endpoints-params", `Given one or more WooCommerce REST API endpoint paths and HTTP methods, returns the parameter schemas (as Zod-like JSON) for those endpoints and methods.
Use this to discover what parameters are required or accepted for specific endpoints and methods.
Best for preforming CRUD actions on WooCommerce entities like products/categories/orders, etc...
The tool will return the parameters objects (if available) for the specified endpoints and methods, or error messages if not found.
You must first call the list-functionalities tool to get the list of available endpoints and their methods.

# WooCommerce Guidelines:
- The first time you call the WooCommerce API in the conversation, you must call the 'list-functionalities' tool to get the available endpoints.
- The first time you call a specific endpoint of WooCommerce in the conversation, you must call the 'get-endpoints-params' tool for the endpoint. Try to get the params for multiple endpoints in one call.
- You must plan ahead and call "get-endpoints-params" only once with all the routes you will need in order to fulfill the request.
- Prefer to use "call-endpoint-with-params" in parallel for efficiency.
- For adding products no need to call this tool.`, {
            routeMethodPairs: a.array(a.object({
                route: a.string().describe(`The endpoint route ${mt}... for instance products/categories`),
                method: a.string().describe("The HTTP method, e.g. GET, POST, PUT, DELETE")
            })).describe("Array of route and method pairs to get parameter schemas for"),
            wasListFunctionalitiesCalled: a.boolean().describe("Whether the list-functionalities tool was called anytime in the conversation before this tool.")
        }, async ({routeMethodPairs: v, wasListFunctionalitiesCalled: S}) => await r(S, v)),
        t.tool("call-endpoint-with-params", `Calls a WooCommerce REST API endpoint with the specified HTTP method and parameters.
Use this when you need to invoke a WooCommerce endpoint directly with custom parameters.
Best for preforming CRUD actions on WooCommerce entities like products/categories/orders, etc...
The tool will return the raw response from the endpoint.
You MUST first call the list-functionalities tool to get the list of available endpoints and their methods.
You must first call the get-endpoints-params tool to get the parameters for the endpoint.

# WooCommerce Guidelines:
- The first time you call the WooCommerce API in the conversation, you must call the 'list-functionalities' tool to get the available endpoints.
- The first time you call a specific endpoint of WooCommerce in the conversation, you must call the 'get-endpoints-params' tool for the endpoint. Try to get the params for multiple endpoints in one call.
- You must plan ahead and call "get-endpoints-params" only once with all the routes you will need in order to fulfill the request.
- Prefer to use "call-endpoint-with-params" in parallel for efficiency.
- For adding products no need to call this tool.
`, {
            route: a.string().describe("The endpoint route, e.g. products/categories"),
            method: a.string().describe("The HTTP method, e.g. GET, POST, PUT, DELETE"),
            params: a.string().describe("A JSON string representing the parameters to send, matching the endpoint's Zod-like schema"),
            wasListFunctionalitiesCalled: a.boolean().describe("Whether the list-functionalities tool was called anytime in the conversation before this tool."),
            wasGetEndpointParamsToolCalled: a.boolean().describe("Whether the get-endpoints-params tool was called for this endpoint anytime in the conversation before this tool.")
        }, async ({route: v, method: S, params: w, wasListFunctionalitiesCalled: _, wasGetEndpointParamsToolCalled: I}) => {
            var k, C, L, N;
            try {
                if (!_) {
                    const re = `You must first call the list-functionalities tool to get the list of available WooCommerce endpoints and their methods.
I took the liberty to do it for you so you wouldn't need.
Here's the list of available endpoints and methods: ${(C = (k = (await e()).content) == null ? void 0 : k[0]) == null ? void 0 : C.text}.

Now that you have the required knowledge you can recall this tool (call-endpoint-with-params). Make sure to set wasListFunctionalitiesCalled to true.`;
                    throw new Error(re)
                }
                if (!I) {
                    const te = (N = (L = (await r(_, [{
                        route: v,
                        method: S
                    }])).content) == null ? void 0 : L[0]) == null ? void 0 : N.text
                      , re = `You must first call the get-endpoints-params tool to get the parameters for the WooCommerce endpoint and method you want to call.
I took the liberty to do it for you so you wouldn't need.
Here are the parameters for the endpoint ${v} and method ${S}: 
"""
${te}
"""
Now that you have the required knowledge you can recall this tool (call-endpoint-with-params) with the correct parameters. Make sure to set wasGetEndpointParamsToolCalled to true.`;
                    throw new Error(re)
                }
                let A = {};
                try {
                    A = w ? JSON.parse(w) : {}
                } catch (te) {
                    return {
                        isError: !0,
                        content: [{
                            type: "text",
                            text: `Invalid params JSON: ${teinstanceof Error ? te.message : String(te)}`
                        }]
                    }
                }
                let $ = Bd(v);
                const R = {
                    method: S.toUpperCase()
                };
                if (["GET", "DELETE"].includes(S.toUpperCase())) {
                    const te = new URLSearchParams(A).toString();
                    te && ($ += ($.includes("?") ? "&" : "?") + te)
                } else
                    R.body = JSON.stringify(A);
                const q = await Pt($, R);
                if (!q.ok) {
                    let te = "";
                    try {
                        const re = await q.json();
                        te = re.message || JSON.stringify(re)
                    } catch (re) {
                        console.warn("Failed to parse error response as JSON:", re)
                    }
                    return {
                        isError: !0,
                        content: [{
                            type: "text",
                            text: `Error calling endpoint: Got ${q.status} ${q.statusText} from ${q.url}.
								Error details: ${te}`
                        }]
                    }
                }
                const ee = await q.text();
                let ne;
                try {
                    ne = JSON.parse(ee)
                } catch {
                    ne = ee
                }
                return {
                    content: [{
                        type: "text",
                        text: `result:
"""
${typeof ne == "string" ? ne : JSON.stringify(ne)}
"""`
                    }]
                }
            } catch (A) {
                return console.error("Error in call-endpoint-with-params:", A),
                {
                    isError: !0,
                    content: [{
                        type: "text",
                        text: `Error calling endpoint: ${Ainstanceof Error ? A.message : String(A)}`
                    }]
                }
            }
        }
        );
        async function o(v) {
            try {
                const S = await Pt(`${v}${mt}products/categories`);
                return S.ok ? await S.json() : []
            } catch (S) {
                return console.warn("Failed to fetch existing categories:", S),
                []
            }
        }
        async function n(v, S) {
            const w = {
                name: v.name,
                slug: v.slug || v.name.toLowerCase().replace(/\s+/g, "-"),
                description: v.description || "",
                parent: v.parent || 0
            };
            try {
                const _ = await Pt(`${S}${mt}products/categories`, {
                    method: "POST",
                    body: JSON.stringify(w)
                });
                if (_.ok) {
                    const k = await _.json();
                    return {
                        name: v.name,
                        id: k.id,
                        success: !0,
                        action: "created_new"
                    }
                }
                const I = await _.json().catch( () => ({}));
                return {
                    name: v.name,
                    id: 0,
                    success: !1,
                    action: "failed",
                    error: I.message || "Failed to create category"
                }
            } catch (_) {
                return {
                    name: v.name,
                    id: 0,
                    success: !1,
                    action: "failed",
                    error: `Failed to create category: ${_instanceof Error ? _.message : String(_)}`
                }
            }
        }
        async function s(v, S) {
            if (!(v != null && v.length))
                return [];
            const w = await o(S)
              , _ = [];
            for (const I of v) {
                const k = w.find(C => C.name.toLowerCase() === I.name.toLowerCase());
                if (k && k.id)
                    _.push({
                        name: I.name,
                        id: k.id,
                        success: !0,
                        action: "used_existing"
                    });
                else {
                    const C = await n(I, S);
                    _.push(C),
                    C.success && w.push({
                        id: C.id,
                        name: C.name
                    })
                }
            }
            return _
        }
        async function i(v) {
            try {
                const S = await Pt(`${v}${mt}products/attributes`);
                return S.ok ? await S.json() : []
            } catch (S) {
                return console.warn("Failed to fetch existing global attributes:", S),
                []
            }
        }
        async function l(v, S) {
            const w = {
                name: v.name,
                slug: v.slug || v.name.toLowerCase().replace(/\s+/g, "-"),
                type: v.type || "select",
                has_archives: !1
            };
            try {
                const _ = await Pt(`${S}${mt}products/attributes`, {
                    method: "POST",
                    body: JSON.stringify(w)
                });
                if (_.ok) {
                    const k = await _.json();
                    return {
                        name: v.name,
                        id: k.id,
                        success: !0,
                        action: "created_new"
                    }
                }
                const I = await _.json().catch( () => ({}));
                return {
                    name: v.name,
                    id: 0,
                    success: !1,
                    action: "failed",
                    error: I.message || "Failed to create global attribute"
                }
            } catch (_) {
                return {
                    name: v.name,
                    id: 0,
                    success: !1,
                    action: "failed",
                    error: `Failed to create global attribute: ${_instanceof Error ? _.message : String(_)}`
                }
            }
        }
        async function d(v, S) {
            if (!(v != null && v.length))
                return [];
            const w = await i(S)
              , _ = [];
            for (const I of v) {
                const k = w.find(C => C.name.toLowerCase() === I.name.toLowerCase());
                if (k && k.id)
                    _.push({
                        name: I.name,
                        id: k.id,
                        success: !0,
                        action: "used_existing"
                    });
                else {
                    const C = await l(I, S);
                    _.push(C),
                    C.success && w.push({
                        id: C.id,
                        name: C.name
                    })
                }
            }
            return _
        }
        function u(v, S) {
            const w = []
              , _ = new Map;
            for (const I of v) {
                const k = S.find(C => C.name.toLowerCase() === I.name.toLowerCase() && C.success);
                k && I.options && (_.set(I.name.toLowerCase(), k.id),
                w.push({
                    id: k.id,
                    name: I.name,
                    options: I.options,
                    variation: I.variation !== !1,
                    visible: I.visible !== !1
                }))
            }
            return {
                productAttributes: w,
                attributeNameToIdMap: _
            }
        }
        async function g(v, S, w) {
            const _ = w ? "PUT" : "POST"
              , I = w ? `${S}${mt}products/${w}` : `${S}${mt}products`
              , k = await Pt(I, {
                method: _,
                body: JSON.stringify(v)
            });
            if (!k.ok) {
                let C = "";
                try {
                    const L = await k.json();
                    C = L.message || JSON.stringify(L)
                } catch (L) {
                    console.warn("Failed to parse error response as JSON:", L)
                }
                throw new Error(`Error ${w ? "updating" : "creating"} product: Got ${k.status} ${k.statusText} from ${k.url}. Error details: ${C}`)
            }
            return await k.json()
        }
        async function c(v, S, w, _) {
            var L, N, A;
            if (!_) {
                const {root: $} = vr();
                _ = $
            }
            const I = $ => $.map(R => R.id ? {
                id: R.id,
                option: R.option || ""
            } : R.name && w ? {
                id: w.get(R.name.toLowerCase()),
                option: R.option || ""
            } : {
                id: null,
                option: R.option || ""
            })
              , k = {};
            (L = S.create) != null && L.length && (k.create = S.create.map($ => ({
                attributes: I($.attributes),
                regular_price: $.regularPrice,
                sale_price: $.salePrice,
                sku: $.sku,
                weight: $.weight,
                dimensions: $.dimensions,
                stock_quantity: $.stockQuantity,
                manage_stock: $.manageStock,
                description: $.description
            }))),
            (N = S.update) != null && N.length && (k.update = S.update.map($ => ({
                id: $.id,
                attributes: $.attributes ? I($.attributes) : void 0,
                regular_price: $.regularPrice,
                sale_price: $.salePrice,
                sku: $.sku,
                weight: $.weight,
                dimensions: $.dimensions,
                stock_quantity: $.stockQuantity,
                manage_stock: $.manageStock,
                description: $.description
            }))),
            (A = S.delete) != null && A.length && (k.delete = S.delete);
            const C = await Pt(`${_}${mt}products/${v}/variations/batch`, {
                method: "POST",
                body: JSON.stringify(k)
            });
            if (!C.ok) {
                let $ = "";
                try {
                    const R = await C.json();
                    $ = R.message || JSON.stringify(R)
                } catch (R) {
                    console.warn("Failed to parse error response as JSON:", R)
                }
                throw new Error(`Error managing variations: ${$}`)
            }
            return await C.json()
        }
        async function m(v, S, w) {
            return (S === "variable" || v) && (v != null && v.length) ? await d(v.map(_ => ({
                name: _.name
            })), w) : []
        }
        function p(v, S) {
            if (!(v != null && v.length) || !S.length)
                return {
                    productAttributes: [],
                    attributeNameToIdMap: new Map,
                    resultText: ""
                };
            const {productAttributes: w, attributeNameToIdMap: _} = u(v, S)
              , I = `--- Processing Attributes ---
Attributes processed:
"""
${JSON.stringify(S, null, 2)}
"""

`;
            return {
                productAttributes: w,
                attributeNameToIdMap: _,
                resultText: I
            }
        }
        async function h(v, S) {
            return v != null && v.length ? await s(v.filter(w => w.name).map(w => ({
                name: w.name
            })), S) : []
        }
        function f(v, S) {
            if (!(v != null && v.length) || !S.length)
                return {
                    processedCategories: [],
                    resultText: ""
                };
            const w = v.map(I => {
                if (I.id)
                    return {
                        id: I.id
                    };
                if (I.name) {
                    const k = S.find(C => C.name.toLowerCase() === I.name.toLowerCase() && C.success);
                    return k ? {
                        id: k.id
                    } : null
                }
                return null
            }
            ).filter(Boolean)
              , _ = `--- Processing Categories ---
Categories processed: 
"""
${JSON.stringify(S, null, 2)}
"""

`;
            return {
                processedCategories: w,
                resultText: _
            }
        }
        function y(v, S, w) {
            return {
                name: v.name,
                type: v.type || "simple",
                status: v.status || "draft",
                description: v.description,
                short_description: v.short_description,
                sku: v.sku,
                catalog_visibility: v.catalog_visibility,
                featured: v.featured,
                virtual: v.virtual,
                downloadable: v.downloadable,
                categories: w != null && w.length ? w : void 0,
                tags: v.tags,
                low_stock_amount: v.low_stock_amount,
                backorders: v.backorders,
                weight: v.type === "simple" ? v.weight : void 0,
                dimensions: v.type === "simple" ? v.dimensions : void 0,
                regular_price: v.type === "simple" ? v.regular_price : void 0,
                sale_price: v.type === "simple" ? v.sale_price : void 0,
                manage_stock: v.type === "simple" ? v.manage_stock : void 0,
                stock_quantity: v.type === "simple" ? v.stock_quantity : void 0,
                attributes: S != null && S.length ? S : void 0
            }
        }
        async function b(v, S) {
            const w = await g(v, S)
              , _ = `--- Creating Product ---
Product created successfully:
"""
${JSON.stringify(w, null, 2)}
"""

Product ID: ${w.id}
Product Name: ${w.name}
Status: ${w.status}
Permalink: ${w.permalink}

`;
            return {
                createdProduct: w,
                resultText: _
            }
        }
        async function x(v, S, w, _) {
            var k;
            if (!(S != null && S.length))
                return "";
            let I = `--- Creating Variations ---
`;
            try {
                const C = S.map(N => ({
                    ...N,
                    attributes: N.attributes.map(A => ({
                        name: A.name,
                        option: A.option || ""
                    }))
                }))
                  , L = await c(v, {
                    create: C
                }, w, _);
                I += `Variations created successfully:
"""
${JSON.stringify(L, null, 2)}
"""

${((k = L.create) == null ? void 0 : k.length) || 0} variations created.
Variable product setup is now complete!`
            } catch (C) {
                I += `Error creating variations: ${Cinstanceof Error ? C.message : String(C)}`
            }
            return I
        }
        return t.tool("woo-create-product", `This tool creates a new WooCommerce product with specified details and configuration options, including support for variable products with attributes and variations.
Use this when you need to add a new product to the WooCommerce store, whether it's a simple product or a variable product with multiple variations.
The tool automatically handles:
1. Categories - checks existing categories and creates new ones if needed (like attributes)
2. Tags - passes through directly (WooCommerce auto-creates if names are provided)
3. Attributes - checks existing global attributes and creates new ones if needed
4. Variations - creates all variations and assigns them in batch
The tool prevents duplicate categories and attributes by checking existing ones first.`, pb.shape, async ({name: v, type: S, description: w, short_description: _, regular_price: I, sale_price: k, sku: C, status: L, catalog_visibility: N, featured: A, virtual: $, downloadable: R, weight: q, dimensions: ee, categories: ne, tags: te, manage_stock: re, stock_quantity: Q, low_stock_amount: Ie, backorders: Fe, attributes: We, variations: ve}) => {
            try {
                const {root: qe} = vr()
                  , Ke = await m(We, S, qe)
                  , Te = p(We, Ke)
                  , Ve = await h(ne, qe)
                  , rt = f(ne, Ve)
                  , Ge = y({
                    name: v,
                    type: S,
                    status: L,
                    description: w,
                    short_description: _,
                    sku: C,
                    catalog_visibility: N,
                    featured: A,
                    virtual: $,
                    downloadable: R,
                    tags: te,
                    low_stock_amount: Ie,
                    backorders: Fe,
                    weight: q,
                    dimensions: ee,
                    regular_price: I,
                    sale_price: k,
                    manage_stock: re,
                    stock_quantity: Q
                }, Te.productAttributes, rt.processedCategories)
                  , {createdProduct: Ce, resultText: Ut} = await b(Ge, qe)
                  , Qe = await x(Ce.id, ve, Te.attributeNameToIdMap, qe);
                return {
                    content: [{
                        type: "text",
                        text: Te.resultText + rt.resultText + Ut + Qe
                    }]
                }
            } catch (qe) {
                return console.error("Error in woo-create-product:", qe),
                {
                    isError: !0,
                    content: [{
                        type: "text",
                        text: `Error creating product: ${qeinstanceof Error ? qe.message : String(qe)}`
                    }]
                }
            }
        }
        ),
        t
    }
      , gb = /^[v^~<>=]*?(\d+)(?:\.([x*]|\d+)(?:\.([x*]|\d+)(?:\.([x*]|\d+))?(?:-([\da-z\-]+(?:\.[\da-z\-]+)*))?(?:\+[\da-z\-]+(?:\.[\da-z\-]+)*)?)?)?$/i
      , zd = t => {
        if (typeof t != "string")
            throw new TypeError("Invalid argument expected string");
        const e = t.match(gb);
        if (!e)
            throw new Error(`Invalid argument not valid semver ('${t}' received)`);
        return e.shift(),
        e
    }
      , Zd = t => t === "*" || t === "x" || t === "X"
      , Hd = t => {
        const e = parseInt(t, 10);
        return isNaN(e) ? t : e
    }
      , fb = (t, e) => typeof t != typeof e ? [String(t), String(e)] : [t, e]
      , yb = (t, e) => {
        if (Zd(t) || Zd(e))
            return 0;
        const [r,o] = fb(Hd(t), Hd(e));
        return r > o ? 1 : r < o ? -1 : 0
    }
      , Vd = (t, e) => {
        for (let r = 0; r < Math.max(t.length, e.length); r++) {
            const o = yb(t[r] || "0", e[r] || "0");
            if (o !== 0)
                return o
        }
        return 0
    }
      , vb = (t, e) => {
        const r = zd(t)
          , o = zd(e)
          , n = r.pop()
          , s = o.pop()
          , i = Vd(r, o);
        return i !== 0 ? i : n && s ? Vd(n.split("."), s.split(".")) : n || s ? n ? -1 : 1 : 0
    }
      , wb = (t, e, r) => {
        bb(r);
        const o = vb(t, e);
        return Jd[r].includes(o)
    }
      , Jd = {
        ">": [1],
        ">=": [0, 1],
        "=": [0],
        "<=": [-1, 0],
        "<": [-1],
        "!=": [-1, 1]
    }
      , Yd = Object.keys(Jd)
      , bb = t => {
        if (typeof t != "string")
            throw new TypeError(`Invalid operator type, expected string but got ${typeof t}`);
        if (Yd.indexOf(t) === -1)
            throw new Error(`Invalid operator, expected one of ${Yd.join("|")}`)
    }
      , ai = "3.32.0"
      , Sb = async t => {
        var o, n;
        const e = (n = (o = window.angieConfig) == null ? void 0 : o.plugins) == null ? void 0 : n.elementor_pro;
        let r = !1;
        if (e != null && e.version)
            try {
                r = wb(e.version, t, ">=")
            } catch {
                r = !1
            }
        return {
            isInstalled: (e == null ? void 0 : e.isInstalled) ?? !1,
            isActive: (e == null ? void 0 : e.isActive) ?? !1,
            version: (e == null ? void 0 : e.version) ?? null,
            isVersionSupported: r
        }
    }
      , Eb = t => ({
        head: "elementor_head",
        "body-start": "elementor_body_start",
        "body-end": "elementor_body_end"
    })[t] || "elementor_body_end"
      , xb = t => {
        const r = !!document.querySelector(".CodeMirror")
          , o = new URLSearchParams(window.location.search)
          , n = t || o.get("post")
          , s = !!n && o.get("action") === "edit";
        return {
            isOnEditScreen: r,
            currentPostId: n,
            isEditExistingCode: s
        }
    }
      , _b = () => {
        var e, r;
        const t = document.querySelector(".CodeMirror");
        return ((r = (e = t == null ? void 0 : t.CodeMirror) == null ? void 0 : e.getValue) == null ? void 0 : r.call(e)) || ""
    }
      , Tb = (t, e) => {
        const r = new URL(t);
        return `${`${r.protocol}//${r.host}`}/wp-admin/post.php?post=${e}&action=edit`
    }
      , Pb = async ({title: t, location: e, priority: r, code: o}, n) => {
        const s = n.isEditExistingCode ? `/wp/v2/elementor_snippet/${n.currentPostId}` : "/wp/v2/elementor_snippet"
          , i = n.isEditExistingCode ? "PUT" : "POST"
          , d = await U(s, i, {
            title: t,
            status: "draft",
            meta: {
                _elementor_location: e,
                _elementor_priority: r,
                _elementor_code: o
            }
        });
        return console.log("[Elementor Pro Server] REST API save successful:", d),
        {
            success: !0,
            id: d.id,
            status: d.status,
            method: n.isEditExistingCode ? "update" : "create",
            link: d.link
        }
    }
      , kb = ({title: t, location: e, priority: r, code: o}) => {
        var n;
        try {
            const s = document.querySelector('input[name="post_title"]');
            s && (s.value = t,
            s.dispatchEvent(new Event("input",{
                bubbles: !0
            })));
            const i = document.querySelector('select[name="location"]');
            i && (i.value = e,
            i.dispatchEvent(new Event("change",{
                bubbles: !0
            })));
            const l = document.querySelector('select[name="priority"]');
            l && (l.value = r.toString(),
            l.dispatchEvent(new Event("change",{
                bubbles: !0
            })));
            const d = document.querySelector(".CodeMirror");
            return (n = d == null ? void 0 : d.CodeMirror) != null && n.setValue && d.CodeMirror.setValue(o),
            "success"
        } catch (s) {
            return console.error("[Elementor Pro Server] UI injection failed:", s),
            "failed"
        }
    }
    ;
    function Ib() {
        const t = new He({
            name: "elementor-pro-server",
            version: "1.0.0"
        },{
            capabilities: {
                resources: {
                    subscribe: !0
                }
            }
        });
        return t.tool("generate-custom-code", 'This tool creates and updates site-wide custom code snippets for Elementor Pro sites that can be injected into different sections of the webpage. Use this when you need to add tracking codes (Google Analytics, Facebook Pixel), embed widgets (Spotify, YouTube), implement custom functionality with JavaScript, or apply global styling with CSS. The tool supports HTML, JavaScript, and CSS code snippets and allows precise control over where the code is placed (head, body start, or body end) with priority management. It can also update existing snippets when a postId is provided or when the conversation context indicates updating an existing custom code snippet (e.g., "update the title", "change the priority", "modify the code"). The tool will generate/update the code and fill the form if you are on the custom code edit screen, or provide manual instructions otherwise.', {
            title: a.string().describe('A descriptive name for this code snippet that helps identify its purpose later (e.g., "Google Analytics Tracking", "Facebook Pixel", "Custom Button Styling")'),
            location: a.enum(["head", "body-start", "body-end"]).describe('Where to inject the code: "head" for <head> section (best for meta tags, CSS, analytics), "body-start" for beginning of <body> (early loading scripts), "body-end" for end of <body> (most JavaScript, tracking pixels)'),
            priority: a.number().min(1).max(10).optional().default(1).describe("Execution priority when multiple scripts target the same location (1 = highest priority, 10 = lowest priority). Lower numbers run first"),
            prompt: a.string().describe("A prompt to generate the code snippet. Include explanation for the feature and specify that this is a custom code snippet that will be injected into the website at the specified location (head, body-start, or body-end), explain it should include the html tags and the code should be in the correct language. if code so inside <script> tags etc, prompt should always be textual and not a code snippet"),
            language: a.string().describe("The language of the code snippet"),
            postId: a.string().optional().describe('The ID of the custom code snippet to update. Use this when updating an existing snippet (e.g., when user says "update the title", "change the priority", "modify the code", etc.). If provided, the existing snippet will be updated. If not provided or when creating new functionality, a new snippet will be created. This should be used when the conversation context indicates working with an existing custom code snippet.')
        }, async ({title: e, location: r, priority: o=1, prompt: n, language: s, postId: i}) => {
            const l = await Sb(ai);
            if (!l.isInstalled)
                throw new Error(`Elementor Pro is not installed. Please install Elementor Pro version ${ai} or higher to use the Custom Code feature. You can download it from https://elementor.com/pro/`);
            if (!l.isActive)
                throw new Error("Elementor Pro is installed but not activated. Only inform the user that activation is required to use the Custom Code feature. and ask if the user wants you to activate it. Don't do it without asking.");
            if (!l.isVersionSupported) {
                const h = l.version || "unknown";
                throw new Error(`Elementor Pro version ${h} is not supported. Please upgrade to version ${ai} or higher to use the Custom Code feature. You can update via WordPress Admin > Plugins > Update or download the latest version from https://elementor.com/pro/`)
            }
            const d = _b()
              , g = (await t.server.request({
                method: "sampling/createMessage",
                params: {
                    messages: [{
                        role: "user",
                        content: {
                            type: "text",
                            text: n
                        }
                    }],
                    maxTokens: 1e3,
                    modelPreferences: {
                        hints: [{
                            name: "elementor-code-generation"
                        }]
                    },
                    metadata: {
                        language: s,
                        codeContext: {
                            existingCode: d,
                            parsedResponse: !0
                        }
                    }
                }
            }, Pr)).content.text
              , c = xb(i)
              , m = Eb(r)
              , p = {
                title: e,
                location: m,
                priority: o,
                code: g
            };
            try {
                const h = await Pb(p, c);
                let f = null;
                c.isOnEditScreen && (console.log("[Elementor Pro Server] Injecting into UI for immediate feedback"),
                f = kb(p));
                const y = Tb(h.link, h.id)
                  , b = {
                    success: !0,
                    code: g,
                    method: h.method,
                    postId: h.id,
                    postStatus: h.status,
                    location: r,
                    priority: o,
                    title: e,
                    ...c.isOnEditScreen ? {} : {
                        edit_url: y
                    }
                };
                return c.isOnEditScreen ? {
                    content: [{
                        type: "text",
                        text: JSON.stringify({
                            ...b,
                            message: "**Code Created & Ready to Edit!** I've inserted the code directly into your editor. **YOU CAN EDIT IT RIGHT NOW** - modify the code, adjust settings, and customize everything before publishing.",
                            ui_injection: f,
                            instructions: ["**EDIT THE CODE NOW:** The code is in your editor - click in the code area and modify it however you want", "**CHANGE ANYTHING:** You can edit the HTML/CSS/JavaScript, modify the title, adjust location/priority", '**SET DISPLAY CONDITIONS:** By default shows cross-site (entire website) - click "Conditions" tab to choose specific pages/sections', "**DRAFT STATUS:** This is a DRAFT and NOT LIVE yet - you must publish it to activate", '**TO MAKE IT LIVE:** After editing, click "Update" or "Publish" to activate the code on your site', ""],
                            status_note: "DRAFT - Not yet active on your site",
                            conditions_note: "Default: Will display cross-site when published"
                        }, null, 2)
                    }]
                } : {
                    content: [{
                        type: "text",
                        text: JSON.stringify({
                            ...b,
                            message: `**Code Created & Ready to Edit!** I've created "${e}" as a draft. **YOU CAN EDIT EVERYTHING** - the code, conditions, settings, etc. 
									**[Click here to EDIT your code ](${y})**`,
                            edit_link: y,
                            instructions: ["**EDIT YOUR CODE:**", "**[Click here to EDIT your code ](" + y + ")**", "", "**YOU CAN EDIT EVERYTHING:**", " **Code Content:** Modify the HTML/CSS/JavaScript however you want", " **Display Conditions:** Choose specific pages/sections (default: cross-site)", " **Settings:** Change title, location (head/body), priority", " **Targeting:** Set where and when the code should run", "", "**IMPORTANT - DRAFT STATUS:**", " This is a DRAFT and NOT LIVE on your site yet", " You MUST PUBLISH it after editing to make it active", "", "**TO EDIT & ACTIVATE:**", "1. Click the edit link above OR go to Elementor  Custom Code", '2. Find "' + e + '" and click to open it', "3. **EDIT THE CODE** - change anything you want in the code editor", "4. **SET CONDITIONS** - choose which pages it appears on (Conditions tab)", "5. **PUBLISH** to make it live on your site", ""],
                            status_note: "DRAFT - Not yet active on your site",
                            conditions_note: "Default: Will display on all pages when published"
                        }, null, 2)
                    }]
                }
            } catch (h) {
                return console.warn("[Elementor Pro Server] REST API operation failed:", h),
                {
                    content: [{
                        type: "text",
                        text: JSON.stringify({
                            success: !0,
                            message: c.isOnEditScreen ? "I've generated the code but couldn't save it automatically. Don't worry - you can copy it and add it directly in your editor." : "I've generated the code but couldn't create the draft automatically. I'll guide you through adding it manually.",
                            code: g,
                            method: "manual_fallback",
                            rest_error: h instanceof Error ? h.message : String(h),
                            instructions: c.isEditExistingCode ? ["**To Update the Code:**", "1. Copy the code below", "2. Paste it into your current code editor", "3. Adjust the title, location, and priority if needed", '4. Review the "Conditions" tab to set where it displays (default: cross-site)', '5. Click "Update" to save your changes', "", "**Remember:** After updating, the code will remain as a draft until you publish it."] : ["**To Add the Code Manually:**", "1. Open Elementor  Custom Code in your WordPress admin", '2. Click "Add New"', "3. Set these details:", "    Title: " + e, "    Location: " + r + " (where in the HTML to place the code)", "    Priority: " + o + " (execution order)", "4. Paste the code below into the editor", '5. Review "Conditions" tab (default: displays cross-site)', '6. Click "Save Draft" first, then "Publish" to activate', "", "**Display Conditions:** By default, code will show cross-site when published.", "**Draft Status:** Code won't be active until you publish it."],
                            location: r,
                            priority: o,
                            title: e,
                            status_note: "DRAFT - Remember to publish to activate",
                            conditions_note: "Default: Will display on all pages when published"
                        }, null, 2)
                    }]
                }
            }
        }
        ),
        t
    }
    async function Cb(t, e) {
        const r = await U("/angie/v1/elementor-kit/fonts", "GET")
          , o = Object.keys(r.fonts || {})
          , n = [];
        return [t, e].forEach(s => {
            s && s.forEach(i => {
                i.typography_font_family && !o.includes(i.typography_font_family) && n.push(i.typography_font_family)
            }
            )
        }
        ),
        n.length > 0 ? `Please use available fonts only. Invalid fonts: ${n.join(", ")}. Available fonts: ${o.join(", ")}` : ""
    }
    const Kd = a.object({
        title: a.string(),
        color: a.string()
    })
      , Qd = a.object({
        title: a.string(),
        typography_typography: a.string(),
        typography_font_family: a.string().describe("Font family name that must be from the available Elementor fonts list. Use the get-fonts endpoint (/angie/v1/elementor-kit/fonts) to get the complete list of available fonts. Only use fonts that exist in this list to avoid validation errors."),
        typography_font_weight: a.string(),
        typography_font_size: a.object({
            unit: a.string(),
            size: a.number()
        }).optional(),
        typography_font_size_tablet: a.object({
            unit: a.string(),
            size: a.number()
        }).optional(),
        typography_font_size_mobile: a.object({
            unit: a.string(),
            size: a.number()
        }).optional(),
        typography_line_height: a.object({
            unit: a.string(),
            size: a.number()
        }).optional()
    }).passthrough()
      , $b = Kd.extend({
        _id: a.enum(["primary", "secondary", "text", "accent"])
    })
      , Ab = Qd.extend({
        _id: a.enum(["primary", "secondary", "text", "accent"])
    })
      , Rb = Kd.extend({
        _id: a.string()
    })
      , Ob = Qd.extend({
        _id: a.string()
    })
      , Db = a.array($b).length(4)
      , Nb = a.array(Ab).length(4)
      , Lb = a.array(Rb)
      , Ub = a.array(Ob)
      , jb = a.record(a.unknown()).describe("General patch object for any other Elementor kit settings like spacing, buttons, forms, layout settings, etc.");
    async function Mb() {
        const t = new He({
            name: "elementor-kit-server",
            version: "1.0.0"
        },{
            capabilities: {
                resources: {
                    subscribe: !0
                }
            }
        })
          , e = async () => {
            const r = await U("/angie/v1/elementor-kit/schema", "GET");
            return Object.keys(r)
        }
        ;
        t.tool("update-elementor-kit-settings-colors-and-fonts", "This tool applies configuration changes to Elementor global kit settings that control site-wide design elements. Use this when you need to modify global colors, typography, spacing, buttons, form fields, or other theme-wide settings that affect the entire website appearance. This tool requires calling get-elementor-settings-schema first to understand the current structure and available options. The tool will permanently update the site's global design settings and return a success confirmation with the updated configuration data.", {
            systemColors: Db.optional().nullable().describe("System colors array with exactly 4 items having IDs: primary, secondary, text, accent"),
            systemTypography: Nb.optional().nullable().describe("System typography array with exactly 4 items having IDs: primary, secondary, text, accent"),
            customColors: Lb.optional().nullable().describe("Custom colors array - flexible structure for additional color definitions"),
            customTypography: Ub.optional().nullable().describe("Custom typography array - flexible structure for additional font definitions (no color field needed)"),
            patchObject: jb.optional().nullable().describe("General patch object for any other Elementor kit settings like spacing, buttons, forms, layout settings, etc."),
            wasGetElementorSettingsSchemaToolCalled: a.boolean().describe("Whether the tool was called from get-elementor-settings-schema tool")
        }, async ({systemColors: r, systemTypography: o, customColors: n, customTypography: s, patchObject: i, wasGetElementorSettingsSchemaToolCalled: l}) => {
            try {
                if (!l)
                    throw new Error("You cannot call this tool without calling get-elementor-settings-schema first. Try again to call get-elementor-settings-schema first.");
                const d = await Cb(o, s);
                if (d)
                    throw new Error(d);
                const u = {
                    ...r && {
                        system_colors: r
                    },
                    ...o && {
                        system_typography: o
                    },
                    ...n && {
                        custom_colors: n
                    },
                    ...s && {
                        custom_typography: s
                    },
                    ...i || {}
                };
                if (Object.keys(u).length === 0)
                    throw new Error("At least one update must be provided (systemColors, systemTypography, customColors, customTypography, or patchObject)");
                const g = await U("/angie/v1/elementor-kit", "POST", u);
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify({
                            success: !0,
                            message: "Settings updated successfully",
                            data: g,
                            appliedSettings: u
                        }, null, 2)
                    }]
                }
            } catch (d) {
                throw console.error("[Elementor Kit MCP] Error updating settings:", d),
                d
            }
        }
        );
        try {
            const r = await e();
            t.tool("get-elementor-settings-schema", "Get the schema for a specific Elementor settings tab and the current settings", {
                settingsTab: a.enum(r).describe("Settings tab to get schema for - includes global colors/typography and theme style sections")
            }, async ({settingsTab: o}) => {
                try {
                    const n = await U("/angie/v1/elementor-kit/schema", "GET")
                      , s = await U("/angie/v1/elementor-kit", "GET")
                      , i = n[o];
                    if (!i) {
                        const l = Object.keys(n);
                        throw new Error(`No schema found for settings tab '${o}'. Available tabs: ${l.join(", ")}`)
                    }
                    return {
                        content: [{
                            type: "text",
                            text: JSON.stringify({
                                tabSchema: i,
                                currentSettings: s
                            }, null, 2)
                        }]
                    }
                } catch (n) {
                    throw console.error("[Elementor Kit MCP] Error getting settings schema:", n),
                    n
                }
            }
            )
        } catch (r) {
            console.error("[Elementor Kit MCP] Failed to initialize dynamic enum:", r)
        }
        return t
    }
    function Xd(t) {
        const e = t.replace(/\D/g, "");
        if (e.length === 8 && /^(19|20)\d{6}$/.test(e))
            return e;
        if (t.match(/^\d{4}-\d{2}-\d{2}$/))
            return t.replace(/-/g, "");
        const r = t.match(/^(\d{1,2})[\/\-.](\d{1,2})[\/\-.](\d{4})$/);
        if (r) {
            const [,o,n,s] = r
              , i = o.padStart(2, "0")
              , l = n.padStart(2, "0");
            return `${s}${l}${i}`
        }
        return e.length >= 8 ? e.substring(0, 8) : (console.error("[Meta Tools] Unable to convert date to hidden format:", t),
        t)
    }
    function Fb(t, e) {
        const r = Xd(t);
        if (r.length !== 8)
            return t;
        const o = r.substring(0, 4)
          , n = r.substring(4, 6)
          , s = r.substring(6, 8);
        let i;
        switch (e.toLowerCase()) {
        case "dd/mm/yy":
        case "dd/mm/yyyy":
            i = `${s}/${n}/${o}`;
            break;
        case "mm/dd/yy":
        case "mm/dd/yyyy":
            i = `${n}/${s}/${o}`;
            break;
        case "yyyy-mm-dd":
            i = `${o}-${n}-${s}`;
            break;
        case "dd-mm-yyyy":
            i = `${s}-${n}-${o}`;
            break;
        case "mm-dd-yyyy":
            i = `${n}-${s}-${o}`;
            break;
        default:
            i = `${s}/${n}/${o}`
        }
        return i
    }
    function ii(t) {
        t.forEach(e => ["input", "change", "blur"].forEach(r => e.dispatchEvent(new Event(r,{
            bubbles: !0
        }))))
    }
    function li(t, e) {
        var o;
        const r = t.replace(/_/g, "-").replace(/-/g, "_");
        return document.querySelector(`[data-key="${t}"]`) || document.querySelector(`[data-key="${r}"]`) || e && document.querySelector(`[data-name="${e}"]`) || e && ((o = document.querySelector(`input[name="acf[${e}]"]`)) == null ? void 0 : o.closest(".acf-field")) || null
    }
    function eu(t, e) {
        return t.getAttribute("data-type") || "" || e || "text"
    }
    function tu(t) {
        return t === "radio" ? 'input[type="radio"]' : t === "checkbox" ? 'input[type="checkbox"]' : "input, textarea, select"
    }
    function Wb(t, e, r) {
        var s;
        const o = t.querySelector('input[type="hidden"]')
          , n = t.querySelector('input[type="text"]');
        if (!o || !n)
            return !1;
        if (e === "date_picker") {
            const i = ((s = t.querySelector(".acf-date-picker")) == null ? void 0 : s.getAttribute("data-date_format")) || "dd/mm/yy";
            o.value = Xd(r),
            n.value = Fb(r, i)
        } else
            o.value = r,
            n.value = r;
        return ii([o, n]),
        !0
    }
    function qb(t, e) {
        const r = t.querySelectorAll('input[type="radio"]')
          , o = String(e);
        let n = !1;
        return r.forEach(s => {
            s.value === o ? (s.checked = !0,
            s.dispatchEvent(new Event("change",{
                bubbles: !0
            })),
            n = !0) : s.checked = !1
        }
        ),
        n
    }
    function Gb(t, e, r) {
        const o = t.querySelectorAll('input[type="checkbox"]');
        if (o.length > 1) {
            const n = Array.from(o).find(s => s.value === String(r));
            return n ? (n.checked = typeof r == "boolean" ? r : !0,
            n.dispatchEvent(new Event("change",{
                bubbles: !0
            })),
            !0) : !1
        }
        return e.checked = !!r,
        e.dispatchEvent(new Event("change",{
            bubbles: !0
        })),
        !0
    }
    function Bb(t, e) {
        const r = String(e);
        if (t.value = r,
        t.value !== r) {
            const o = Array.from(t.options).find(n => {
                var s;
                return n.value === r || ((s = n.textContent) == null ? void 0 : s.trim()) === r
            }
            );
            if (o)
                t.selectedIndex = o.index;
            else
                return !1
        }
        return ii([t]),
        !0
    }
    function zb(t, e) {
        return t.value = String(e),
        ii([t]),
        !0
    }
    function Zb(t, e) {
        const r = tu(e)
          , o = t.querySelector(r);
        if (!o)
            return {
                value: ""
            };
        if (e === "radio") {
            const n = t.querySelectorAll('input[type="radio"]')
              , s = Array.from(n).map(l => l.value)
              , i = Array.from(n).find(l => l.checked);
            return {
                value: (i == null ? void 0 : i.value) || "",
                options: s
            }
        }
        if (e === "checkbox") {
            const n = t.querySelectorAll('input[type="checkbox"]');
            if (n.length > 1) {
                const i = Array.from(n).map(d => d.value);
                return {
                    value: Array.from(n).filter(d => d.checked).map(d => d.value),
                    options: i
                }
            }
            return {
                value: n[0].checked
            }
        }
        if (e === "select" || o.tagName.toLowerCase() === "select") {
            const n = o
              , s = Array.from(n.options).map(i => i.value);
            return {
                value: n.value,
                options: s
            }
        }
        if (e === "date_picker" || e === "time_picker") {
            const n = t.querySelector('input[type="text"]');
            return {
                value: n ? n.value : o.value
            }
        }
        return {
            value: o.value
        }
    }
    function Hb(t, e) {
        const r = e === "checkbox" || t.type === "checkbox"
          , o = t.tagName.toLowerCase() === "select";
        return r ? t.checked : t.value
    }
    function Vb() {
        const t = document.querySelector('#save-post, .editor-post-save-draft, input[name="save"]');
        return t ? t.disabled ? {
            saved: !1,
            reason: "button disabled"
        } : (t.click(),
        {
            saved: !0
        }) : {
            saved: !1,
            reason: "button not found"
        }
    }
    function Jb(t) {
        const {fieldKey: e, fieldName: r, value: o, fieldType: n} = t;
        try {
            const s = li(e, r);
            if (!s)
                throw new Error(`Field not found: ${e}`);
            const i = eu(s, n)
              , l = tu(i)
              , d = s.querySelector(l);
            if (!d)
                throw new Error(`Input not found: ${e}`);
            const u = d.value
              , g = i === "date_picker" || i === "time_picker"
              , c = i === "radio" || d.type === "radio"
              , m = i === "checkbox" || d.type === "checkbox"
              , p = i === "select" || d.tagName.toLowerCase() === "select";
            let h = !1;
            if (g ? h = Wb(s, i, String(o)) : c ? h = qb(s, o) : m ? h = Gb(s, d, o) : p ? h = Bb(d, o) : h = zb(d, o),
            !h)
                throw new Error(`Failed to update field: ${e}`);
            const f = Hb(d, i);
            return {
                success: !0,
                fieldKey: e,
                originalValue: u,
                newValue: f
            }
        } catch (s) {
            return {
                success: !1,
                fieldKey: e,
                error: s.message
            }
        }
    }
    function Yb(t) {
        t.tool("discover-meta-fields", "Discovers available ACF meta fields on the current WordPress admin page with their current values", {}, async () => {
            console.log("[Meta Tools] discover-meta-fields");
            const e = document.querySelectorAll(".acf-field")
              , r = Array.from(e).map(o => {
                var n, s;
                try {
                    const i = eu(o)
                      , l = o.getAttribute("data-key") || ""
                      , d = o.getAttribute("data-name") || ""
                      , u = ((s = (n = o.querySelector(".acf-label label")) == null ? void 0 : n.textContent) == null ? void 0 : s.trim()) || ""
                      , {value: g, options: c} = Zb(o, i);
                    return {
                        key: l,
                        name: d,
                        type: i,
                        label: u,
                        value: g,
                        ...c && {
                            options: c
                        }
                    }
                } catch (i) {
                    return console.warn("[Meta Tools] Error processing field:", i),
                    null
                }
            }
            ).filter(Boolean);
            return console.log("[Meta Tools] fields", r),
            {
                content: [{
                    type: "text",
                    text: JSON.stringify({
                        fields: r,
                        totalFound: r.length
                    }, null, 2)
                }]
            }
        }
        ),
        t.tool("update-meta-field-values", "Updates ACF meta field values on the current WordPress admin page, must be used with discover-meta-fields tool to get the field key and name", {
            alreadyDiscoveredFields: a.boolean().describe("mark if alredy familiar with the fields, if false, you can run discover-meta-fields tool to get the fields config"),
            fieldUpdates: a.array(a.object({
                key: a.string().describe("field key from discover-meta-fields tool"),
                name: a.string(),
                value: a.union([a.string(), a.number(), a.boolean(), a.array(a.string())]),
                type: a.string().optional()
            })).min(1).describe("note: when you update date or time fields, try to update also the end date or time if are exist, and vice versa"),
            triggerSave: a.boolean().optional().describe("trigger save button click")
        }, async ({fieldUpdates: e, triggerSave: r=!1, alreadyDiscoveredFields: o=!1}) => {
            if (console.log("[Meta Tools] update-meta-field-values", {
                fieldUpdates: e.map(g => ({
                    key: g.key,
                    name: g.name,
                    value: g.value,
                    type: g.type
                })),
                triggerSave: r,
                updateCount: e.length
            }),
            !o)
                return console.log("[Meta Tools] update-meta-field-values alreadyDiscoveredFields is false"),
                {
                    content: [{
                        type: "text",
                        isError: !0,
                        text: "The tool is working, as an LLM - please run discover-meta-fields tool to get the field key and name"
                    }]
                };
            const n = e.map(g => {
                let c = g.type === "checkbox";
                if (Array.isArray(g.value) && !c) {
                    const m = li(g.key, g.name);
                    m && (c = m.querySelectorAll('input[type="checkbox"]').length > 1)
                }
                if (Array.isArray(g.value) && c) {
                    const m = g.key
                      , p = g.name
                      , h = li(m, p);
                    if (h) {
                        const f = h.querySelectorAll('input[type="checkbox"]');
                        return f.forEach(y => {
                            y.checked = !1,
                            y.dispatchEvent(new Event("change",{
                                bubbles: !0
                            }))
                        }
                        ),
                        g.value.forEach(y => {
                            const b = Array.from(f).find(x => x.value === y);
                            b && (b.checked = !0,
                            b.dispatchEvent(new Event("change",{
                                bubbles: !0
                            })))
                        }
                        ),
                        {
                            success: !0,
                            fieldKey: m,
                            originalValue: [],
                            newValue: g.value
                        }
                    }
                    return {
                        success: !1,
                        fieldKey: m,
                        error: `Field not found: ${m}`
                    }
                }
                return Jb({
                    fieldKey: g.key,
                    fieldName: g.name,
                    value: g.value,
                    fieldType: g.type
                })
            }
            );
            let s = null;
            r && (s = Vb());
            const i = n.filter(g => g.success).length
              , l = n.length - i
              , u = {
                success: n.every(g => g.success),
                summary: {
                    successful: i,
                    failed: l,
                    saveResult: s
                },
                results: n
            };
            return {
                content: [{
                    type: "text",
                    text: JSON.stringify(u, null, 2)
                }]
            }
        }
        )
    }
    function Kb(t) {
        t.tool("create-gallery-block", "This tool creates empty WordPress gallery blocks that can be populated with images later. Use this when you need to create the foundation for photo galleries, image showcases, or any multi-image display within Gutenberg. It supports various configuration options including column layouts, image cropping, linking behavior, and size preferences. The tool will create a new empty gallery block with specified settings and insert it at the desired position. After creation, use the add-images-to-gallery tool to populate it with images.", {
            configuration: a.object({
                columns: a.number().optional().default(3).describe("Number of columns to display images in (1-8)"),
                imageCrop: a.boolean().optional().default(!0).describe("Whether to crop images to maintain consistent aspect ratios"),
                linkTo: a.enum(["none", "media", "attachment"]).optional().default("none").describe("Linking behavior: none (no links), media (link to image file), attachment (link to attachment page)"),
                sizeSlug: a.enum(["thumbnail", "medium", "large", "full"]).optional().default("large").describe("Image size to use for display"),
                allowResize: a.boolean().optional().default(!0).describe("Whether users can resize images within the gallery"),
                caption: a.string().optional().describe("Overall caption text for the entire gallery")
            }).optional().describe("Gallery display and behavior configuration options"),
            position: a.object({
                index: a.number().optional().describe("Insertion position within the parent container (0-based)"),
                parentClientId: a.string().optional().describe('Parent block client ID if creating gallery within another block (e.g., "f521ca0d-ab62-4187-82b3-3c04d44a4327"). This is a UUID-style string identifier for the parent block')
            }).optional().describe("Position specifications for where to place the gallery block")
        }, async ({configuration: e={}, position: r={}}) => {
            const o = window.wp.data.dispatch("core/block-editor")
              , n = window.wp.blocks
              , {columns: s=3, imageCrop: i=!0, linkTo: l="none", sizeSlug: d="large", allowResize: u=!0, caption: g=""} = e
              , c = {
                columns: s,
                imageCrop: i,
                linkTo: l,
                sizeSlug: d,
                allowResize: u,
                caption: g
            }
              , m = n.createBlock("core/gallery", c, [])
              , {index: p, parentClientId: h=""} = r;
            return o.insertBlock(m, p, h),
            {
                content: [{
                    type: "text",
                    text: JSON.stringify({
                        success: !0,
                        message: "Successfully created empty gallery block",
                        blockId: m.clientId
                    }, null, 2)
                }]
            }
        }
        ),
        t.tool("update-gallery-block-configuration", "This tool updates configuration settings for existing WordPress gallery blocks including column layouts, image cropping, linking behavior, and size preferences. Use this when you need to modify display settings of existing galleries without changing the images. For adding or removing images, use the dedicated add-images-to-gallery or remove-images-from-gallery tools instead.", {
            galleryClientId: a.string().describe('The Gutenberg block client ID of the gallery block to update (e.g., "f521ca0d-ab62-4187-82b3-3c04d44a4327"). Obtained from the user context data'),
            configuration: a.object({
                columns: a.number().optional().describe("Number of columns to display images in (1-8)"),
                imageCrop: a.boolean().optional().describe("Whether to crop images to maintain consistent aspect ratios"),
                linkTo: a.enum(["none", "media", "attachment"]).optional().describe("Linking behavior: none (no links), media (link to image file), attachment (link to attachment page)"),
                sizeSlug: a.enum(["thumbnail", "medium", "large", "full"]).optional().describe("Image size to use for display"),
                allowResize: a.boolean().optional().describe("Whether users can resize images within the gallery"),
                caption: a.string().optional().describe("Overall caption text for the entire gallery")
            }).describe("Gallery configuration options to update. Only specified options will be changed")
        }, async ({galleryClientId: e, configuration: r}) => (window.wp.data.dispatch("core/block-editor").updateBlockAttributes(e, r),
        {
            content: [{
                type: "text",
                text: JSON.stringify({
                    success: !0,
                    message: "Successfully updated gallery block configuration",
                    blockId: e,
                    updatedAttributes: Object.keys(r)
                }, null, 2)
            }]
        })),
        t.tool("add-images-to-gallery", "This tool adds new images to an existing WordPress gallery block from image URLs without affecting the current images. MCP server handles upload automatically. Use this when you need to expand a gallery by adding more images while preserving the existing collection. It's particularly useful for incremental gallery building or when users want to add specific images to an established gallery. The tool will upload the images to WordPress media library and append them to the current gallery.", {
            galleryClientId: a.string().describe('The Gutenberg block client ID of the gallery block to add images to (e.g., "f521ca0d-ab62-4187-82b3-3c04d44a4327"). Obtained from the user context data'),
            newImages: a.array(a.object({
                imageUrl: a.string().url().describe("URL of the image to add to gallery. Can be any public image URL - MCP server will handle upload to WordPress media library."),
                filename: a.string().optional().describe("Custom filename for the uploaded image (defaults to extracted from URL)"),
                alt: a.string().optional().describe("Alternative text for accessibility"),
                caption: a.string().optional().describe("Caption text to display with the image"),
                title: a.string().optional().describe("Title for the media library entry (defaults to filename)"),
                link: a.string().optional().describe("URL to link to when the image is clicked")
            })).describe("Array of new images to add to the gallery")
        }, async ({galleryClientId: e, newImages: r}) => {
            const o = window.wp.data.dispatch("core/block-editor")
              , n = window.wp.blocks
              , s = [];
            for (const l of r)
                try {
                    console.log("[Gutenberg Gallery] Uploading image to media library:", l.imageUrl);
                    const d = await Rr({
                        imageUrl: l.imageUrl,
                        filename: l.filename || "gallery-image.jpg",
                        title: l.title || "Gallery Image",
                        altText: l.alt || "Gallery Image"
                    });
                    console.log("[Gutenberg Gallery] Image uploaded with ID:", d.id),
                    s.push({
                        mediaId: d.id,
                        url: d.url,
                        alt: d.altText,
                        caption: l.caption || "",
                        link: l.link
                    })
                } catch (d) {
                    console.error("[Gutenberg Gallery] Error uploading image:", d)
                }
            if (s.length === 0)
                throw new Error("No images were successfully uploaded");
            const i = s.map(l => {
                const d = {
                    id: l.mediaId,
                    url: l.url,
                    alt: l.alt,
                    caption: l.caption
                };
                return l.link && (d.linkDestination = "custom",
                d.href = l.link),
                n.createBlock("core/image", d)
            }
            );
            return o.insertBlocks(i, void 0, e),
            {
                content: [{
                    type: "text",
                    text: JSON.stringify({
                        success: !0,
                        message: `Successfully uploaded and added ${s.length} images to gallery`,
                        blockId: e,
                        addedImages: s.length,
                        requestedImages: r.length,
                        uploadedMediaIds: s.map(l => l.mediaId)
                    }, null, 2)
                }]
            }
        }
        ),
        t.tool("remove-images-from-gallery", "This tool removes specific images from an existing WordPress gallery block while preserving the remaining images. Use this when you need to clean up galleries by removing unwanted, outdated, or irrelevant images without affecting the rest of the collection. It's particularly useful for gallery curation and content management. The tool will remove the specified images and return confirmation of the removals. IMPORTANT: You must first use get-all-blocks to find the gallery block and identify the client IDs of the specific image blocks you want to remove.", {
            blockClientIds: a.array(a.string()).describe('Array of Gutenberg block client IDs of the image blocks to remove from the gallery (e.g., ["d948b4ef-ba2f-45ad-831a-af43afc8b3d9", "a01062b1-da76-41e3-9717-5074d8a32477"]). These are UUID-style string identifiers for the blocks in the editor, obtained from get-all-blocks or find-blocks tools. To find these IDs: 1) Call get-all-blocks to see all blocks, 2) Find the gallery block, 3) Look at its innerBlocks array, 4) Each image block will have a clientId property - use these clientId values, not media library attachment IDs'),
            wasGetAllBlocksCalled: a.boolean().describe("Indicates whether get-all-blocks was called prior to using this tool. You must call that tool before using this one.")
        }, async ({blockClientIds: e, wasGetAllBlocksCalled: r}) => {
            if (!r)
                throw new Error("LLM Instructions: You must call get-all-blocks before using remove-images-from-gallery to ensure valid blockClientIds are provided.");
            return window.wp.data.dispatch("core/block-editor").removeBlocks(e),
            {
                content: [{
                    type: "text",
                    text: JSON.stringify({
                        success: !0,
                        message: `Successfully removed ${e.length} images from gallery`,
                        removedImages: e.length
                    }, null, 2)
                }]
            }
        }
        )
    }
    const ru = async () => {
        let t = null;
        try {
            t = await U("/wp/v2/block-patterns/patterns", "GET"),
            console.log("[Gutenberg Server] Retrieved patterns from REST API")
        } catch (e) {
            console.log("[Gutenberg Server] REST API approach failed:", e)
        }
        if (!t || !Array.isArray(t))
            throw new Error("Could not fetch block patterns from any available source. This may be due to theme incompatibility or missing pattern support.");
        return t
    }
      , Qb = async () => {
        let t = null;
        try {
            t = await U("/wp/v2/block-patterns/categories", "GET"),
            console.log("[Gutenberg Server] Retrieved pattern categories from REST API")
        } catch (e) {
            console.log("[Gutenberg Server] REST API pattern categories approach failed:", e)
        }
        if (!t || !Array.isArray(t))
            throw new Error("Could not fetch block pattern categories from any available source. This may be due to theme incompatibility or missing pattern support.");
        return t
    }
    ;
    function Zn(t) {
        var r;
        if (!t)
            return {};
        const e = {
            id: t.clientId || null,
            name: t.name || null,
            isValid: t.isValid || !1
        };
        return t.attributes && (e.attributes = {
            ...t.attributes
        }),
        (r = t.innerBlocks) != null && r.length && (e.innerBlocks = t.innerBlocks.map(o => Zn(o))),
        e
    }
    function Xb() {
        const t = new He({
            name: "gutenberg-server",
            version: "1.0.0"
        },{
            capabilities: {
                resources: {
                    subscribe: !0
                }
            }
        });
        return console.log("[Gutenberg Server] Initializing Gutenberg server"),
        t.tool("get-all-blocks", "This tool analyzes and maps the entire content structure of the WordPress editor. Use this when you need to understand the current page layout, identify specific blocks for editing, or gather information about block relationships and hierarchy. It's essential for operations that require block identification before performing actions like styling, content updates, or structural changes. The tool will return a complete JSON representation of all blocks, including their unique IDs, attributes, content values, and nested inner blocks in their hierarchical arrangement.", {}, async () => {
            var e, r;
            console.log("[Gutenberg Server] get-all-blocks");
            try {
                if (!((r = (e = window.wp) == null ? void 0 : e.data) != null && r.select))
                    throw new Error("WordPress editor API is not available.");
                const o = window.wp.data.select("core/block-editor");
                if (!o || !o.getBlocks)
                    throw new Error("BlockInstance editor API is not available.");
                const n = o.getBlocks();
                console.log("[Gutenberg Server] blocks:", n);
                const s = n.map(i => Zn(i));
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(s, null, 2)
                    }]
                }
            } catch (o) {
                console.error("[Gutenberg Server] Error getting blocks:", o);
                const n = o instanceof Error ? o.message : String(o);
                throw new Error(n)
            }
        }
        ),
        t.tool("add-block", "This tool creates and places new content elements within the WordPress editor. Use this when you need to add specific types of content such as paragraphs, headings, images, buttons, or other block types to build or enhance page layouts. It's particularly valuable for content creation workflows, implementing user-requested additions, or programmatically constructing page sections. The tool will insert the requested block at the specified position and return its unique identifier for subsequent operations like content population or styling.", {
            blockName: a.string().describe(`The specific block type identifier to create (e.g., "core/paragraph", "core/heading", "core/image"), which determines the content element's functionality and available attributes`),
            attributes: a.record(a.unknown()).optional().describe("Initial configuration options for the block including content, formatting, alignment, and block-specific settings that define how the element will appear and behave"),
            position: a.object({
                index: a.number().optional().describe("The precise numeric position (0-based) where the block should appear within its container; lower values place it closer to the beginning"),
                parentClientId: a.string().optional().describe("The container block's unique identifier if this element should be nested inside another block (like columns or groups); omit for top-level placement")
            }).optional().describe("Placement specifications that determine where the new block will appear in the document structure"),
            blockType: a.enum(["core/paragraph", "core/heading", "core/image", "core/button", "core/list", "core/list-item", "core/quote", "core/separator", "core/spacer", "core/table", "core/table-cell", "core/table-row", "core/video", "core/cover", "core/group", "core/gallery", "core/preformatted", "core/pullquote"])
        }, async ({blockName: e, attributes: r={}, position: o={}}) => {
            var n, s, i, l, d;
            console.log("[Gutenberg Server] add-block:", {
                blockName: e,
                attributes: r,
                position: o
            });
            try {
                if (!((s = (n = window.wp) == null ? void 0 : n.data) != null && s.select) || !((l = (i = window.wp) == null ? void 0 : i.data) != null && l.dispatch) || !((d = window.wp) != null && d.blocks))
                    throw new Error("WordPress editor API is not available.");
                const u = window.wp.data.dispatch("core/block-editor")
                  , g = window.wp.blocks;
                if (!g.createBlock || !u)
                    throw new Error("BlockInstance editor API is not available.");
                const c = g.createBlock(e, r)
                  , {index: m, parentClientId: p=""} = o;
                return typeof m == "number" ? u.insertBlock(c, m, p) : u.insertBlock(c, void 0, p),
                {
                    content: [{
                        type: "text",
                        text: JSON.stringify({
                            success: !0,
                            newBlock: c,
                            message: `Successfully added ${e} block`
                        }, null, 2)
                    }]
                }
            } catch (u) {
                console.error("[Gutenberg Server] Error adding block:", u);
                const g = u instanceof Error ? u.message : String(u);
                throw new Error(g)
            }
        }
        ),
        t.tool("get-block-patterns", "This tool retrieves available block patterns from the WordPress pattern library. Use this ONLY when the user specifically asks to see what patterns are available, requests to browse patterns, or when you need to find a specific pattern name for the insert-block-pattern tool. Do not call this tool automatically - only call it when the user explicitly wants to explore or discover patterns. The tool will return a list of pattern objects with names, titles, categories, and HTML content.", {}, async () => {
            console.log("[Gutenberg Server] get-block-patterns");
            try {
                const e = await ru();
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(e, null, 2)
                    }]
                }
            } catch (e) {
                console.error("[Gutenberg Server] Error getting block patterns:", e);
                const r = e instanceof Error ? e.message : String(e);
                throw new Error(r)
            }
        }
        ),
        t.tool("get-block-pattern-categories", "This tool retrieves the available pattern categories from WordPress. Use this ONLY when the user specifically asks what pattern categories exist, wants to see how patterns are organized, or requests to browse patterns by category. Do not call this tool automatically or as part of general pattern discovery. The tool will return a list of category objects with names, labels, and descriptions.", {}, async () => {
            console.log("[Gutenberg Server] get-block-pattern-categories");
            try {
                const e = await Qb();
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(e, null, 2)
                    }]
                }
            } catch (e) {
                console.error("[Gutenberg Server] Error getting block pattern categories:", e);
                const r = e instanceof Error ? e.message : String(e);
                throw new Error(r)
            }
        }
        ),
        t.tool("update-block-attributes-content-and-style", `This tool modifies any attributes of a Gutenberg block in the WordPress editor.
Use this when you need to change block content, configuration, or appearance including text content, image URLs, styling properties, layout settings, or any other block-specific attributes.
It handles all types of block modifications from simple content updates to complex styling changes and configuration adjustments. 
The tools CAN'T handle custom fields and ACF fields, for ACF fields use update-meta-field-values tool.
For gallery blocks, use the dedicated gallery management tools (create-gallery-block, update-gallery-block, etc.) instead of this tool.
The tool will immediately apply the attribute changes to the specified block and return confirmation with the updated block details.`, {
            clientId: a.string().describe('The Gutenberg block client ID of the block to modify (e.g., "f521ca0d-ab62-4187-82b3-3c04d44a4327"). This is a UUID-style string identifier for the block in the editor, obtained from get-all-blocks or other block discovery tools'),
            attributes: a.union([a.object({
                url: Lc(Zf)
            }).passthrough().describe("Image block attributes with validated URL"), a.any().describe(`Non-image block attributes. Complete block attributes object containing any properties to update.
This includes content fields, styling configurations, layout settings, and block-specific options.
The structure varies by block type but follows Gutenberg block attribute standards with proper nesting for style objects and configuration properties.
For quote blocks (core/quote), the "value" attribute must contain HTML-formatted content wrapped in paragraph tags, e.g., {"value": "<p>Your quote text here</p>", "citation": "Author Name"}.`)]).describe("Block attributes that are not custom fields or ACF fields")
        }, async ({clientId: e, attributes: r}) => {
            var o, n, s, i;
            console.log("[Gutenberg Server] update-block-attributes:", {
                clientId: e,
                attributes: r
            });
            try {
                if (!((n = (o = window.wp) == null ? void 0 : o.data) != null && n.select) || !((i = (s = window.wp) == null ? void 0 : s.data) != null && i.dispatch))
                    throw new Error("WordPress editor API is not available.");
                const l = window.wp.data.dispatch("core/block-editor")
                  , d = window.wp.data.select("core/block-editor");
                if (!l || !d)
                    throw new Error("BlockInstance editor API is not available.");
                const u = d.getBlock(e);
                if (!u)
                    throw new Error(`Block with client ID "${e}" not found.`);
                return console.log("GUTENBERG: update attributes for:", {
                    block: u,
                    attributes: r
                }),
                l.updateBlockAttributes(e, r),
                {
                    content: [{
                        type: "text",
                        text: JSON.stringify({
                            success: !0,
                            message: `Successfully updated attributes for block ${e}`,
                            blockName: u.name,
                            updatedAttributes: Object.keys(r)
                        }, null, 2)
                    }]
                }
            } catch (l) {
                console.error("[Gutenberg Server] Error updating block attributes:", l);
                const d = l instanceof Error ? l.message : String(l);
                throw new Error(d)
            }
        }
        ),
        t.tool("insert-block-pattern", "This tool places professionally designed, multi-block content arrangements into the page layout. Use this when you need to quickly implement complex page sections like hero areas, feature grids, pricing tables, or testimonial displays with consistent styling and proper structure. It's especially powerful for efficiently creating polished page layouts without manually configuring individual blocks. The tool will insert the complete pattern at your specified position, converting the pre-designed template into fully editable blocks that can be further customized as needed.", {
            patternInput: a.union([a.string().describe("The unique identifier of the pattern to insert (obtained from get-block-patterns), which references a specific pre-designed template from the WordPress library"), a.object({
                content: a.string().describe("Custom HTML content to be parsed and inserted as blocks, allowing for dynamic generation or customization of patterns not in the standard library")
            }).describe("A custom content object when using generated or modified pattern HTML rather than a pre-defined pattern")]).describe("The pattern source specification - either a pattern name from the WordPress library or custom HTML content"),
            position: a.object({
                index: a.number().optional().describe("The numeric position (0-based) where the pattern should appear within its container; lower numbers place it closer to the beginning of the content"),
                parentClientId: a.string().optional().describe("The unique identifier of a container block if the pattern should be nested within another element; omit for top-level placement")
            }).optional().describe("Positioning specifications that determine exactly where in the document structure the pattern will be placed")
        }, async ({patternInput: e, position: r={}}) => {
            var o, n, s, i, l;
            console.log("[Gutenberg Server] insert-block-pattern:", {
                patternInput: e,
                position: r
            });
            try {
                if (!((n = (o = window.wp) == null ? void 0 : o.data) != null && n.select) || !((i = (s = window.wp) == null ? void 0 : s.data) != null && i.dispatch) || !((l = window.wp) != null && l.blocks))
                    throw new Error("WordPress editor API is not available.");
                const d = window.wp.data.dispatch("core/block-editor");
                let u;
                if (typeof e == "string") {
                    const f = (await ru()).find(y => y.name === e);
                    if (!f)
                        throw new Error(`Pattern with name "${e}" not found.`);
                    u = f.content
                } else
                    u = e.content;
                if (!u)
                    throw new Error("Invalid pattern content.");
                const g = window.wp.blocks;
                if (!g.parse)
                    throw new Error("BlockInstance parser is not available.");
                const c = g.parse(u);
                if (!c || c.length === 0)
                    throw new Error("Failed to parse pattern content into blocks.");
                const {index: m, parentClientId: p=""} = r;
                if (!d.insertBlocks)
                    throw new Error("insertBlocks dispatch method is not available.");
                return d.insertBlocks(c, typeof m == "number" ? m : void 0, p),
                {
                    content: [{
                        type: "text",
                        text: JSON.stringify({
                            success: !0,
                            message: "Successfully inserted pattern",
                            insertedBlocks: c.length
                        }, null, 2)
                    }]
                }
            } catch (d) {
                console.error("[Gutenberg Server] Error inserting block pattern:", d);
                const u = d instanceof Error ? d.message : String(d);
                throw new Error(u)
            }
        }
        ),
        t.tool("convert-html-to-gutenberg-blocks", 'This tool converts raw HTML markup into structured Gutenberg blocks using WordPress native conversion logic (wp.blocks.rawHandler). Use this to convert HTML content into proper semantic blocks like paragraphs, headings, and lists. When mode is "insert", it adds the converted blocks to the editor. When mode is "replace", it replaces all existing classic/freeform blocks with the converted HTML blocks.', {
            html: a.string().describe("The complete HTML markup to be converted using wp.blocks.rawHandler for proper block conversion"),
            mode: a.enum(["insert", "replace"]).default("insert").describe('Mode: "insert" adds converted blocks to editor, "replace" replaces all classic/freeform blocks with the converted HTML'),
            position: a.object({
                index: a.number().optional().describe("The precise insertion point (0-based) within the parent container where the parsed blocks should appear; lower values place content closer to the beginning"),
                parentClientId: a.string().optional().describe("The unique identifier of a container block if the content should be nested inside another element; omit for top-level placement in the main content area")
            }).optional().describe("Location specifications determining where in the document structure the parsed HTML blocks will be placed (only used in insert mode)")
        }, async ({html: e, mode: r="insert", position: o={}}) => {
            var n, s, i, l, d;
            console.log("[Gutenberg Server] convert-html-to-gutenberg-blocks:", {
                htmlLength: e == null ? void 0 : e.length,
                mode: r,
                position: o
            });
            try {
                if (!((s = (n = window.wp) == null ? void 0 : n.data) != null && s.dispatch) || !((l = (i = window.wp) == null ? void 0 : i.data) != null && l.select) || !((d = window.wp) != null && d.blocks))
                    throw new Error("WordPress editor API is not available.");
                const u = window.wp.data.dispatch("core/block-editor")
                  , g = window.wp.data.select("core/block-editor")
                  , c = window.wp.blocks
                  , m = c.rawHandler
                  , p = m({
                    HTML: e
                });
                if (!p || p.length === 0)
                    throw new Error("Failed to convert HTML content into blocks.");
                if (r === "replace") {
                    const y = g.getBlocks().filter(v => v.name === "core/freeform" || v.name === "core/classic" || v.name === "core/html");
                    let b = 0;
                    const x = [];
                    for (const v of y) {
                        const S = v.clientId
                          , w = c.getBlockContent(v);
                        if (w) {
                            const _ = m({
                                HTML: w
                            });
                            _ && _.length > 0 && (u.replaceBlocks ? u.replaceBlocks([S], _) : (u.removeBlock(S),
                            u.insertBlocks && u.insertBlocks(_)),
                            b += _.length,
                            x.push(S))
                        }
                    }
                    return {
                        content: [{
                            type: "text",
                            text: JSON.stringify({
                                success: !0,
                                message: "Successfully converted to Gutenberg blocks (paragraphs, lists, etc.)",
                                convertedCount: b,
                                insertedBlocks: b
                            }, null, 2)
                        }]
                    }
                }
                const {index: h, parentClientId: f=""} = o;
                if (!u.insertBlocks)
                    throw new Error("insertBlocks dispatch method is not available.");
                return u.insertBlocks(p, typeof h == "number" ? h : void 0, f),
                {
                    content: [{
                        type: "text",
                        text: JSON.stringify({
                            success: !0,
                            message: "Successfully inserted HTML content as blocks",
                            insertedBlocks: p.length
                        }, null, 2)
                    }]
                }
            } catch (u) {
                console.error("[Gutenberg Server] Error processing HTML content:", u);
                const g = u instanceof Error ? u.message : String(u);
                throw new Error(g)
            }
        }
        ),
        t.tool("remove-block", "This tool permanently eliminates content elements from the page layout. Use this when you need to clean up unnecessary sections, remove outdated information, or restructure content by deleting specific blocks. It's particularly useful during content editing workflows, page redesigns, or when implementing user requests to remove specific elements. The tool will instantly delete the specified block and all of its nested content, freeing up space in the layout and simplifying the page structure.", {
            clientId: a.string().describe('The Gutenberg block client ID of the block to be deleted (e.g., "f521ca0d-ab62-4187-82b3-3c04d44a4327"). This is a UUID-style string identifier for the block in the editor, obtained from get-all-blocks or get-block tools')
        }, async ({clientId: e}) => {
            var r, o;
            console.log("[Gutenberg Server] remove-block:", {
                clientId: e
            });
            try {
                if (!((o = (r = window.wp) == null ? void 0 : r.data) != null && o.dispatch))
                    throw new Error("WordPress editor API is not available.");
                const n = window.wp.data.dispatch("core/block-editor");
                if (!n)
                    throw new Error("BlockInstance editor API is not available.");
                return n.removeBlock(e),
                {
                    content: [{
                        type: "text",
                        text: JSON.stringify({
                            success: !0,
                            message: `Successfully removed block ${e}`
                        }, null, 2)
                    }]
                }
            } catch (n) {
                console.error("[Gutenberg Server] Error removing block:", n);
                const s = n instanceof Error ? n.message : String(n);
                throw new Error(s)
            }
        }
        ),
        t.tool("get-block-types", "This tool provides a comprehensive catalog of all content element types available for use in the WordPress editor. Use this when planning page structure, determining which content elements would best serve specific needs, or exploring the full range of available block functionality. It's particularly valuable during content strategy discussions or when teaching users about available content options. The tool will return detailed information about each block type, including its name, title, visual icon, category, description, and relevant keywords to help identify the most appropriate elements for different content requirements.", {}, async () => {
            var e, r, o;
            console.log("[Gutenberg Server] get-block-types");
            try {
                if (!((r = (e = window.wp) == null ? void 0 : e.blocks) != null && r.getBlockTypes))
                    throw new Error("WordPress blocks API is not available.");
                const s = ((o = window.wp.blocks) == null ? void 0 : o.getBlockTypes()).map(i => {
                    var d;
                    const l = typeof i.icon == "string" ? i.icon : (d = i.icon) == null ? void 0 : d.src;
                    return {
                        name: i.name,
                        title: i.title,
                        icon: l,
                        category: i.category,
                        description: i.description,
                        keywords: i.keywords
                    }
                }
                );
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(s, null, 2)
                    }]
                }
            } catch (n) {
                console.error("[Gutenberg Server] Error getting block types:", n);
                const s = n instanceof Error ? n.message : String(n);
                throw new Error(s)
            }
        }
        ),
        t.tool("create-columns", "This tool creates responsive multi-column layouts for organizing content in parallel visual streams. Use this when you need to present related information side-by-side, create comparison tables, or structure content in grid-like arrangements for better visual flow and space utilization. It's particularly effective for pricing tables, feature comparisons, team profiles, or any content that benefits from parallel presentation. The tool will generate a complete column structure with the specified number of columns, each containing placeholder content that can be easily replaced with your actual content.", {
            numberOfColumns: a.number().min(1).max(6).describe("The specific number of vertical content divisions to create (between 1-6), which determines how many parallel content streams will appear side-by-side in the layout"),
            position: a.object({
                index: a.number().optional().describe("The precise insertion point (0-based) within the parent container where the column layout should appear; lower values place it closer to the beginning of the content"),
                parentClientId: a.string().optional().describe("The unique identifier of a container block if the column layout should be nested inside another element; omit for top-level placement in the main content area")
            }).optional().describe("Positioning specifications that determine where in the document structure the column layout will be placed"),
            columnWidth: a.number().describe("The width of each column in percentage (0-100), which determines the relative size of each column in the layout"),
            blockType: a.enum(["core/columns", "core/column"])
        }, async ({numberOfColumns: e, position: r={}, columnWidth: o=100}) => {
            var n, s, i;
            console.log("[Gutenberg Server] create-columns:", {
                numberOfColumns: e,
                position: r,
                columnWidth: o
            });
            try {
                if (!((s = (n = window.wp) == null ? void 0 : n.data) != null && s.dispatch) || !((i = window.wp) != null && i.blocks))
                    throw new Error("WordPress editor API is not available.");
                const l = window.wp.data.dispatch("core/block-editor")
                  , d = window.wp.blocks;
                if (!d.createBlock)
                    throw new Error("Block creation API is not available.");
                const u = [];
                for (let p = 0; p < e; p++) {
                    const h = d.createBlock("core/column", {
                        width: `${o}%`
                    }, []);
                    u.push(h)
                }
                const g = d.createBlock("core/columns", {}, u)
                  , {index: c, parentClientId: m=""} = r;
                return typeof c == "number" ? l.insertBlock(g, c, m) : l.insertBlock(g, void 0, m),
                {
                    content: [{
                        type: "text",
                        text: JSON.stringify({
                            success: !0,
                            columnsBlock: g,
                            message: `Successfully created columns block with ${e} columns`
                        }, null, 2)
                    }]
                }
            } catch (l) {
                console.error("[Gutenberg Server] Error creating columns block:", l);
                const d = l instanceof Error ? l.message : String(l);
                throw new Error(d)
            }
        }
        ),
        t.tool("move-block", "This tool changes the position of existing content elements within the page layout. Use this when you need to reorganize content flow, improve visual hierarchy, or change the structural relationship between elements. It's particularly valuable for refining layouts based on user feedback, improving content narrative, or adapting layouts for different screen sizes and content priorities. The tool will transfer the specified block to a new location while preserving all its content, styling, and functionality intact.", {
            clientId: a.string().describe("The unique identifier of the content element to be moved, which can be obtained from get-all-blocks or get-block tools and specifies exactly which block will change position"),
            toIndex: a.number().describe("The destination position (0-based) within the target container where the block should be placed; lower numbers position content closer to the beginning of the container"),
            toParentClientId: a.string().optional().describe("The unique identifier of the destination container block if moving the element to a different parent (such as into a column or group); omit to reposition within the current parent container")
        }, async ({clientId: e, toIndex: r, toParentClientId: o=""}) => {
            var n, s;
            console.log("[Gutenberg Server] move-block:", {
                clientId: e,
                toIndex: r,
                toParentClientId: o
            });
            try {
                if (!((s = (n = window.wp) == null ? void 0 : n.data) != null && s.dispatch))
                    throw new Error("WordPress editor API is not available.");
                const i = window.wp.data.dispatch("core/block-editor");
                if (!i)
                    throw new Error("BlockInstance editor API is not available.");
                return i.moveBlockToPosition(e, "", o, r),
                {
                    content: [{
                        type: "text",
                        text: JSON.stringify({
                            success: !0,
                            message: `Successfully moved block ${e} to index ${r}${o ? ` under parent ${o}` : ""}`
                        }, null, 2)
                    }]
                }
            } catch (i) {
                console.error("[Gutenberg Server] Error moving block:", i);
                const l = i instanceof Error ? i.message : String(i);
                throw new Error(l)
            }
        }
        ),
        t.tool("get-block", "This tool analyzes and provides detailed information about a specific content element in the editor. Use this when you need to understand a block's current configuration, examine its attributes, or investigate its content and structure before modifying it. It's particularly useful during troubleshooting, content auditing, or when planning targeted updates to specific elements. The tool will return comprehensive data about the requested block, including its type, attributes, content values, and any nested inner blocks it contains.", {
            clientId: a.string().describe('The Gutenberg block client ID of the specific block to analyze (e.g., "f521ca0d-ab62-4187-82b3-3c04d44a4327"). This is a UUID-style string identifier for the block in the editor, obtained from get-all-blocks or find-blocks tools')
        }, async ({clientId: e}) => {
            var r, o;
            console.log("[Gutenberg Server] get-block:", {
                clientId: e
            });
            try {
                if (!((o = (r = window.wp) == null ? void 0 : r.data) != null && o.select))
                    throw new Error("WordPress editor API is not available.");
                const n = window.wp.data.select("core/block-editor");
                if (!n)
                    throw new Error("BlockInstance editor API is not available.");
                const s = n.getBlock(e);
                if (!s)
                    throw new Error(`BlockInstance with client ID "${e}" not found.`);
                const i = Zn(s);
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(i, null, 2)
                    }]
                }
            } catch (n) {
                console.error("[Gutenberg Server] Error getting block:", n);
                const s = n instanceof Error ? n.message : String(n);
                throw new Error(s)
            }
        }
        ),
        t.tool("find-blocks", "This tool surveys and catalogs content elements currently present in the editor. Use this when you need to identify existing blocks for analysis, manipulation, or to understand the overall page structure without knowing specific block IDs in advance. It's particularly valuable when planning content reorganization, performing content audits, or preparing for batch operations on multiple blocks. The tool will return a structured inventory of blocks in the editor, providing essential information about each one to facilitate further operations.", {
            criteria: a.object({
                maxResults: a.number().optional().describe("An optional limit on the number of blocks to return, which helps prevent overwhelming responses when only a sampling of blocks is needed for analysis")
            }).optional().describe("Optional filtering parameters that control how many results are returned to manage response size and focus on the most relevant blocks")
        }, async ({criteria: e={}}) => {
            var r, o;
            console.log("[Gutenberg Server] find-blocks:", e);
            try {
                if (!((o = (r = window.wp) == null ? void 0 : r.data) != null && o.select))
                    throw new Error("WordPress editor API is not available.");
                const n = window.wp.data.select("core/block-editor");
                if (!n)
                    throw new Error("Block editor API is not available.");
                const s = n.getBlocks()
                  , i = s.map(u => Zn(u))
                  , l = e.maxResults
                  , d = l ? i.slice(0, l) : i;
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify({
                            success: !0,
                            rootBlockCount: s.length,
                            returnedRootBlocks: d.length,
                            blocks: d
                        }, null, 2)
                    }]
                }
            } catch (n) {
                console.error("[Gutenberg Server] Error finding blocks:", n);
                const s = n instanceof Error ? n.message : String(n);
                throw new Error(s)
            }
        }
        ),
        t.tool("find-specific-block", "This tool interprets conversational descriptions to identify specific content elements in the editor. Use this when you need to reference blocks by their visual appearance, relative position, or content characteristics rather than technical identifiers. It's particularly helpful when working with users who describe content in natural language terms, or when targeting blocks based on their semantic meaning or visual context. The tool will analyze the entire page structure and identify the most likely block matching the given description, returning its technical details for subsequent operations.", {
            description: a.string().describe('A human-friendly description of the content element to locate, which can reference position ("at the top"), visual characteristics ("blue button"), content ("about pricing"), or any other distinguishing features that help identify the specific block'),
            returnAllBlocks: a.boolean().optional().describe("Controls whether the response includes the complete block inventory (when true) to provide context for analysis, or only returns matching results (when false) for a more concise response")
        }, async ({description: e, returnAllBlocks: r=!0}) => {
            var o, n;
            console.log("[Gutenberg Server] find-specific-block:", {
                description: e
            });
            try {
                if (!((n = (o = window.wp) == null ? void 0 : o.data) != null && n.select))
                    throw new Error("WordPress editor API is not available.");
                const s = window.wp.data.select("core/block-editor");
                if (!s)
                    throw new Error("Block editor API is not available.");
                const i = s.getBlocks()
                  , l = i.map(d => Zn(d));
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify({
                            success: !0,
                            blockCount: i.length,
                            description: e,
                            blocks: r ? l : [],
                            instructions: "Please analyze the blocks to find the one that best matches the description: " + e
                        }, null, 2)
                    }]
                }
            } catch (s) {
                console.error("[Gutenberg Server] Error finding specific block:", s);
                const i = s instanceof Error ? s.message : String(s);
                throw new Error(i)
            }
        }
        ),
        t.tool("update-block-html", "This tool replaces the textual content of existing blocks with new HTML markup. Use this ONLY when the user explicitly mentions working with HTML, requests HTML updates, or specifically asks to use HTML markup. This is a specialized tool for direct HTML manipulation - do not use for general content updates or formatting unless HTML is specifically requested. The tool will apply the provided HTML content to the specified block, instantly updating its appearance while preserving its position in the layout.", {
            clientId: a.string().describe("The unique identifier of the block to modify, which can be obtained from get-all-blocks or find-blocks tools and specifies exactly which content element will receive the new HTML content"),
            html: a.string().describe("The complete HTML markup to be applied to the block, including any formatting tags, links, or other HTML elements required for proper rendering of the content")
        }, async ({clientId: e, html: r}) => {
            var o, n, s, i, l, d, u, g, c, m;
            console.log("[Gutenberg Server] update-block-html:", {
                clientId: e,
                html: r
            });
            try {
                if (!((n = (o = window.wp) == null ? void 0 : o.data) != null && n.select) || !((i = (s = window.wp) == null ? void 0 : s.data) != null && i.dispatch))
                    throw new Error("WordPress editor API is not available.");
                const p = window.wp.data.dispatch("core/block-editor")
                  , h = window.wp.data.select("core/block-editor");
                if (!p || !h)
                    throw new Error("BlockInstance editor API is not available.");
                const f = h.getBlock(e);
                if (!f)
                    throw new Error(`BlockInstance with client ID "${e}" not found.`);
                const y = h.getBlockAttributes(e);
                let b = !1;
                if (y && (b = Object.prototype.hasOwnProperty.call(y, "content"),
                !b && ((d = (l = window.wp) == null ? void 0 : l.blocks) != null && d.getBlockType))) {
                    const S = window.wp.blocks.getBlockType(f.name);
                    (u = S == null ? void 0 : S.attributes) != null && u.content && (b = !0)
                }
                if (b)
                    p.updateBlockAttributes(e, {
                        content: r
                    });
                else {
                    const S = (c = (g = document.querySelector('iframe[name="editor-canvas"]')) == null ? void 0 : g.contentDocument) == null ? void 0 : c.querySelector(`[data-block="${e}"]`);
                    if (S)
                        S.innerHTML = r;
                    else
                        throw new Error(`Could not find DOM element for block ${e}`)
                }
                const x = document.querySelectorAll(".components-toolbar-button");
                let v = null;
                for (const S of x)
                    if (((m = S.textContent) == null ? void 0 : m.trim()) === "Preview") {
                        v = S;
                        break
                    }
                return v && !v.classList.contains("is-pressed") && v.click(),
                {
                    content: [{
                        type: "text",
                        text: JSON.stringify({
                            success: !0,
                            message: `Successfully updated HTML content for block ${e}`
                        }, null, 2)
                    }]
                }
            } catch (p) {
                console.error("[Gutenberg Server] Error updating block HTML:", p);
                const h = p instanceof Error ? p.message : String(p);
                throw new Error(h)
            }
        }
        ),
        t.tool("save-post", "This tool saves all current changes to the post or page in the editor to ensure they are not lost. Use this when you've completed a series of content modifications and want to secure those changes before continuing with additional edits or publishing. It's particularly important after making significant content changes, implementing user-requested modifications, or before performing operations that might cause unexpected behavior. The tool will commit all pending changes to the WordPress database, updating the content's revision history and providing confirmation of the save operation.", {}, async () => {
            var e, r, o, n;
            console.log("[Gutenberg Server] save-post");
            try {
                if (!((r = (e = window.wp) == null ? void 0 : e.data) != null && r.select) || !((n = (o = window.wp) == null ? void 0 : o.data) != null && n.dispatch))
                    throw new Error("WordPress editor API is not available.");
                const s = window.wp.data.dispatch("core/editor")
                  , i = window.wp.data.select("core/editor");
                if (!s || !i)
                    throw new Error("Editor API is not available.");
                if (typeof s.savePost != "function")
                    throw new Error("savePost function is not available.");
                if (i.isSavingPost())
                    return {
                        content: [{
                            type: "text",
                            text: JSON.stringify({
                                success: !1,
                                message: "Post is already being saved."
                            }, null, 2)
                        }]
                    };
                await s.savePost();
                const d = i.getCurrentPostId()
                  , u = i.getCurrentPostType()
                  , g = i.getEditedPostAttribute("title");
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify({
                            success: !0,
                            postId: d,
                            postType: u,
                            postTitle: g,
                            message: "Post saved successfully."
                        }, null, 2)
                    }]
                }
            } catch (s) {
                console.error("[Gutenberg Server] Error saving post:", s);
                const i = s instanceof Error ? s.message : String(s);
                throw new Error(i)
            }
        }
        ),
        t.tool("publish-post", "This tool releases content to the public by changing its status from draft to published. Use this when content creation and editing are complete, and the page or post is ready for public viewing. It's the final step in the content creation workflow that makes the content accessible to site visitors and search engines. The tool will update the post status to published, save all changes, and return confirmation details including the post ID, title, and updated status.", {
            options: a.object({
                autoSave: a.boolean().optional().describe("Controls whether unsaved changes should be automatically saved before publishing (true) or if publishing should proceed without saving draft changes first (false)")
            }).optional().describe("Publishing configuration options that determine how the publication process should handle unsaved changes")
        }, async ({options: e={
            autoSave: !0
        }}) => {
            var r, o, n, s;
            console.log("[Gutenberg Server] publish-post:", e);
            try {
                if (!((o = (r = window.wp) == null ? void 0 : r.data) != null && o.select) || !((s = (n = window.wp) == null ? void 0 : n.data) != null && s.dispatch))
                    throw new Error("WordPress editor API is not available.");
                const i = window.wp.data.dispatch("core/editor")
                  , l = window.wp.data.select("core/editor");
                if (!i || !l)
                    throw new Error("Editor API is not available.");
                if (typeof i.savePost != "function" || typeof i.editPost != "function")
                    throw new Error("Required editor functions are not available.");
                const d = l.isCurrentPostPublished()
                  , u = l.isCurrentPostScheduled()
                  , g = l.isEditedPostDirty()
                  , c = l.isSavingPost()
                  , m = l.isPublishingPost();
                return m || c ? {
                    content: [{
                        type: "text",
                        text: JSON.stringify({
                            success: !1,
                            message: m ? "Post is already being published." : "Post is already being saved."
                        }, null, 2)
                    }]
                } : (e.autoSave && g && await i.savePost(),
                d || u ? (await i.savePost(),
                {
                    content: [{
                        type: "text",
                        text: JSON.stringify({
                            success: !0,
                            postId: l.getCurrentPostId(),
                            postTitle: l.getEditedPostAttribute("title"),
                            message: "Published post was updated successfully.",
                            postStatus: l.getEditedPostAttribute("status")
                        }, null, 2)
                    }]
                }) : (i.editPost({
                    status: "publish"
                }),
                await i.savePost(),
                {
                    content: [{
                        type: "text",
                        text: JSON.stringify({
                            success: !0,
                            postId: l.getCurrentPostId(),
                            postTitle: l.getEditedPostAttribute("title"),
                            message: "Post published successfully.",
                            postStatus: l.getEditedPostAttribute("status")
                        }, null, 2)
                    }]
                }))
            } catch (i) {
                console.error("[Gutenberg Server] Error publishing post:", i);
                const l = i instanceof Error ? i.message : String(i);
                throw new Error(l)
            }
        }
        ),
        t.tool("merge-blocks", "This tool consolidates multiple separate content elements into a single cohesive element. Use this when you need to simplify page structure, combine related content that was previously divided, or streamline the editing experience for content that logically belongs together. It's particularly useful for joining adjacent paragraphs, lists, or other text-based content that should flow as one unified block. The tool will intelligently combine the specified blocks while preserving their content, resulting in a cleaner page structure with fewer individual elements to manage.", {
            blockClientIds: a.array(a.string()).describe("An ordered list of unique block identifiers that specifies which content elements to combine and the sequence in which they should be merged, with the first block becoming the container for all content")
        }, async ({blockClientIds: e}) => {
            var r, o, n, s;
            console.log("[Gutenberg Server] merge-blocks:", {
                blockClientIds: e
            });
            try {
                if (!((o = (r = window.wp) == null ? void 0 : r.data) != null && o.select) || !((s = (n = window.wp) == null ? void 0 : n.data) != null && s.dispatch))
                    throw new Error("WordPress editor API is not available.");
                const i = window.wp.data.dispatch("core/block-editor")
                  , l = window.wp.data.select("core/block-editor");
                if (!i || !l)
                    throw new Error("Block editor API is not available.");
                if (!e || e.length < 2)
                    throw new Error("At least two block client IDs must be provided for merging.");
                if (!i.mergeBlocks)
                    throw new Error("mergeBlocks operation is not available in this version of Gutenberg.");
                const d = l.getBlocksByClientId(e).filter(c => !!c);
                if (d.length < 2)
                    throw new Error("At least two valid blocks must be provided for merging.");
                const u = d[0].clientId
                  , g = d[0].clientId;
                for (let c = 1; c < d.length; c++) {
                    const m = d[c].clientId;
                    i.mergeBlocks(g, m)
                }
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify({
                            success: !0,
                            blockId: u,
                            message: `Successfully merged ${d.length} blocks using Gutenberg's native mergeBlocks functionality`
                        }, null, 2)
                    }]
                }
            } catch (i) {
                console.error("[Gutenberg Server] Error merging blocks:", i);
                const l = i instanceof Error ? i.message : String(i);
                throw new Error(l)
            }
        }
        ),
        t.tool("toggle-block-mode", "This tool changes how a content element can be edited by switching between visual (WYSIWYG) and HTML code editing interfaces. Use this when you need finer control over HTML markup, need to fix formatting issues that can't be addressed through the visual editor, or want to add custom HTML that isn't supported by standard block controls. It's particularly valuable for advanced editing of complex content or when troubleshooting display problems. The tool will immediately switch the specified block's editing interface while preserving all content and formatting.", {
            clientId: a.string().describe("The unique identifier of the block whose editing mode should be changed, which can be obtained from get-all-blocks or find-blocks tools and determines which exact content element will be affected"),
            mode: a.enum(["visual", "html", "toggle"]).optional().describe('The specific editing interface to activate: "visual" for the standard WYSIWYG editor, "html" for direct code editing, or "toggle" to switch to the opposite of the current mode')
        }, async ({clientId: e, mode: r="toggle"}) => {
            var o, n, s, i;
            console.log("[Gutenberg Server] toggle-block-mode:", {
                clientId: e,
                mode: r
            });
            try {
                if (!((n = (o = window.wp) == null ? void 0 : o.data) != null && n.select) || !((i = (s = window.wp) == null ? void 0 : s.data) != null && i.dispatch))
                    throw new Error("WordPress editor API is not available.");
                const l = window.wp.data.dispatch("core/block-editor")
                  , d = window.wp.data.select("core/block-editor");
                if (!l || !d)
                    throw new Error("Block editor API is not available.");
                if (!l.toggleBlockMode)
                    throw new Error("toggleBlockMode operation is not available in this version of Gutenberg.");
                if (!d.getBlock(e))
                    throw new Error(`Block with client ID "${e}" not found.`);
                return l.toggleBlockMode(e),
                {
                    content: [{
                        type: "text",
                        text: JSON.stringify({
                            success: !0,
                            blockId: e,
                            message: `Successfully toggled block mode to ${r === "toggle" ? "the opposite mode" : r}`
                        }, null, 2)
                    }]
                }
            } catch (l) {
                console.error("[Gutenberg Server] Error toggling block mode:", l);
                const d = l instanceof Error ? l.message : String(l);
                throw new Error(d)
            }
        }
        ),
        t.tool("generate-custom-code", "This tool generates custom code snippets in specified programming languages based on user requirements. Use this when you need to create code for websites, web applications, or any programming tasks. It supports various programming languages including HTML, CSS, JavaScript, PHP, Python, and more. The tool is particularly useful for creating functional code blocks, implementing specific features, or generating code examples. When editing existing code blocks in Gutenberg, the tool automatically detects the current block context and modifies the existing code appropriately.", {
            prompt: a.string().describe("Detailed description of what the code should accomplish, including specific requirements, functionality, and any constraints"),
            language: a.string().describe('The programming language for the generated code (e.g., "javascript", "html", "css", "php", "python", "sql")'),
            codeContext: a.object({
                blockId: a.string().optional().describe("The unique identifier of an existing code block if editing existing code"),
                existingCode: a.string().optional().describe("The current code content if editing an existing code block"),
                blockType: a.string().optional().describe('The type of the current block (e.g., "core/code", "core/html")')
            }).optional().describe("Optional context about the current editor state and existing code to be edited")
        }, async ({prompt: e, language: r, codeContext: o}) => {
            console.log("[Gutenberg Server] generate-custom-code:", {
                prompt: e,
                language: r,
                codeContext: o
            });
            try {
                const n = await t.server.request({
                    method: "sampling/createMessage",
                    params: {
                        messages: [{
                            role: "user",
                            content: {
                                type: "text",
                                text: e
                            }
                        }],
                        maxTokens: 2e3,
                        modelPreferences: {
                            hints: [{
                                name: "elementor-code-generation"
                            }]
                        },
                        metadata: {
                            language: r,
                            codeContext: {
                                ...o,
                                parsedResponse: !0
                            }
                        }
                    }
                }, Pr)
                  , s = n.content.text;
                if (!s)
                    throw console.error("[Gutenberg Server] Error: No code text received from API", n),
                    new Error("Failed to generate code: No text content received from API.");
                const {blockId: i} = o || {}
                  , l = window.wp.data.dispatch("core/block-editor")
                  , d = window.wp.data.select("core/block-editor");
                if (i) {
                    if (!(l != null && l.updateBlockAttributes) || !(d != null && d.getBlock))
                        throw new Error("Block update API is not available");
                    if (!d.getBlock(i))
                        throw new Error(`Block with ID "${i}" not found`);
                    l.updateBlockAttributes(i, {
                        content: s
                    })
                } else {
                    const g = window.wp.blocks;
                    if (!(g != null && g.createBlock) || !(l != null && l.insertBlock))
                        throw new Error("Block creation API is not available");
                    const c = g.createBlock("core/code", {
                        content: s
                    });
                    l.insertBlock(c)
                }
                const u = i ? "updated" : "created";
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify({
                            success: !0,
                            message: "Custom code generated successfully",
                            code: s,
                            language: r,
                            blockId: o == null ? void 0 : o.blockId,
                            action: u
                        })
                    }]
                }
            } catch (n) {
                console.error("[Gutenberg Server] Error generating custom code:", n);
                const s = n instanceof Error ? n.message : String(n);
                throw new Error(s)
            }
        }
        ),
        t.tool("get-media-by-id", "Gets WordPress media library item details by media ID, including the source URL that can be used for image processing in Gutenberg. Use this when you have a media ID and need to get the image URL for processing operations.", {
            mediaId: a.number().describe("The WordPress media library ID of the image to get details for")
        }, async ({mediaId: e}) => {
            var r, o, n;
            console.log("[Gutenberg Server] get-media-by-id", {
                mediaId: e
            });
            try {
                if (!window.wp)
                    throw new Error("Window.wp is not defined");
                const s = await fetch(`/wp-json/wp/v2/media/${e}`);
                if (!s.ok)
                    throw new Error(`HTTP ${s.status}: ${s.statusText}`);
                const i = await s.json();
                if (!i || !i.source_url)
                    throw new Error(`Media item with ID ${e} not found or has no source URL`);
                const l = {
                    id: i.id,
                    title: typeof i.title == "string" ? i.title : ((r = i.title) == null ? void 0 : r.rendered) || i.slug || "Untitled",
                    alt_text: i.alt_text || "",
                    source_url: i.source_url,
                    media_type: i.media_type,
                    mime_type: i.mime_type,
                    date: i.date,
                    caption: typeof i.caption == "string" ? i.caption : ((o = i.caption) == null ? void 0 : o.rendered) || "",
                    description: typeof i.description == "string" ? i.description : ((n = i.description) == null ? void 0 : n.rendered) || "",
                    media_details: i.media_details
                };
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(l, null, 2)
                    }]
                }
            } catch (s) {
                throw console.error("[Gutenberg Server] get-media-by-id error:", s),
                new Error(`Error retrieving media by ID ${e}: ${s.message}`)
            }
        }
        ),
        t.tool("remove-background-from-image", "This tool removes the background from existing images in Gutenberg blocks, creating a transparent or clean background version. Use this when users want to remove the background from a photo, product image, or any image to isolate the main subject in a Gutenberg image block. The tool provides preview functionality before applying the changes and will automatically update the block with the processed image.", {
            imageUrl: a.string().url().describe("The URL of the existing image from the WordPress media library to remove background from. Must be a media library URL (containing /wp-content/uploads/). If you don't have the media library URL, ask the user to select an image element first so you have the correct context."),
            elementId: a.string().describe("ID of the Gutenberg block/element where the processed image should be applied"),
            platform: a.enum(["elementor", "gutenberg", "wordpress"]).describe("The platform where the image is located")
        }, async ({imageUrl: e, elementId: r, platform: o}) => {
            try {
                if (console.log("[Gutenberg Server] Processing background removal request for:", e),
                o !== "gutenberg")
                    throw new Error(`This tool can only be used on Gutenberg, please use the appropriate tool meant for ${o} instead`);
                Ye(e);
                const n = {
                    name: Se.REMOVE_BACKGROUND,
                    imageUrl: e,
                    elementId: r,
                    supportsPreview: !0
                }
                  , s = await xe(n);
                return console.log("[Gutenberg Server] Background removal result:", s),
                {
                    content: [{
                        type: "text",
                        text: JSON.stringify(s)
                    }]
                }
            } catch (n) {
                console.error("[Gutenberg Server] Error removing background:", n);
                const s = n instanceof Error ? n.message : String(n);
                throw new Error(s)
            }
        }
        ),
        t.tool("upscale-image", "This tool upscales and resizes existing images in Gutenberg blocks using AI to increase resolution and improve quality. Use this when users want to: upscale images, resize images to larger dimensions, enhance image quality, increase resolution, make images bigger/larger, scale up images, enlarge images, improve image sharpness, or change image size to specific dimensions. Supports any resolution from 512px to 2048px in 256px steps. The tool provides preview functionality before applying changes.", {
            imageUrl: a.string().url().describe("The URL of the existing image from the WordPress media library to upscale. Must be a media library URL (containing /wp-content/uploads/). If you don't have the media library URL, ask the user to select an image element first so you have the correct context."),
            elementId: a.string().describe("ID of the Gutenberg block/element where the upscaled image should be applied"),
            resolution: a.number().min(512).max(2048).describe("REQUIRED: The exact resolution for the upscaled image. Choose from: 512, 768, 1024, 1280, 1536, 1792, 2048. Higher resolutions create larger, more detailed images."),
            platform: a.enum(["elementor", "gutenberg", "wordpress"]).describe("The platform where the image is located")
        }, async ({imageUrl: e, elementId: r, resolution: o, platform: n}) => {
            try {
                if (console.log("[Gutenberg Server] Processing image upscale request for:", e),
                n !== "gutenberg")
                    throw new Error(`This tool can only be used on Gutenberg, please use the appropriate tool meant for ${n} instead`);
                Ye(e);
                const s = {
                    name: Se.UPSCALE_IMAGE,
                    imageUrl: e,
                    elementId: r,
                    resolution: o,
                    context: "gutenberg",
                    supportsPreview: !0
                }
                  , i = await xe(s);
                return console.log("[Gutenberg Server] Image upscale result:", i),
                {
                    content: [{
                        type: "text",
                        text: JSON.stringify(i)
                    }]
                }
            } catch (s) {
                console.error("[Gutenberg Server] Error upscaling image:", s);
                const i = s instanceof Error ? s.message : String(s);
                throw new Error(i)
            }
        }
        ),
        t.tool("assign-image-to-block", "Assigns an existing image URL to a Gutenberg block. Handles uploading the image to WordPress media library and updating the block attributes. Use this when you have a generated or processed image URL that needs to be applied to a specific Gutenberg image block.", {
            blockId: a.string().describe("ID of the Gutenberg block where the image should be assigned"),
            imageUrl: a.string().url().describe("URL of the image to assign to the block"),
            imageSize: a.enum(["full", "large", "medium", "thumbnail"]).optional().default("full").describe("Image size setting for Gutenberg display"),
            altText: a.string().optional().describe("Alt text for accessibility"),
            caption: a.string().optional().describe("Image caption for the block"),
            filename: a.string().optional().describe("Custom filename for the uploaded image"),
            title: a.string().optional().describe("Title for the media library entry")
        }, async ({blockId: e, imageUrl: r, imageSize: o="full", altText: n, caption: s, filename: i, title: l}) => {
            console.log("[Gutenberg Server] assign-image-to-block", {
                blockId: e,
                imageUrl: r
            });
            try {
                const d = await Rr({
                    imageUrl: r,
                    filename: i || "assigned-image.jpg",
                    title: l || "Assigned Image",
                    altText: n || "Assigned Image"
                });
                console.log("[Gutenberg Server] Image uploaded with ID:", d.id);
                const u = {
                    id: d.id,
                    url: d.url,
                    sizeSlug: o
                };
                n && (u.alt = n),
                s && (u.caption = s);
                const {data: g} = window.wp
                  , {dispatch: c} = g;
                return c("core/block-editor").updateBlockAttributes(e, u),
                console.log("[Gutenberg Server] Successfully assigned image to block:", e),
                {
                    content: [{
                        type: "text",
                        text: JSON.stringify({
                            success: !0,
                            blockId: e,
                            mediaId: d.id,
                            imageUrl: d.url,
                            imageSize: o,
                            altText: n,
                            caption: s,
                            message: "Image successfully assigned to Gutenberg block!"
                        })
                    }]
                }
            } catch (d) {
                throw console.error("[Gutenberg Server] Error assigning image:", d),
                new Error(`Failed to assign image to Gutenberg block: ${dinstanceof Error ? d.message : String(d)}`)
            }
        }
        ),
        t.tool("replace-background-from-image", "This tool replaces the background of existing images in Gutenberg blocks with a new AI-generated background based on a text prompt. Use this when users want to change or manipulate the background scene of a photo while keeping the main subject intact.", {
            imageUrl: a.string().url().describe("The URL of the existing image from the WordPress media library to replace the background of. Must be a media library URL (containing /wp-content/uploads/). If you don't have the media library URL, ask the user to select an image element first so you have the correct context."),
            backgroundPrompt: a.string().describe('A description of the new background to generate (e.g., "a beautiful sunset over mountains", "modern office space", "tropical beach")'),
            elementId: a.string().describe("ID of the Gutenberg block/element where the processed image should be applied"),
            platform: a.enum(["elementor", "gutenberg", "wordpress"]).describe("The platform where the image is located")
        }, async ({imageUrl: e, backgroundPrompt: r, elementId: o, platform: n}) => {
            try {
                if (console.log("[Gutenberg Server] Processing background replacement request for:", e),
                n !== "gutenberg")
                    throw new Error(`This tool can only be used on Gutenberg, please use the appropriate tool meant for ${n} instead`);
                Ye(e);
                const s = {
                    name: Se.REPLACE_BACKGROUND,
                    imageUrl: e,
                    backgroundPrompt: r,
                    elementId: o,
                    context: "gutenberg",
                    supportsPreview: !0
                }
                  , i = await xe(s);
                return console.log("[Gutenberg Server] Background replacement result:", i),
                {
                    content: [{
                        type: "text",
                        text: JSON.stringify(i)
                    }]
                }
            } catch (s) {
                console.error("[Gutenberg Server] Error replacing background:", s);
                const i = s instanceof Error ? s.message : String(s);
                throw new Error(i)
            }
        }
        ),
        t.tool("generate-variation-for-existing-image", `This tool transforms and modifies existing images based on user instructions. Use this when users want to change, modify, or transform an image they already have - whether they want style variations, color changes (like "make this black and white"), artistic transformations, or different creative interpretations of the same subject. This is the go-to tool for any image modification request where the user has an existing image and wants it altered in some way. The tool analyzes the original image and generates 4 different versions based on the user's prompt, maintaining the core subject while applying the requested changes. Users can then select their preferred version to replace the original image.`, {
            prompt: a.string().describe(`Instructions for how to modify the image based on what the user actually wants to achieve. Understand the user's intent and perspective - if they want something "grim and dark," describe the visual elements that create that feeling. The prompt should capture the essence of their request, not just repeat their exact words. Focus on translating their vision into clear visual directions for the image transformation.`),
            imageUrl: a.string().url().describe("The URL of the existing image from the WordPress media library to create variations from. Must be a media library URL (containing /wp-content/uploads/). If you don't have the media library URL, ask the user to select an image element first so you have the correct context."),
            elementId: a.string().describe("ID of the Gutenberg block/element where the processed image should be applied"),
            platform: a.enum(["elementor", "gutenberg", "wordpress"]).describe("The platform where the image is located")
        }, async ({imageUrl: e, elementId: r, prompt: o, platform: n}) => {
            try {
                if (console.log("[Gutenberg Server] Processing image variations request for:", e),
                n !== "gutenberg")
                    throw new Error(`This tool can only be used on Gutenberg, please use the appropriate tool meant for ${n} instead`);
                Ye(e);
                const s = {
                    name: Se.GENERATE_IMAGE_VARIATIONS,
                    imageUrl: e,
                    elementId: r,
                    prompt: o,
                    supportsPreview: !0,
                    context: "gutenberg"
                }
                  , i = await xe(s);
                return console.log("[Gutenberg Server] Image variations result:", i),
                {
                    content: [{
                        type: "text",
                        text: JSON.stringify(i)
                    }]
                }
            } catch (s) {
                console.error("[Gutenberg Server] Error generating image variations:", s);
                const i = s instanceof Error ? s.message : String(s);
                throw new Error(i)
            }
        }
        ),
        t.tool("isolate-object", "This tool isolates specific objects from images in Gutenberg blocks using AI. Use this when users want to isolate, extract, or separate the main subject or object from an image while removing or replacing the background. The tool allows choosing a background color. Supports variations to provide multiple options.", {
            imageUrl: a.string().url().describe("The URL of the existing image from the WordPress media library to process. Must be a media library URL (containing /wp-content/uploads/). If you don't have the media library URL, ask the user to select an image element first so you have the correct context."),
            backgroundColor: a.string().optional().describe('Background color for the isolated object (e.g., "#ffffff", "#000000"). Defaults to white if not specified.'),
            elementId: a.string().describe("ID of the Gutenberg block/element where the processed image should be applied"),
            platform: a.enum(["elementor", "gutenberg", "wordpress"]).describe("The platform where the image is located")
        }, async ({imageUrl: e, backgroundColor: r="#ffffff", elementId: o, platform: n}) => {
            try {
                if (console.log("[Gutenberg Server] Processing isolate object request for:", e),
                n !== "gutenberg")
                    throw new Error(`This tool can only be used on Gutenberg, please use the appropriate tool meant for ${n} instead`);
                Ye(e);
                const s = {
                    name: Se.ISOLATE_OBJECT,
                    imageUrl: e,
                    backgroundColor: r,
                    elementId: o,
                    context: "gutenberg",
                    supportsPreview: !0
                }
                  , i = await xe(s);
                return console.log("[Gutenberg Server] Isolate object result:", i),
                {
                    content: [{
                        type: "text",
                        text: JSON.stringify(i)
                    }]
                }
            } catch (s) {
                console.error("[Gutenberg Server] Error isolating object:", s);
                const i = s instanceof Error ? s.message : String(s);
                throw new Error(i)
            }
        }
        ),
        Yb(t),
        Kb(t),
        t
    }
    const nu = {
        _background_color: [{
            mandatory: "_background_background",
            default: "classic"
        }],
        _background_image: [{
            mandatory: "_background_background",
            default: "classic"
        }],
        _background_color_b: [{
            mandatory: "_background_background",
            default: "gradient"
        }],
        _background_gradient_type: [{
            mandatory: "_background_background",
            default: "gradient"
        }],
        _background_color_stop: [{
            mandatory: "_background_background",
            default: "gradient"
        }],
        _border_width: [{
            mandatory: "_border_border",
            default: "solid"
        }],
        _border_color: [{
            mandatory: "_border_border",
            default: "solid"
        }],
        background_overlay_color: [{
            mandatory: "background_overlay_background",
            default: "classic"
        }],
        background_overlay_image: [{
            mandatory: "background_overlay_background",
            default: "classic"
        }],
        background_overlay_color_b: [{
            mandatory: "background_overlay_background",
            default: "gradient"
        }]
    };
    async function eS(t, e, r, o) {
        var g, c, m, p, h, f, y;
        const n = (p = (m = (c = (g = window.elementor) == null ? void 0 : g.widgetsCache) == null ? void 0 : c[r]) == null ? void 0 : m.controls) == null ? void 0 : p[e]
          , s = (f = (h = t.settings) == null ? void 0 : h.attributes) == null ? void 0 : f[e];
        let i = ((y = s == null ? void 0 : s.models) == null ? void 0 : y.length) ?? 0;
        const l = {}
          , d = [];
        for (Object.keys(n.fields ?? {}).forEach(b => {
            var v;
            const x = (v = n == null ? void 0 : n.fields) == null ? void 0 : v[b];
            l[b] = (x == null ? void 0 : x.default) || ""
        }
        ),
        o[e].forEach(b => {
            const x = {};
            Object.keys(l).forEach(v => {
                x[v] = b[v] ?? l[v]
            }
            ),
            x._id = window.elementorCommon.helpers.getUniqueId(),
            window.$e.run("document/repeater/insert", {
                container: t,
                name: e,
                model: x
            }),
            d.push(x)
        }
        ); i--; )
            await window.$e.run("document/repeater/remove", {
                container: t,
                name: e,
                index: 0
            });
        return d
    }
    function tS(t) {
        const e = {};
        return Object.keys(t).forEach(r => {
            const o = nu[r];
            o == null || o.forEach(n => {
                t[n.mandatory] || (t[n.mandatory] = n.default,
                e[n.mandatory] = n.default)
            }
            )
        }
        ),
        e
    }
    function ou() {
        return Object.keys(window.elementor.selection.elements) || []
    }
    async function su(t) {
        if (t)
            try {
                await window.$e.run("document/elements/select", {
                    container: window.elementor.getContainer(t)
                })
            } catch (e) {
                console.warn("Unable to restore selection:", e)
            }
    }
    function rS(t) {
        const e = {};
        for (const [r,o] of Object.entries(t))
            typeof o == "string" && o.startsWith("globals/") ? e[r] = o : r.includes("typography") ? e[r] = `globals/typography?id=${o}` : e[r] = `globals/colors?id=${o}`;
        return e
    }
    async function ci(t, e) {
        const r = {}
          , o = await window.$e.data.get("globals/colors")
          , n = await window.$e.data.get("globals/typography");
        if (Object.keys(t).forEach(s => {
            const i = t[s];
            if (typeof i == "string" && i)
                if (o.data[i] || n.data[i])
                    r[s] = i;
                else {
                    const l = Object.keys(o.data).find(u => {
                        var g;
                        return ((g = o.data[u]) == null ? void 0 : g.value) === i
                    }
                    )
                      , d = Object.keys(n.data).find(u => {
                        const g = n.data[u];
                        return g && JSON.stringify(g.value) === JSON.stringify(i)
                    }
                    );
                    l ? r[s] = l : d && (r[s] = d)
                }
        }
        ),
        Object.keys(r).forEach(s => {
            delete t[s]
        }
        ),
        Object.keys(r).length > 0) {
            const s = window.elementor.getContainer(e);
            if (s) {
                const i = rS(r);
                await window.$e.run("document/globals/enable", {
                    container: s,
                    settings: i
                })
            }
        }
        return r
    }
    function nS() {
        return new URLSearchParams(window.location.search).get("elementor-mcp") !== "old"
    }
    function kt(t) {
        return JSON.stringify(t).replaceAll('"', "'")
    }
    function au(t) {
        const e = window.elementor.getContainer(t);
        if (!e)
            throw new Error(`Container with ID ${t} not found.`);
        return e.model.attributes.widgetType ?? "container"
    }
    let zt = {
        sessionId: void 0,
        context: {}
    }
      , iu = !1;
    function oS() {
        iu || (window.addEventListener("message", t => {
            if (t.data.type === "CHAT_CONTEXT_UPDATE") {
                const e = t.data.payload
                  , r = e.sessionId;
                zt.sessionId !== r && r ? sS(e) : zt = {
                    ...zt,
                    sessionId: r,
                    context: {
                        ...zt.context,
                        ...e.context || {}
                    }
                }
            }
        }
        ),
        iu = !0)
    }
    function sS(t) {
        zt = {
            sessionId: t.sessionId,
            context: t.context || {}
        }
    }
    oS();
    const aS = () => ({
        ...zt
    })
      , Hn = (t, e) => {
        zt.context || (zt.context = {}),
        zt.context[t] = e
    }
      , Vn = t => {
        var e;
        return ((e = zt.context) == null ? void 0 : e[t]) !== void 0
    }
    ;
    function iS() {
        var n, s, i;
        const t = (s = (n = window.elementor) == null ? void 0 : n.documents) == null ? void 0 : s.getCurrent();
        if (!t)
            return {
                error: "No active document found"
            };
        function e(l) {
            if (!l || !l.model)
                return null;
            const d = l.model.attributes
              , u = {
                id: d.id,
                elType: d.elType,
                widgetType: d.widgetType || void 0
            };
            return d.title && (u.title = d.title),
            l.children && l.children.length > 0 && (u.children = l.children.map(g => e(g)).filter(g => g !== null)),
            u
        }
        const o = t.container.children.map(l => e(l));
        return {
            documentId: t.id,
            documentType: t.config.type,
            title: ((i = t.config.settings) == null ? void 0 : i.post_title) || "Untitled",
            elements: o.filter(l => l !== null)
        }
    }
    function lS(t) {
        const e = window.elementor.getContainer(t);
        if (!e)
            throw new Error(`Container with ID ${t} not found.`);
        const r = e.settings.attributes || {}
          , o = e.model.attributes || {}
          , n = {}
          , s = ["settings", "editSettings", "defaultEditSettings"];
        return Object.keys({
            ...r,
            ...o
        }).forEach(i => {
            const l = r[i]
              , d = o[i]
              , u = l !== void 0 ? l : d;
            !s.includes(i) && typeof u != "function" && !(u && typeof u == "object" && u.constructor && u.constructor.name.includes("Model")) && (n[i] = u)
        }
        ),
        n
    }
    function di(t) {
        return !t || typeof t != "object" ? {} : Object.fromEntries(Object.entries(t).filter( ([,e]) => e.type !== "section" && e.type !== "tab").map( ([e,r]) => {
            let o;
            r.options ? o = Object.keys(r.options) : r.return_value && (o = [r.return_value, ""]);
            let n;
            return r.fields && (n = di(r.fields)),
            [e, {
                type: r.type,
                options: o,
                default: r.default,
                fields: n,
                size_units: r.size_units,
                range: r.range
            }]
        }
        ))
    }
    function cS(t) {
        const e = window.elementor.documents.get(t);
        if (!e)
            return;
        const r = e.config.controls;
        return di(r)
    }
    function ui(t) {
        var r;
        const e = (r = window.elementor.widgetsCache[t]) == null ? void 0 : r.controls;
        return di(e)
    }
    function mi(t) {
        const e = ui(t);
        if (!e)
            return;
        const r = `loadedElementTypeSchema_${t}`;
        return Hn(r, !0),
        e
    }
    function lu(t) {
        const e = `loadedElementTypeSchema_${t}`;
        return Vn(e)
    }
    function dS(t) {
        const e = lS(t);
        if (!e)
            return;
        const r = `loadedElementSettings_${t}`;
        return Hn(r, !0),
        e
    }
    function uS(t) {
        const e = `loadedElementSettings_${t}`;
        return Vn(e)
    }
    function mS() {
        const t = iS();
        return t ? (Hn("pageOverviewLoaded", !0),
        t) : void 0
    }
    function pS() {
        return Vn("pageOverviewLoaded")
    }
    function hS(t) {
        if (lu(t))
            return "";
        const e = mi(t);
        if (!e)
            throw new Error(`Element schema for ${t} not found.`);
        let r = "", o;
        if (lu("common") || (o = mi("common"),
        r += `**Common schema for all widgets:**

 ${kt(o)}

`),
        o || (o = ui("common")),
        !o)
            throw new Error("Common element schema not found.");
        const n = {};
        return Object.keys(e).forEach(s => {
            (!o[s] || JSON.stringify(o[s]) !== JSON.stringify(e[s])) && (n[s] = e[s])
        }
        ),
        r += `**ELEMENT SCHEMA for type ${t}:**

 ${kt(n)}

`,
        r
    }
    function gS(t) {
        if (t === "document")
            throw new Error(`Document-level settings should be retrieved using the 'page' tool with action 'get-settings' or 'get-overview', not the elements tool. The elementId '${t}' refers to the document/page, not an individual element. Please use a specific element ID instead, or use: page tool with action 'get-settings' for document-level information.`);
        const e = cu(t);
        return e ? `**ELEMENT SETTINGS for element ${t}:**

 ${e}

` : ""
    }
    function fS() {
        if (pS())
            return "";
        const t = mS();
        if (!t)
            throw new Error("Page overview not found.");
        return `**PAGE OVERVIEW:**

 ${kt(t)}

`
    }
    function yS(t) {
        var o, n, s;
        const e = (n = (o = window.elementor) == null ? void 0 : o.documents) == null ? void 0 : n.get(t);
        if (!e)
            return;
        const r = `documentSettings_${t}`;
        return Hn(r, !0),
        ((s = e.config) == null ? void 0 : s.settings) || {}
    }
    function vS(t) {
        if (ES(t))
            return "";
        const e = yS(t);
        if (!e)
            throw new Error("Document settings not found.");
        return `**DOCUMENT SETTINGS:**

 ${kt(e)}

`
    }
    function wS(t) {
        const e = cS(t);
        if (!e)
            return;
        const r = `documentSchema_${t}`;
        return Hn(r, !0),
        e
    }
    function bS(t) {
        if (SS(t))
            return "";
        const e = wS(t);
        if (!e)
            throw new Error("Document schema not found.");
        return `**DOCUMENT SCHEMA:**

 ${kt(e)}

`
    }
    function SS(t) {
        const e = `documentSchema_${t}`;
        return Vn(e)
    }
    function ES(t) {
        const e = `documentSettings_${t}`;
        return Vn(e)
    }
    function bs({types: t=[], elementIds: e=[], documentId: r="", onlyContexts: o=[]}) {
        const n = !o.length || o.includes("page")
          , s = !o.length || o.includes("schema")
          , i = !o.length || o.includes("settings")
          , l = o.includes("document");
        let d = "";
        if (n && (d += fS()),
        l && (d += bS(r),
        d += vS(r)),
        e.length && s)
            for (const u of e) {
                const g = au(u);
                t.includes(g) || t.push(g)
            }
        if (t.length && s)
            for (const u of t)
                d += hS(u);
        if (e.length && i)
            for (const u of e)
                d += gS(u);
        return d ? `Before proceeding with your request, here is the information you need:

${d}` : ""
    }
    function cu(t, e=!1) {
        if (!e && uS(t))
            return "";
        const r = dS(t);
        if (!r)
            throw new Error(`Element settings for ${t} not found.`);
        const o = au(t)
          , n = mi(o);
        if (!n)
            throw new Error(`Element schema for ${o} not found.`);
        const s = ui("common");
        if (!s)
            throw new Error("Common elements schema not found.");
        const i = {
            ...s,
            ...n
        };
        return Object.keys(r).forEach(l => {
            var d;
            JSON.stringify(r[l]) === JSON.stringify(((d = i[l]) == null ? void 0 : d.default) ?? "") && delete r[l]
        }
        ),
        kt(r)
    }
    const xS = 'IMPORTANT: Always use existing global style names (like "primary", "secondary", etc.) when they are close enough to the intended value, name, or meaning  even if not exact. Only create a new value if no suitable global exists.';
    function _S(t) {
        t.tool("elements", `This tool manages individual Elementor elements (widgets and containers).

		**IMPORTANT: When NOT to use this tool:**
			- When you need to get or update page settings (like page title, page description, page keywords, etc), you MUST use the 'elementor__page' tool instead.
			- When the user requests a complete page or section design
			- When the user requests standard sections (About, Hero, Testimonials, Pricing, FAQ, Gallery, Contact, etc.)
			- When the user describes both layout and content intent together ("3-column team section", "section with service boxes")
			- When the user wants AI to generate complete sections instead of building element by element
			- When managing Copilot-generated layout suggestions

		For these scenarios, use the 'copilot' tool instead.

		**When to use this tool:**

		Use this tool to create, update, delete, duplicate, copy, paste, and select individual elements, as well as manage their settings and styles. 
		You can also use this tool to remove global styles from elements when needed.
		This tool includes powerful AI text generation features for creating high-quality, contextually appropriate content.

		Elements Schema:
			You can use the 'get-widget-schema' action to retrieve the schema for a widget type.
 
			When asked to create a nested widget (like nested-tabs) and insert widgets inside its child containers, do the following step by step:
				1. Call the 'get-widget-schema' action to retrieve the schema for the parent widget type if not already done.
				2. Create the parent widget (e.g., "nested-tabs"). This automatically creates child containers (e.g., individual tab containers).
				3. Retrieve the IDs of the automatically created child containers from the creation response.
				4. Call the 'get-widget-schema' action to retrieve the schema for the nested widget type if not already done.
				4. Use 'create-widget' action to create the desired widgets inside the specific child containers, setting 'parentId' to the appropriate child container ID.
				
			Note: Nested elements in Elementor follow this structure:
				- Parent widget (e.g., nested-tabs)
				- Child containers (automatically created, each representing a tab/section)
				- Nested widgets (unlimited widgets can be placed inside each child container)

		CONSTRAINTS:
			Before creating a widget of a certain type for the first time, you MUST call this tool with a 'get-widget-schema' action to retrieve its schema.
			Before you create, update or delete an element, always refer to the Page Overview to ensure you know the page structure. 
			You can only update settings for an existing element. 
			Always use the most relevant Elementor widget type for the user's request instead of creating HTML tags or generic markup.
			Use \`widgetSettings\` parameter when working on a widget. Use \`containerSettings\` parameter when working on a container. Be careful! do NOT send containerSettings for widgets!
			When the user want to link/enable/update global styles for an element, only use existing global style names (like "primary", "secondary", etc.). DO NOT use vars or explicit values.
			When the user want to remove global styles from an element, choose only available settings from within the '__globals__' object under the element settings and send them in the 'globalSettings' parameter with the 'remove-global-styles' action.
			To remove repeater item(s), use the update-settings action and provide only the items that should remain.

		TEXT GENERATION RULES:
			PREFER using \`textGenerationSettings\` for ANY text-related requests to ensure high-quality, contextually appropriate content.

			USE \`textGenerationSettings\` when:
				1. User requests text to be written, created, or generated (e.g., "add a compelling headline", "write a description", "create a call-to-action")
				2. User wants text that should match a specific tone, style, or purpose (e.g., "professional bio", "engaging introduction", "persuasive button text")
				3. User asks for content without providing exact wording (e.g., "add a heading about our services", "create welcome text")
				4. Text needs to be contextually relevant to the website/business/audience
			
			textGenerationSettings format (keys MUST be valid widget setting names):
			{
				"valid_widget_setting_name": "detailed prompt describing what text to generate, including context, tone, and purpose",
				"another_valid_setting": "another generation prompt with specific requirements"
			}
			
			Examples that SHOULD use textGenerationSettings:
			- "Add a headline about our services"  textGenerationSettings: { "title": "Create a compelling headline about our services that highlights our expertise and attracts potential customers" }
			- "Create a welcome message"  textGenerationSettings: { "title": "Write a warm, welcoming message for website visitors that makes them feel valued" }
			- "Add a call-to-action button"  textGenerationSettings: { "text": "Create persuasive call-to-action text that encourages users to contact us or learn more" }
			- "Write a description for this section"  textGenerationSettings: { "description": "Write an engaging description for this section that explains the benefits clearly and motivates action" }
			
			ONLY use direct text in widgetSettings/containerSettings when:
			- User provides exact, specific text (e.g., "Add a heading that says 'Welcome to our site'")
			- User gives you the precise wording they want used verbatim
		ICONS:
			You MUST use only Font Awesome icons from version 5.15.4 with pattern "fab|far|fas fa-{{icon name}}".`, {
            action: a.enum(["get-widget-schema", "get-widget-settings", "create-widget", "create-container", "update-settings", "delete", "duplicate", "copy", "copy-all", "paste", "paste-style", "paste-area", "select", "deselect", "deselect-all", "select-all", "select-multiple", "toggle-selection", "move", "empty-container", "import", "reset-style", "reset-settings", "get-current-selection", "remove-global-styles"]).describe("The element operation to perform."),
            elementId: a.string().optional().describe("The ID of the target element"),
            elementIds: a.array(a.string()).optional().describe("Array of element IDs for multi-element operations"),
            widgetType: a.string().optional().describe('The type of widget to create. Must be one of the "availableWidgetTypes" list (required for create-widget and get-widget-schema actions)'),
            widgetSettings: a.record(a.any()).optional().describe("Widget settings to set when creating or updating a widget. MUST be one or more valid widget settings with exact keys only from the ELEMENT SCHEMA of this widget type or from the Common schema. " + xS),
            globalSettings: a.record(a.any()).optional().describe("Global settings to use when removing global styles from an element. Use only settings from within the `__globals__` object under the element settings. Required for remove-global-styles action."),
            containerSettings: a.record(a.any()).optional().describe("Container settings to set when creating or updating a container. MUST be one or more valid container settings according to the containerConfigStructure."),
            textGenerationSettings: a.record(a.string(), a.string()).optional().describe('PREFERRED for text content creation. CRITICAL: Keys MUST be valid widget setting names from the widget type configuration. Do NOT use arbitrary key names. Value = detailed generation prompt with context and requirements. Example: {"title": "Create a compelling headline for a restaurant website that emphasizes fresh ingredients and family atmosphere"}'),
            parentId: a.string().optional().describe('Parent container ID for element creation. If the parent ID is unknown, send "document" instead.'),
            targetId: a.string().optional().describe("Target element ID for move operations"),
            position: a.enum(["before", "after", "inside"]).optional().describe("Position relative to target for move operations")
        }, {
            title: "Manage Elements"
        }, async e => {
            const r = e.elementId ? [e.elementId] : e.elementIds || []
              , o = []
              , n = ["create-widget", "create-container", "update-settings", "remove-global-styles"]
              , s = ["get-widget-settings", "get-widget-schema"];
            if (e.widgetType && o.push(e.widgetType),
            (o.length || r.length || e.action === "create-container") && !s.includes(e.action)) {
                e.action === "create-container" && o.push("container");
                let i;
                n.includes(e.action) && (i = {
                    types: o,
                    elementIds: r
                });
                const l = bs(i || {});
                if (l)
                    throw new Error(l)
            }
            switch (e.action) {
            case "get-widget-schema":
                return await TS(e);
            case "get-widget-settings":
                return await PS(e);
            case "create-widget":
                return await kS(e, t);
            case "create-container":
                return await IS(e);
            case "update-settings":
                return await CS(e, t);
            case "get-settings":
                return await $S(e);
            case "delete":
                return await AS(e);
            case "duplicate":
                return await RS(e);
            case "copy":
                return await OS(e);
            case "copy-all":
                return await DS();
            case "paste":
                return await NS(e);
            case "paste-style":
                return await LS(e);
            case "paste-area":
                return await US(e);
            case "select":
                return await jS(e);
            case "deselect":
                return await MS(e);
            case "deselect-all":
                return await FS();
            case "select-all":
                return await WS(e);
            case "select-multiple":
                return await qS(e);
            case "toggle-selection":
                return await GS(e);
            case "move":
                return await BS(e);
            case "empty-container":
                return await zS(e);
            case "import":
                return await ZS(e);
            case "reset-style":
                return await HS(e);
            case "reset-settings":
                return await VS(e);
            case "get-current-selection":
                return await JS();
            case "remove-global-styles":
                return await YS(e);
            default:
                throw new Error(`Unknown action: ${e.action}`)
            }
        }
        )
    }
    async function TS(t) {
        const e = t.widgetType;
        if (!e)
            throw new Error("widgetType is required for get-widget-schema action");
        let r = bs({
            types: [e],
            onlyContexts: ["schema", "page"]
        });
        return r || (r = `You already have the required schema context for widget type "${e}". Refer to the conversation history for more information.`),
        {
            content: [{
                type: "text",
                text: r
            }]
        }
    }
    async function PS(t) {
        const e = t.elementId;
        if (!e)
            throw new Error("elementId is required for get-widget-settings action");
        let r = cu(e, !0);
        return r || (r = `You already have the required context for element "${e}". Refer to the conversation history for more information.`),
        {
            content: [{
                type: "text",
                text: r
            }]
        }
    }
    async function kS(t, e) {
        var y, b, x, v, S;
        const r = t.widgetType
          , o = ((y = window.elementor) == null ? void 0 : y.widgetsCache) || {};
        if (!o[r]) {
            const w = Object.keys(o);
            throw new Error(`Widget type "${r}" is not available. Available widget types: ${w.slice(0, 10).join(", ")}${w.length > 10 ? ` (and ${w.length - 10} more)` : ""}`)
        }
        if (!!!((x = (b = window.angieConfig) == null ? void 0 : b.plugins) != null && x.elementor_pro) && Object.keys(window.elementor.widgetsCache).filter(_ => {
            var k, C;
            const I = window.elementor.widgetsCache[_];
            return ((k = I.categories) == null ? void 0 : k.includes("pro-elements")) || ((C = I.categories) == null ? void 0 : C.includes("woocommerce-elements"))
        }
        ).includes(r))
            throw new Error(`Widget "${r}" is not available in this plan. Please upgrade to the Pro plan to use this widget.`);
        let s = t.widgetSettings || {};
        const i = await du(t.textGenerationSettings, e);
        s = {
            ...s,
            ...i
        };
        const l = {
            elType: "widget",
            widgetType: r,
            settings: s
        }
          , d = ou()[0];
        let u = t.parentId ? window.elementor.getContainer(t.parentId) : window.elementor.getPreviewContainer();
        if (!u && !t.parentId)
            throw new Error("Preview container is not available");
        if (!u || u.id === "document" || ((S = (v = u.model) == null ? void 0 : v.attributes) == null ? void 0 : S.elType) === "document") {
            console.log("[Elementor Server] Widget cannot be created directly in document, creating container first...");
            const w = {
                elType: "container",
                settings: {
                    content_width: "boxed",
                    flex_direction: "row",
                    flex_wrap: "wrap"
                }
            }
              , _ = await window.$e.run("document/elements/create", {
                container: u,
                model: w,
                options: {}
            });
            if (_ === !1)
                throw new Error("Failed to create container for widget. Cannot create widgets directly in the document.");
            const I = _
              , k = Array.isArray(I) ? I.map(C => C == null ? void 0 : C.id).filter(Boolean) : [I == null ? void 0 : I.id].filter(Boolean);
            if (k.length === 0 || !k[0])
                throw new Error("Failed to get ID of created container.");
            u = window.elementor.getContainer(k[0])
        }
        const g = await window.$e.run("document/elements/create", {
            container: u,
            model: l
        });
        if (g === !1)
            throw new Error(`Failed to create widget of type "${r}". This usually happens when: 1) The widget type is invalid, 2) The parent container is not suitable for this widget, 3) Required settings are missing, or 4) Elementor validation failed. Check the browser console for more details.`);
        const m = (Array.isArray(g) ? g : [g]).map(uu);
        await su(d);
        const p = await ci(s, m[0].id)
          , h = aS()
          , f = t.textGenerationSettings && Object.keys(t.textGenerationSettings).length > 0;
        return m.length && bs({
            elementIds: m.map(w => w.id)
        }),
        {
            content: [{
                type: "text",
                text: `Widget "${r}" created in the following structure: ${kt(m)}${f ? " (with AI-generated text content)" : ""}${p && Object.keys(p).length > 0 ? " (with global styles applied)" : ""}${h.sessionId ? ` (Session: ${h.sessionId})` : ""}`
            }]
        }
    }
    async function IS(t) {
        const e = {
            elType: "container",
            settings: t.containerSettings || {}
        }
          , r = ou()[0]
          , o = t.parentId ? window.elementor.getContainer(t.parentId) : window.elementor.getPreviewContainer()
          , n = await window.$e.run("document/elements/create", {
            container: o,
            model: e
        });
        if (n === !1)
            throw new Error("Failed to create container. Ensure that the parameters are correct.");
        const s = n
          , i = Array.isArray(s) ? s.map(d => d == null ? void 0 : d.id).filter(Boolean) : [s == null ? void 0 : s.id].filter(Boolean);
        await su(r);
        const l = await ci(t.containerSettings || {}, i[0] ?? "");
        return {
            content: [{
                type: "text",
                text: `Container created with ID: ${i.join(", ")}${l && Object.keys(l).length > 0 ? " (with global styles applied)" : ""}`
            }]
        }
    }
    async function CS(t, e) {
        var p, h;
        const r = t.elementId;
        if (!r)
            throw new Error("elementId is required for update-settings action");
        if (r === "document")
            throw ((h = (p = window.elementor) == null ? void 0 : p.documents) == null ? void 0 : h.getCurrent()) ? new Error(`Document-level settings should be updated using the 'elementor__page' tool with action 'update-settings', not the elements tool. The elementId '${t.elementId}' refers to the document/page, not an individual element. Please use a specific element ID instead, or use: page tool with action 'update-settings' and your settings object for document-level operations.`) : new Error("No active document found for document-level settings update.");
        const o = window.elementor.getContainer(r);
        if (!o)
            throw new Error(`Element with ID ${r} not found. Make sure you're using a valid element ID, not 'document' or other reserved keywords.`);
        const n = o.model.attributes.widgetType
          , s = n && n !== "document" && n !== "container";
        let i = (s ? t.widgetSettings : t.containerSettings) || {};
        const l = await du(t.textGenerationSettings, e);
        if (i = {
            ...i,
            ...l
        },
        !i || Object.keys(i).length === 0)
            throw new Error("no settings provided for update-settings action");
        const d = tS(i) || {}
          , u = {};
        s && Object.keys(i).forEach(async f => {
            const b = window.elementor.widgetsCache[n].controls[f].type;
            if (["repeater", "nested-elements-repeater", "form-fields-repeater"].includes(b)) {
                const v = await eS(o, f, n, i);
                u[f] = v,
                delete i[f]
            }
        }
        );
        const g = await ci(i, r);
        Object.keys(i).length && window.$e.run("document/elements/settings", {
            container: o,
            settings: i,
            options: {
                external: !0,
                render: !0
            }
        }),
        window.elementorFrontend.elements.$body.resize();
        const c = t.textGenerationSettings && Object.keys(t.textGenerationSettings).length > 0;
        let m = `The following settings were updated for element ${t.elementId}${c ? " (including AI-generated text content)" : ""}:

${kt(i)}`;
        return d && Object.keys(d).length && (m += `
Note: The following mandatory fields were added: ${kt(d)}`),
        Object.keys(g).length && (m += `
Global styles applied: ${kt(g)}`),
        Object.keys(u).length && (m += `
The following repeater items were inserted: ${kt(u)}`),
        {
            content: [{
                type: "text",
                text: m
            }]
        }
    }
    async function $S(t) {
        if (!t.elementId)
            throw new Error("elementId is required for get-settings action");
        if (t.elementId === "document")
            throw new Error(`Document-level settings should be retrieved using the 'page' tool with action 'get-settings' or 'get-overview', not the elements tool. The elementId '${t.elementId}' refers to the document/page, not an individual element. Please use a specific element ID instead, or use: page tool with action 'get-settings' for document-level information.`);
        return {
            content: [{
                type: "text",
                text: "Refer to the conversation and context so far to get the settings of this element"
            }]
        }
    }
    async function AS(t) {
        if (!t.elementId && !t.elementIds)
            throw new Error("elementId or elementIds is required for delete action");
        const e = t.elementIds || [t.elementId]
          , r = e.map(o => window.elementor.getContainer(o)).filter(Boolean);
        return window.$e.run("document/elements/delete", {
            containers: r
        }),
        {
            content: [{
                type: "text",
                text: `Element(s) ${e.join(", ")} deleted successfully.`
            }]
        }
    }
    async function RS(t) {
        if (!t.elementId && !t.elementIds)
            throw new Error("elementId or elementIds is required for duplicate action");
        const e = t.elementIds || [t.elementId]
          , r = e.map(o => window.elementor.getContainer(o)).filter(Boolean);
        return window.$e.run("document/elements/duplicate", {
            containers: r
        }),
        {
            content: [{
                type: "text",
                text: `Element(s) ${e.join(", ")} duplicated successfully.`
            }]
        }
    }
    async function OS(t) {
        if (!t.elementId)
            throw new Error("elementId is required for copy action");
        const e = window.elementor.getContainer(t.elementId);
        return e ? (window.$e.run("document/elements/copy", {
            container: e
        }),
        {
            content: [{
                type: "text",
                text: `Element ${t.elementId} copied to clipboard.`
            }]
        }) : {
            content: [{
                type: "text",
                text: `Element with ID ${t.elementId} not found.`
            }]
        }
    }
    async function DS() {
        return window.$e.run("document/elements/copy-all"),
        {
            content: [{
                type: "text",
                text: "All elements copied to clipboard."
            }]
        }
    }
    async function NS(t) {
        const e = t.elementId ? window.elementor.getContainer(t.elementId) : window.elementor.getPreviewContainer();
        return window.$e.run("document/elements/paste", {
            container: e
        }),
        {
            content: [{
                type: "text",
                text: `Element(s) pasted successfully${t.elementId ? ` into ${t.elementId}` : ""}.`
            }]
        }
    }
    async function LS(t) {
        if (!t.elementId)
            throw new Error("elementId is required for paste-style action");
        const e = window.elementor.getContainer(t.elementId);
        if (!e)
            throw new Error(`Element with ID ${t.elementId} not found.`);
        return window.$e.run("document/elements/paste-style", {
            container: e
        }),
        {
            content: [{
                type: "text",
                text: `Style pasted to element ${t.elementId}.`
            }]
        }
    }
    async function US(t) {
        if (!t.elementId)
            throw new Error("elementId is required for paste-area action");
        const e = window.elementor.getContainer(t.elementId);
        if (!e)
            throw new Error(`Element with ID ${t.elementId} not found.`);
        return window.$e.run("document/elements/paste-area", {
            container: e
        }),
        {
            content: [{
                type: "text",
                text: `Area content pasted into element ${t.elementId}.`
            }]
        }
    }
    async function jS(t) {
        if (!t.elementId)
            throw new Error("elementId is required for select action");
        const e = window.elementor.getContainer(t.elementId);
        if (!e)
            throw new Error(`Element with ID ${t.elementId} not found.`);
        return window.$e.run("document/elements/select", {
            container: e
        }),
        {
            content: [{
                type: "text",
                text: `Element ${t.elementId} selected.`
            }]
        }
    }
    async function MS(t) {
        if (!t.elementId)
            throw new Error("elementId is required for deselect action");
        const e = window.elementor.getContainer(t.elementId);
        if (!e)
            throw new Error(`Element with ID ${t.elementId} not found.`);
        return window.$e.run("document/elements/deselect", {
            container: e
        }),
        {
            content: [{
                type: "text",
                text: `Element ${t.elementId} deselected.`
            }]
        }
    }
    async function FS() {
        return window.$e.run("document/elements/deselect-all"),
        {
            content: [{
                type: "text",
                text: "All elements deselected."
            }]
        }
    }
    async function WS(t) {
        const e = t.elementId ? window.elementor.getContainer(t.elementId) : window.elementor.getPreviewContainer();
        return window.$e.run("document/elements/select-all", {
            container: e
        }),
        {
            content: [{
                type: "text",
                text: `All elements selected${t.elementId ? ` in ${t.elementId}` : ""}.`
            }]
        }
    }
    async function qS(t) {
        if (!t.elementIds || !Array.isArray(t.elementIds))
            throw new Error("elementIds array is required for select-multiple action");
        const e = t.elementIds.map(r => window.elementor.getContainer(r)).filter(Boolean);
        for (const r of e)
            window.$e.run("document/elements/select", {
                container: r
            });
        return {
            content: [{
                type: "text",
                text: `Elements ${t.elementIds.join(", ")} selected.`
            }]
        }
    }
    async function GS(t) {
        if (!t.elementId)
            throw new Error("elementId is required for toggle-selection action");
        const e = window.elementor.getContainer(t.elementId);
        if (!e)
            throw new Error(`Element with ID ${t.elementId} not found.`);
        return window.$e.run("document/elements/toggle-selection", {
            container: e
        }),
        {
            content: [{
                type: "text",
                text: `Element ${t.elementId} selection toggled.`
            }]
        }
    }
    async function BS(t) {
        if (!t.elementId || !t.targetId || !t.position)
            throw new Error("elementId, targetId, and position are required for move action");
        const e = t.elementId
          , r = t.targetId
          , o = t.position
          , n = window.elementor.getContainer(e);
        if (!n)
            throw new Error(`Element with ID ${e} not found.`);
        const s = window.elementor.getContainer(r);
        if (!s)
            throw new Error(`Target element with ID ${r} not found.`);
        if (o === "inside") {
            const m = s
              , p = {
                container: n,
                target: m,
                options: {
                    container: m
                }
            };
            return await window.$e.run("document/elements/move", p),
            {
                content: [{
                    type: "text",
                    text: `Element ${e} moved ${o} element ${r}.`
                }]
            }
        }
        const l = s.parent;
        if (!l)
            throw new Error(`Target element (ID ${r}) has no parent container.`);
        const u = (Array.isArray(l.children) ? l.children : []).findIndex(m => m.id === r);
        if (u === -1)
            throw new Error(`Target element (ID ${r}) not found within its parent.`);
        const g = o === "before" ? u : u + 1
          , c = {
            container: n,
            target: l,
            options: {
                at: g,
                container: l
            }
        };
        return await window.$e.run("document/elements/move", c),
        {
            content: [{
                type: "text",
                text: `Element ${e} moved ${o} element ${r}.`
            }]
        }
    }
    async function zS(t) {
        if (!t.elementId)
            throw new Error("elementId is required for empty-container action");
        const e = window.elementor.getContainer(t.elementId);
        if (!e)
            throw new Error(`Element with ID ${t.elementId} not found.`);
        return window.$e.run("document/elements/empty", {
            container: e
        }),
        {
            content: [{
                type: "text",
                text: `Container ${t.elementId} emptied.`
            }]
        }
    }
    async function ZS(t) {
        if (!t.settings)
            throw new Error("settings is required for import action");
        const e = t.elementId ? window.elementor.getContainer(t.elementId) : window.elementor.getPreviewContainer();
        return window.$e.run("document/elements/import", {
            container: e,
            model: t.settings
        }),
        {
            content: [{
                type: "text",
                text: `Elements imported successfully${t.elementId ? ` into ${t.elementId}` : ""}.`
            }]
        }
    }
    async function HS(t) {
        if (!t.elementId)
            throw new Error("elementId is required for reset-style action");
        const e = window.elementor.getContainer(t.elementId);
        if (!e)
            throw new Error(`Element with ID ${t.elementId} not found.`);
        return window.$e.run("document/elements/reset-style", {
            container: e
        }),
        {
            content: [{
                type: "text",
                text: `Element ${t.elementId} style reset.`
            }]
        }
    }
    async function VS(t) {
        if (!t.elementId)
            throw new Error("elementId is required for reset-settings action");
        const e = window.elementor.getContainer(t.elementId);
        if (!e)
            throw new Error(`Element with ID ${t.elementId} not found.`);
        return window.$e.run("document/elements/reset-settings", {
            container: e
        }),
        {
            content: [{
                type: "text",
                text: `Element ${t.elementId} settings reset.`
            }]
        }
    }
    async function JS() {
        var t, e;
        try {
            const r = window.elementor
              , o = ((e = (t = r == null ? void 0 : r.selection) == null ? void 0 : t.getSelectedChildren) == null ? void 0 : e.call(t)) || [];
            if (o.length === 0)
                return {
                    content: [{
                        type: "text",
                        text: "No elements currently selected."
                    }]
                };
            const n = o.map(s => {
                const i = s.model.attributes;
                return {
                    id: i.id,
                    elType: i.elType,
                    widgetType: i.widgetType || void 0
                }
            }
            );
            return {
                content: [{
                    type: "text",
                    text: JSON.stringify({
                        count: o.length,
                        selected: n
                    }, null, 2)
                }]
            }
        } catch {
            return {
                content: [{
                    type: "text",
                    text: "Unable to get current selection."
                }]
            }
        }
    }
    async function YS(t) {
        if (!t.elementId || !t.globalSettings)
            throw new Error("elementId and globalSettings are required for remove-global-styles action");
        const e = window.elementor.getContainer(t.elementId);
        if (!e)
            throw new Error(`Element with ID ${t.elementId} not found.`);
        return window.$e.run("document/globals/disable", {
            container: e,
            settings: t.globalSettings
        }),
        {
            content: [{
                type: "text",
                text: `Global styles removed from element ${t.elementId}.`
            }]
        }
    }
    async function du(t, e) {
        if (!t || typeof t != "object")
            return {};
        const r = {};
        for (const [o,n] of Object.entries(t))
            try {
                r[o] = await KS(n, e)
            } catch (s) {
                throw console.error(`Failed to generate text for key "${o}":`, s),
                new Error(`Failed to generate text for setting "${o}". Please try again or provide the text directly.`)
            }
        return r
    }
    async function KS(t, e) {
        var o;
        const r = await e.server.request({
            method: "sampling/createMessage",
            params: {
                messages: [{
                    role: "user",
                    content: {
                        type: "text",
                        text: t
                    }
                }],
                maxTokens: 1e3,
                modelPreferences: {
                    hints: [{
                        name: "elementor-generate-text"
                    }]
                }
            }
        }, Pr);
        if (!((o = r == null ? void 0 : r.content) != null && o.text))
            throw console.error("[Elementor Server] Error: No text content received from API", r),
            new Error("Failed to generate text: No content received from API.");
        return r.content.text
    }
    function uu(t) {
        var e;
        return {
            id: t.id,
            children: (e = t.children) != null && e.length ? t.children.map(uu) : void 0
        }
    }
    function QS(t) {
        t.tool("page", `Manage page and document operations including getting and upating page settings, saving, history, and page information.
		You MUST use this tool when you want to get or update page settings like page title, page description, page keywords, etc. `, {
            action: a.enum(["save-draft", "save-publish", "save-update", "save-discard", "history-undo", "history-redo", "history-undo-all", "get-settings", "update-settings", "open", "preview"]).describe("The page operation to perform."),
            pageId: a.string().optional().describe("Page/document ID for open action"),
            settings: a.record(a.unknown()).optional().describe("A settings object to use when updating page settings, such as page metadata(title, description, keywords), page styling etc. This parameter is required for update-settings action.")
        }, {
            title: "Manage Page"
        }, async e => {
            console.log("[Elementor Server] page", e);
            try {
                switch (e.action) {
                case "save-draft":
                    return await XS();
                case "save-publish":
                    return await eE();
                case "save-update":
                    return await tE();
                case "save-discard":
                    return await rE();
                case "history-undo":
                    return await nE();
                case "history-redo":
                    return await oE();
                case "history-undo-all":
                    return await sE();
                case "get-settings":
                    return await lE();
                case "update-settings":
                    return await cE(e);
                case "open":
                    return await aE(e);
                case "preview":
                    return await iE();
                default:
                    throw new Error(`Unknown action: ${e.action}`)
                }
            } catch (r) {
                return console.error("[Elementor Server] page error:", r),
                {
                    content: [{
                        type: "text",
                        text: `Error performing ${e.action} action: ${r.message}`
                    }]
                }
            }
        }
        )
    }
    async function XS() {
        return await window.$e.run("document/save/draft"),
        {
            content: [{
                type: "text",
                text: "Page saved as draft."
            }]
        }
    }
    async function eE() {
        return await window.$e.run("document/save/publish"),
        {
            content: [{
                type: "text",
                text: "Page published."
            }]
        }
    }
    async function tE() {
        return await window.$e.run("document/save/update"),
        {
            content: [{
                type: "text",
                text: "Page updated."
            }]
        }
    }
    async function rE() {
        return await window.$e.run("document/save/discard"),
        {
            content: [{
                type: "text",
                text: "Page changes discarded."
            }]
        }
    }
    async function nE() {
        return await window.$e.run("document/history/undo"),
        {
            content: [{
                type: "text",
                text: "Undo performed."
            }]
        }
    }
    async function oE() {
        return await window.$e.run("document/history/redo"),
        {
            content: [{
                type: "text",
                text: "Redo performed."
            }]
        }
    }
    async function sE() {
        return await window.$e.run("document/history/undo-all", {
            document: window.elementor.documents.getCurrent()
        }),
        {
            content: [{
                type: "text",
                text: "All changes undone."
            }]
        }
    }
    async function aE(t) {
        if (!t.pageId)
            throw new Error("pageId is required for open action");
        return await window.$e.run("editor/documents/open", {
            id: t.pageId
        }),
        {
            content: [{
                type: "text",
                text: `Page ${t.pageId} opened.`
            }]
        }
    }
    async function iE() {
        return await window.$e.run("editor/documents/preview"),
        {
            content: [{
                type: "text",
                text: "Page preview opened."
            }]
        }
    }
    async function lE() {
        var r, o, n, s;
        const t = (o = (r = window.elementor) == null ? void 0 : r.documents) == null ? void 0 : o.getCurrent();
        if (!t)
            throw new Error("No active document found.");
        const e = ((n = t.config) == null ? void 0 : n.settings) || {};
        return {
            content: [{
                type: "text",
                text: kt({
                    documentId: t.id,
                    documentType: (s = t.config) == null ? void 0 : s.type,
                    settings: e
                })
            }]
        }
    }
    async function cE(t) {
        var n, s;
        const e = (s = (n = window.elementor) == null ? void 0 : n.documents) == null ? void 0 : s.getCurrent();
        if (!e)
            throw new Error("No active document found.");
        const r = e.id
          , o = bs({
            onlyContexts: ["document"],
            documentId: r
        });
        if (o)
            return {
                content: [{
                    type: "text",
                    text: o
                }]
            };
        if (!t.settings || typeof t.settings != "object")
            throw new Error("settings object is required for update-settings action");
        try {
            return await window.$e.run("document/elements/settings", {
                container: e.container,
                settings: t.settings,
                options: {
                    external: !0
                }
            }),
            {
                content: [{
                    type: "text",
                    text: `Document settings updated successfully. Settings: ${JSON.stringify(t.settings, null, 2)}`
                }]
            }
        } catch (i) {
            throw new Error(`Failed to update document settings: ${i.message}`)
        }
    }
    function dE(t) {
        t.tool("ui", "Manage Elementor editor UI operations.", {
            action: a.enum(["change-device-mode", "reload-preview", "toggle-favorite", "ui-paste"]).describe("The UI operation to perform"),
            deviceMode: a.enum(["desktop", "tablet", "mobile"]).optional().describe("Device mode for change-device-mode"),
            widgetType: a.string().optional().describe("Widget type for toggle-favorite"),
            elementId: a.string().optional().describe("Element ID for ui-paste")
        }, {
            title: "Manage UI"
        }, async e => {
            console.log("[Elementor Server] ui", e);
            try {
                switch (e.action) {
                case "change-device-mode":
                    return await uE(e);
                case "reload-preview":
                    return await mE();
                case "toggle-favorite":
                    return await pE(e);
                case "ui-paste":
                    return await hE(e);
                default:
                    throw new Error(`Unknown action: ${e.action}`)
                }
            } catch (r) {
                return console.error("[Elementor Server] ui error:", r),
                {
                    content: [{
                        type: "text",
                        text: `Error performing ${e.action} action: ${r.message}`
                    }]
                }
            }
        }
        )
    }
    async function uE(t) {
        if (!t.deviceMode)
            throw new Error("deviceMode is required for change-device-mode action");
        return window.$e.run("panel/change-device-mode", {
            device: t.deviceMode
        }),
        {
            content: [{
                type: "text",
                text: `Device mode changed to ${t.deviceMode}.`
            }]
        }
    }
    async function mE() {
        return window.$e.run("preview/reload"),
        {
            content: [{
                type: "text",
                text: "Preview reloaded."
            }]
        }
    }
    async function pE(t) {
        if (!t.widgetType)
            throw new Error("widgetType is required for toggle-favorite action");
        return window.$e.run("favorites/toggle", {
            name: t.widgetType
        }),
        {
            content: [{
                type: "text",
                text: `Favorite status toggled for ${t.widgetType}.`
            }]
        }
    }
    async function hE(t) {
        if (!t.elementId)
            throw new Error("elementId is required for ui-paste action");
        const e = window.elementor.getContainer(t.elementId);
        if (!e)
            throw new Error(`Element with ID ${t.elementId} not found.`);
        return window.$e.run("document/ui/paste", {
            container: e
        }),
        {
            content: [{
                type: "text",
                text: `UI paste performed on element ${t.elementId}.`
            }]
        }
    }
    function gE(t) {
        t.tool("dynamic", "Manage dynamic-tags content for Elementor elements including getting dynamic settings, enabling and disabling dynamic tags.", {
            action: a.enum(["get-settings", "enable", "disable"]).describe("The dynamic content operation to perform"),
            elementId: a.string().describe("The ID of the element to modify"),
            controlName: a.string().describe("The name of the control/setting to make dynamic"),
            dynamicName: a.string().optional().describe("The name of the dynamic tag to enable. Required for enable action. Output of get-settings action."),
            settings: a.object({}).catchall(a.unknown()).optional().describe("The settings to apply to the dynamic tag. Used with enable action. Output of get-settings action."),
            hasRunGetDynamicSettings: a.boolean().optional().describe("Whether the get-settings action has already been run. Must be set to true when using enable action.")
        }, {
            title: "Manage Dynamic Content"
        }, async e => {
            console.log("[Elementor Server] dynamic", e);
            try {
                switch (e.action) {
                case "get-settings":
                    return await fE(e);
                case "enable":
                    if (e.hasRunGetDynamicSettings !== !0)
                        throw new Error("get-dynamic-settings action has not been run. Run it first before using the enable action.");
                    if (!e.elementId || !e.controlName || !e.dynamicName || !e.settings)
                        throw new Error("elementId, controlName, dynamicName, and settings are required for dynamic enable");
                    return await yE(e);
                case "disable":
                    if (!e.elementId || !e.controlName)
                        throw new Error("elementId and controlName are required for dynamic disable");
                    return await vE(e);
                default:
                    throw new Error(`Unknown action: ${e.action}`)
                }
            } catch (r) {
                return console.error("[Elementor Server] dynamic error:", r),
                {
                    content: [{
                        type: "text",
                        text: `Error performing ${e.action} action: ${r.message}`
                    }]
                }
            }
        }
        )
    }
    async function fE(t) {
        if (!t.elementId || !t.controlName)
            throw new Error("elementId and controlName are required for get-settings");
        const e = window.elementor.getContainer(t.elementId);
        if (!e)
            throw new Error(`Element with ID ${t.elementId} not found.`);
        const r = e.settings.controls
          , {categories: o} = r[t.controlName].dynamic
          , n = Object.values(window.elementor.dynamicTags.getConfig("tags")).filter(s => s.categories.find(i => o.includes(i)));
        return console.log("[Commands Server] get-dynamic-settings result:", n),
        {
            content: [{
                type: "text",
                text: JSON.stringify(n, null, 2)
            }]
        }
    }
    async function yE(t) {
        if (!t.elementId || !t.controlName || !t.dynamicName)
            throw new Error("elementId, controlName, and dynamicName are required for dynamic enable");
        if (t.hasRunGetDynamicSettings !== !0)
            throw new Error("get-dynamic-settings action has not been run. Run it first before using the enable action.");
        const e = window.elementor.getContainer(t.elementId);
        if (!e)
            throw new Error(`Element with ID ${t.elementId} not found.`);
        const r = t.dynamicName.toLowerCase().replace(/\s+/g, "-").replace(/_/g, "-").replace(/[^a-z0-9-]/g, "")
          , o = t.settings || {};
        o.toJSON = () => o;
        const n = window.elementorCommon.helpers.getUniqueId()
          , s = window.elementor.dynamicTags.tagDataToTagText(String(n), r, o)
          , i = await window.$e.run("document/dynamic/enable", {
            container: e,
            settings: {
                [t.controlName]: s
            }
        });
        return console.log("[Commands Server] dynamic-enable result:", i),
        {
            content: [{
                type: "text",
                text: `Dynamic content enabled for element ${t.elementId}, control "${t.controlName}" with dynamic tag "${r}": ${s}`
            }]
        }
    }
    async function vE(t) {
        if (!t.elementId || !t.controlName)
            throw new Error("elementId and controlName are required for dynamic disable");
        const e = window.elementor.getContainer(t.elementId);
        if (!e)
            throw new Error(`Element with ID ${t.elementId} not found.`);
        const o = (s => {
            var d, u;
            const i = ((u = (d = s.model) == null ? void 0 : d.attributes) == null ? void 0 : u.settings) || {}
              , l = {};
            return Object.keys(i).forEach(g => {
                const c = i[g];
                let m = null;
                c && typeof c == "object" && c.__dynamic__ && (m = c.__dynamic__),
                m && (l[g] = m)
            }
            ),
            {
                settingsNames: Object.keys(l.attributes || {}),
                dynamicContent: l
            }
        }
        )(e).settingsNames;
        if (!o.includes(t.controlName))
            throw new Error(`Setting "${t.controlName}" on element ${t.elementId} does not have dynamic content enabled. here is the list of dynamic settings available: ${JSON.stringify(o, null, 2)}`);
        const n = await window.$e.run("document/dynamic/disable", {
            container: e,
            settings: {
                [t.controlName]: ""
            }
        });
        return console.log("[Commands Server] dynamic-disable result:", n),
        {
            content: [{
                type: "text",
                text: `Dynamic content disabled for setting "${t.controlName}" on element ${t.elementId}.`
            }]
        }
    }
    function wE(t) {
        const e = window.$e.routes.getAll()
          , r = window.$e.components.getAll()
          , o = r.filter(s => window.$e.components.get(s).getCommands().open)
          , n = r.filter(s => window.$e.components.get(s).getCommands().close);
        t.tool("routes", `Manage Elementor editor routing and navigation. Use this tool to open a component, navigate to a route, go back from a route or close components. Always prefer this tool when user is on the Elementor editor. Available routes to navigate to or back from: ${e.join(", ")}`, {
            action: a.enum(["open", "navigate", "go-back", "close"]),
            route: a.string().optional().describe("The route to navigate to or back from it. Do not send this parameter if you only want to open a component."),
            componentToOpen: a.enum(o).optional().describe("The component to open or navigate to."),
            componentToClose: a.enum(n).optional().describe("The component to close.")
        }, {
            title: "Manage Routes"
        }, async s => {
            console.log("[Elementor Server] routes", s);
            try {
                switch (s.action) {
                case "open":
                    return await bE(s);
                case "navigate":
                    return await SE(s);
                case "go-back":
                    return await EE(s);
                case "close":
                    return await xE(s);
                default:
                    throw new Error(`Unknown action: ${s.action}`)
                }
            } catch (i) {
                return console.error("[Elementor Server] routes error:", i),
                {
                    content: [{
                        type: "text",
                        text: `Error performing ${s.action} action: ${i.message}`
                    }]
                }
            }
        }
        )
    }
    async function bE(t) {
        var o, n;
        const e = t.componentToOpen || t.route
          , r = (n = (o = window.$e.components.get(e)) == null ? void 0 : o.getCommands().open) == null ? void 0 : n.registerConfig.command;
        if (r)
            await window.$e.run(r, {});
        else
            throw new Error("Could not open component");
        return {
            content: [{
                type: "text",
                text: `Opened: ${e}`
            }]
        }
    }
    async function SE(t) {
        var n, s, i, l;
        const e = t.route
          , r = t.componentToOpen
          , o = (s = (n = window.$e.components.get(r)) == null ? void 0 : n.getCommands().open) == null ? void 0 : s.registerConfig.command;
        o && await window.$e.run(o, {}),
        window.$e.routes.saveState(window.$e.routes.getComponent(e).getNamespace());
        try {
            window.$e.routes.to(e, {})
        } catch {
            const u = (l = (i = window.$e.components.get(e)) == null ? void 0 : i.getCommands().open) == null ? void 0 : l.registerConfig.command;
            if (u)
                await window.$e.run(u, {});
            else
                throw new Error("Could not navigate to route")
        }
        return {
            content: [{
                type: "text",
                text: `Navigated to: ${e}`
            }]
        }
    }
    async function EE(t) {
        const e = t.route
          , r = window.$e.routes.getComponent(e);
        return window.$e.routes.back(r.getNamespace()),
        {
            content: [{
                type: "text",
                text: `Go back to: ${e}`
            }]
        }
    }
    async function xE(t) {
        var o, n;
        const e = t.componentToClose
          , r = (n = (o = window.$e.components.get(e)) == null ? void 0 : o.getCommands().close) == null ? void 0 : n.registerConfig.command;
        if (r)
            await window.$e.run(r, {});
        else
            throw new Error("Could not close component");
        return {
            content: [{
                type: "text",
                text: `Closed: ${e}`
            }]
        }
    }
    function _E(t) {
        t.tool("ai", "Manage Elementor AI integration features and interfaces.", {
            action: a.enum(["open-brand-voice", "open-choose-element", "open-text-to-elementor"]).describe("The AI operation to perform")
        }, {
            title: "Manage AI Integration"
        }, async e => {
            console.log("[Elementor Server] ai", e);
            try {
                switch (e.action) {
                case "open-brand-voice":
                    return await TE();
                case "open-choose-element":
                    return await PE();
                case "open-text-to-elementor":
                    return await kE();
                default:
                    throw new Error(`Unknown action: ${e.action}`)
                }
            } catch (r) {
                return console.error("[Elementor Server] ai error:", r),
                {
                    content: [{
                        type: "text",
                        text: `Error performing ${e.action} action: ${r.message}`
                    }]
                }
            }
        }
        )
    }
    async function TE() {
        return await window.$e.run("ai-integration/open-brand-voice"),
        {
            content: [{
                type: "text",
                text: "Brand Voice interface opened."
            }]
        }
    }
    async function PE() {
        return await window.$e.run("ai-integration/open-choose-element"),
        {
            content: [{
                type: "text",
                text: "Choose Element interface opened."
            }]
        }
    }
    async function kE() {
        return await window.$e.run("ai-integration/open-text-to-elementor"),
        {
            content: [{
                type: "text",
                text: "Text to Elementor interface opened."
            }]
        }
    }
    function IE(t) {
        t.tool("copilot", `**USE THIS TOOL when users request complete sections or layouts.**

This tool manages Elementor Copilot functionality for section generation and layout suggestions. Use this when users want to create complete sections, complex layouts or when managing Copilot-generated layout suggestions.

**When to use this tool:**
- User requests a complete page or section design
- User requests standard sections (About, Hero, Testimonials, Pricing, FAQ, Gallery, Contact, etc.)
- User describes both layout and content intent together ("3-column team section", "section with service boxes")
- User wants AI to generate complete sections instead of building element by element
- Need to accept or reject Copilot-generated layout suggestions

**Actions available:**
- **generate**: Launches Copilot to generate sections with content and layout
- **accept-suggestion**: Applies the currently suggested Copilot layout to the page
- **reject-suggestion**: Discards the currently suggested Copilot layout

This tool provides a complete workflow for AI-assisted page building through Copilot integration.`, {
            action: a.enum(["generate", "accept-suggestion", "reject-suggestion"]).describe("The Copilot operation to perform: generate starts AI section generation, accept-suggestion applies the current layout, reject-suggestion discards the current layout."),
            userInput: a.string().optional().describe('Required for generate action only. A detailed description of the desired section including type (Hero, Testimonials, etc.), layout (3 columns, carousel), and specific content requirements. Example: "Create a testimonial carousel section" or "Add a pricing table for 3 plans (Basic, Pro, Enterprise)".')
        }, {
            title: "Manage Copilot Integration"
        }, async e => {
            console.log("[Elementor Server] copilot", e);
            try {
                switch (e.action) {
                case "generate":
                    if (!e.userInput)
                        throw new Error("userInput is required for generate action");
                    return await CE(e.userInput);
                case "accept-suggestion":
                    return await mu("accept");
                case "reject-suggestion":
                    return await mu("reject");
                default:
                    throw new Error(`Unknown action: ${e.action}`)
                }
            } catch (r) {
                return console.error("[Elementor Server] copilot error:", r),
                {
                    content: [{
                        type: "text",
                        text: `Error performing ${e.action} action: ${r.message}`
                    }]
                }
            }
        }
        )
    }
    async function CE(t) {
        const {startCopilot: e} = await Promise.resolve().then( () => Es)
          , {askCopilotForNextLayout: r} = await Promise.resolve().then( () => vu)
          , o = "angie"
          , n = await e();
        return n.style.opacity = "1",
        n.style.visibility = "visible",
        r(n, o, t),
        {
            content: [{
                type: "text",
                text: `Copilot container generation triggered successfully with trigger: "${o}". The Copilot interface should now be active and generating container layout suggestions.`
            }]
        }
    }
    async function mu(t) {
        var o;
        const {getCopilotIframe: e} = await Promise.resolve().then( () => Es)
          , r = e();
        if (!r)
            throw new Error("Copilot iframe not found. Please trigger Copilot first.");
        return (o = r.contentWindow) == null || o.postMessage({
            type: `copilot/next-layout/${t}`
        }, new URL(r.src).origin),
        {
            content: [{
                type: "text",
                text: `Copilot suggestion has been '${t}'ed.`
            }]
        }
    }
    function $E(t) {
        t.tool("motion-effects", `This tool creates dynamic motion effects for Elementor elements with AI-generated animations and interactions. Use this when users want to add visual effects that respond to specific triggers like hover, scroll, mouse movement, or page entrance. The tool supports movements, rotations, scaling, fading, blurring, and entrance animations based on the selected trigger type. It will launch an interactive interface where users can preview and apply the generated motion effects to their elements.

**TRIGGER  Supported EFFECTS**
- hover  Movements, Rotations, Scaling
- scroll  Rotations, Scaling, Fading, Blurring  
- mouse_move  Movements
- entrance  All animate.css "in" effects (fadeIn*, slideIn*, zoomIn*, rotateIn*, flipIn*, bounceIn*, etc.)

**When to use this tool:**
- User requests hover effects like "rotate on hover" or "scale up when hovered"
- User wants scroll-triggered animations like "fade in while scrolling" or "rotate as I scroll"
- User needs mouse-following effects like "move with mouse cursor"
- User wants entrance animations like "slide in from left when page loads"

**Do NOT use this tool if:**
- The requested effect/trigger combination is not supported (refer to the list above)
- User wants static styling without motion (use styling tools instead)
- User requests click-triggered effects (use custom CSS tools instead)`, {
            elementId: a.string().describe("The unique ID of the selected Elementor element to apply motion effects to. This must be obtained from a currently selected element in the Elementor editor. The motion effects will be applied specifically to this element."),
            prompt: a.string().describe("A detailed description of the desired motion effects and behavior. Include the specific effect type (movement, rotation, scaling, fading, etc.), the trigger condition (hover, scroll, mouse movement, entrance), and any specific requirements like direction, intensity, or timing."),
            triggerTypes: a.array(a.enum(["hover", "scroll", "mouse_move", "entrance"])).describe("Array of trigger types that will activate the motion effects. Choose from the supported options based on when the user wants the effects to occur. Multiple triggers can be selected if the effect should respond to different interactions.")
        }, {
            title: "Create Motion Effects"
        }, async e => {
            console.log("[Elementor Server] motion-effects", e);
            try {
                return await AE(e.elementId, e.prompt, e.triggerTypes)
            } catch (r) {
                return console.error("[Elementor Server] motion-effects error:", r),
                {
                    content: [{
                        type: "text",
                        text: `Error creating motion effects: ${r.message}`
                    }]
                }
            }
        }
        )
    }
    async function AE(t, e, r) {
        const o = await xe({
            name: Se.MOTION_EFFECTS,
            elementId: t,
            prompt: e,
            motionEffectType: r
        });
        return {
            content: [{
                type: "text",
                text: JSON.stringify(o)
            }]
        }
    }
    var Dr = (t => (t.IN_PAINTING = "in-painting",
    t.CLEANUP = "cleanup",
    t.OUT_PAINTING = "out-painting",
    t))(Dr || {});
    const RE = Object.keys({
        "Square (1:1)": "1:1",
        "Landscape (3:2)": "3:2",
        "Landscape (4:3)": "4:3",
        "Landscape (16:9)": "16:9",
        "Portrait (2:3)": "2:3",
        "Portrait (3:4)": "3:4",
        "Portrait (9:16)": "9:16"
    })
      , OE = a.enum([...RE]).optional();
    function DE(t) {
        t.tool("image", `This tool provides AI-powered image editing and manipulation operations for Elementor elements. 
		**Note**: For new image generation, use Angie's built in 'generate-image' capability.

**Available Actions:**
- **remove-background**: Remove background from existing images, creating transparent/clean versions
- **replace-background**: Replace image background with AI-generated scenery based on prompts
- **upscale**: Increase image resolution and enhance quality using AI upscaling
- **create-variations**: Transform existing images with style changes, color modifications, or artistic interpretations
- **isolate-object**: Extract and isolate specific objects from images with custom background colors
- **generative-fill**: Open interactive inpainting tool for editing specific image areas with brush controls
- **cleanup**: Open cleanup tool for removing unwanted objects or blemishes with precision brush tools  
- **expand**: Open expansion tool for extending image borders and generating new content around edges

**When to use this tool:**
- User wants to edit, enhance or manipulate EXISTING images for Elementor elements
- User needs background removal, replacement, or object isolation
- User wants to upscale images or create artistic variations
- User needs interactive editing tools for precise image modifications
- User wants to expand images or clean up unwanted elements

This tool handles automated AI processing and interactive editing interfaces with preview functionality.`, {
            action: a.enum(["upscale", "remove-background", "replace-background", "create-variations", "isolate-object", "generative-fill", "cleanup", "expand"]).describe("The image operation to perform. Choose based on what the user wants to accomplish with their image."),
            elementId: a.string().describe("ID of the Elementor image widget/element where the processed image should be applied. This is required for all actions."),
            imageUrl: a.string().url().optional().describe('The URL of the existing image from the WordPress media library. Required for all actions except generate-new. Must be a media library URL (containing /wp-content/uploads/). Required for all actions except "generate-new"'),
            prompt: a.string().optional().describe("Required for generate-new, replace-background, and create-variations actions. Detailed description of the desired image generation or modification."),
            aspectRatio: OE.optional().describe("The aspect ratio for generated images. Used only with generate-new action."),
            resolution: a.number().min(512).max(2048).optional().describe("Required for upscale action. The exact resolution for upscaling. Choose from: 512, 768, 1024, 1280, 1536, 1792, 2048."),
            backgroundColor: a.string().optional().describe('Background color for isolate-object action (e.g., "#ffffff", "#000000"). Defaults to white if not specified.'),
            backgroundPrompt: a.string().optional().describe('Required for replace-background action. Description of the new background to generate (e.g., "sunset over mountains", "modern office space").'),
            confirmed: a.boolean().optional().describe("Set to true only for interactive tools (generative-fill, cleanup, expand) after user confirms they want to proceed. These tools require user confirmation before opening.")
        }, {
            title: "Manage AI Image Operations"
        }, async e => {
            console.log("[Elementor Server] image", e);
            try {
                switch (e.action) {
                case "remove-background":
                    return await NE(e);
                case "upscale":
                    return await LE(e);
                case "replace-background":
                    return await UE(e);
                case "create-variations":
                    return await jE(e);
                case "isolate-object":
                    return await ME(e);
                case "generative-fill":
                    return await FE(e);
                case "cleanup":
                    return await WE(e);
                case "expand":
                    return await qE(e);
                default:
                    throw new Error(`Unknown action: ${e.action}`)
                }
            } catch (r) {
                return console.error("[Elementor Server] image error:", r),
                {
                    content: [{
                        type: "text",
                        text: `Error performing ${e.action} action: ${r.message}`
                    }]
                }
            }
        }
        )
    }
    async function NE(t) {
        if (!t.imageUrl)
            throw new Error("imageUrl is required for remove-background action");
        Ye(t.imageUrl);
        const e = {
            name: Se.REMOVE_BACKGROUND,
            imageUrl: t.imageUrl,
            elementId: t.elementId,
            context: "editor",
            supportsPreview: !0
        }
          , r = await xe(e);
        return {
            content: [{
                type: "text",
                text: JSON.stringify(r)
            }]
        }
    }
    async function LE(t) {
        if (!t.imageUrl)
            throw new Error("imageUrl is required for upscale action");
        if (!t.resolution)
            throw new Error("resolution is required for upscale action");
        Ye(t.imageUrl);
        const e = {
            name: Se.UPSCALE_IMAGE,
            imageUrl: t.imageUrl,
            elementId: t.elementId,
            context: "editor",
            supportsPreview: !0,
            resolution: t.resolution
        }
          , r = await xe(e);
        return {
            content: [{
                type: "text",
                text: JSON.stringify(r)
            }]
        }
    }
    async function UE(t) {
        if (!t.imageUrl)
            throw new Error("imageUrl is required for replace-background action");
        if (!t.backgroundPrompt)
            throw new Error("backgroundPrompt is required for replace-background action");
        Ye(t.imageUrl);
        const e = {
            name: Se.REPLACE_BACKGROUND,
            imageUrl: t.imageUrl,
            backgroundPrompt: t.backgroundPrompt,
            elementId: t.elementId,
            context: "editor",
            supportsPreview: !0
        }
          , r = await xe(e);
        return {
            content: [{
                type: "text",
                text: JSON.stringify(r)
            }]
        }
    }
    async function jE(t) {
        if (!t.imageUrl)
            throw new Error("imageUrl is required for create-variations action");
        if (!t.prompt)
            throw new Error("prompt is required for create-variations action");
        Ye(t.imageUrl);
        const e = {
            name: Se.GENERATE_IMAGE_VARIATIONS,
            imageUrl: t.imageUrl,
            elementId: t.elementId,
            prompt: t.prompt,
            context: "editor",
            supportsPreview: !0
        }
          , r = await xe(e);
        return {
            content: [{
                type: "text",
                text: JSON.stringify(r)
            }]
        }
    }
    async function ME(t) {
        if (!t.imageUrl)
            throw new Error("imageUrl is required for isolate-object action");
        Ye(t.imageUrl);
        const e = {
            name: Se.ISOLATE_OBJECT,
            imageUrl: t.imageUrl,
            backgroundColor: t.backgroundColor || "#ffffff",
            elementId: t.elementId,
            context: "editor",
            supportsPreview: !0
        }
          , r = await xe(e);
        return {
            content: [{
                type: "text",
                text: JSON.stringify(r)
            }]
        }
    }
    async function FE(t) {
        if (!t.imageUrl)
            throw new Error("imageUrl is required for generative-fill action");
        if (!Hr())
            return {
                content: [{
                    type: "text",
                    text: JSON.stringify({
                        message: "Elementor AI is not active. Please activate it or buy an elementor ai subscription."
                    })
                }]
            };
        if (!t.confirmed)
            return {
                content: [{
                    type: "text",
                    text: JSON.stringify({
                        message: `I'll open Elementor's Generative Fill tool for you. This will:
 Open an interactive canvas interface
 Let you brush/mark areas you want to edit
 Allow you to add text prompts for AI modifications
 Automatically apply the edited result to your element`,
                        question: "Do you want me to open the Generative Fill tool?",
                        requiresConfirmation: !0,
                        action: "generative-fill",
                        parameters: {
                            ...t,
                            confirmed: !0
                        }
                    })
                }]
            };
        const e = {
            name: Se.IMAGE_TOOLS_MODAL,
            modalType: Dr.IN_PAINTING,
            imageUrl: t.imageUrl,
            elementId: t.elementId
        }
          , r = await xe(e);
        if (!r.success)
            throw new Error(r.error || "Failed to open Generative Fill interface");
        return {
            content: [{
                type: "text",
                text: JSON.stringify({
                    followup_message: `Done! I've applied the generative fill to your image. 
The edited image has been updated in your element.
Let me know if you want to make any adjustments or try another edit.`,
                    success: r.success,
                    action: r.action
                })
            }]
        }
    }
    async function WE(t) {
        if (!t.imageUrl)
            throw new Error("imageUrl is required for cleanup action");
        if (!Hr())
            return {
                content: [{
                    type: "text",
                    text: JSON.stringify({
                        message: "Elementor AI is not active. Please activate it or buy an elementor ai subscription."
                    })
                }]
            };
        if (!t.confirmed)
            return {
                content: [{
                    type: "text",
                    text: JSON.stringify({
                        message: `I'll open Elementor's Cleanup tool for you. This will:
 Open an interactive brush interface
 Let you mark unwanted areas to remove
 Provide precise editing with undo/redo functionality
 Automatically apply the cleaned result to your element`,
                        question: "Do you want me to open the Cleanup tool?",
                        requiresConfirmation: !0,
                        action: "cleanup",
                        parameters: {
                            ...t,
                            confirmed: !0
                        }
                    })
                }]
            };
        const e = {
            name: Se.IMAGE_TOOLS_MODAL,
            modalType: Dr.CLEANUP,
            imageUrl: t.imageUrl,
            elementId: t.elementId
        }
          , r = await xe(e);
        if (!r.success)
            throw new Error(r.error || "Failed to open Cleanup tool interface");
        return {
            content: [{
                type: "text",
                text: JSON.stringify({
                    followup_message: `Done! I've cleaned up your image. 
The edited image has been updated in your element.
Let me know if you want to make any adjustments or clean up other areas.`,
                    success: r.success,
                    action: r.action
                })
            }]
        }
    }
    async function qE(t) {
        if (!t.imageUrl)
            throw new Error("imageUrl is required for expand action");
        if (!Hr())
            return {
                content: [{
                    type: "text",
                    text: JSON.stringify({
                        message: "Elementor AI is not active. Please activate it or buy an elementor ai subscription."
                    })
                }]
            };
        if (!t.confirmed)
            return {
                content: [{
                    type: "text",
                    text: JSON.stringify({
                        message: `I'll open Elementor's Expand Image tool for you. This will:
 Open an interactive interface
 Let you select which areas to expand
 Generate new content around your image
 Automatically apply the result to your element`,
                        question: "Do you want me to open the Expand Image tool?",
                        requiresConfirmation: !0,
                        action: "expand",
                        parameters: {
                            ...t,
                            confirmed: !0
                        }
                    })
                }]
            };
        const e = {
            name: Se.IMAGE_TOOLS_MODAL,
            modalType: Dr.OUT_PAINTING,
            imageUrl: t.imageUrl,
            elementId: t.elementId
        }
          , r = await xe(e);
        if (!r.success)
            throw new Error(r.error || "Failed to open Expand Image tool interface");
        return {
            content: [{
                type: "text",
                text: JSON.stringify({
                    followup_message: `Done! I've expanded your image with new content. 
The extended image has been updated in your element.
Let me know if you want to make any adjustments or expand other areas.`,
                    success: r.success,
                    action: r.action
                })
            }]
        }
    }
    function GE(t) {
        t.tool("styling", `This tool provides AI-powered custom CSS styling for Elementor elements. Use this when users want advanced styling that goes beyond Elementor capabilities and can't be targeted using the element settings.

**When to use this tool:**
- Visual effects: shadows, filters, pseudo-elements, advanced selectors
- Complex animations with custom keyframes or CSS transitions
- Styling that requires media queries or complex CSS rules
- Click-triggered effects or other non-motion triggers
- Custom hover effects that don't involve motion (color changes, opacity, etc.)

**When NOT to use this tool:**
- Basic styling achievable through Elementor settings (colors, typography, spacing, borders, simple hover effects) -> use the elementor__elements with "update-settings" action.

**Do NOT use this tool if the user mentions motion effects with supported triggers:**
- "on hover" with motion (movement, rotation, scaling)  use motion-effects tool
- "on scroll" with motion effects  use motion-effects tool  
- "mouse move" / "follow mouse"  use motion-effects tool
- "entrance" / "fade in" / "slide in" animations  use motion-effects tool

**Actions available:**
- **custom-css**: Generate and apply AI-powered custom CSS to elements

This tool generates CSS code using AI, provides preview functionality, and handles user approval workflow for applying custom styles.`, {
            action: a.enum(["custom-css"]).describe("The styling operation to perform. Currently supports custom-css for AI-generated CSS styling."),
            elementId: a.string().describe("The ID of the Elementor element to apply custom styling to. This element will receive the generated CSS code."),
            prompt: a.string().describe("A detailed description of the desired styling. Include specific visual requirements, colors, effects, layout modifications, or any custom styling needs. The more detailed the prompt, the better the generated CSS will match your requirements.")
        }, {
            title: "Apply Custom Styling"
        }, async e => {
            console.log("[Elementor Server] styling", e);
            try {
                switch (e.action) {
                case "custom-css":
                    return await BE(e.elementId, e.prompt, t);
                default:
                    throw new Error(`Unknown action: ${e.action}`)
                }
            } catch (r) {
                return console.error("[Elementor Server] styling error:", r),
                {
                    content: [{
                        type: "text",
                        text: `Error performing ${e.action} action: ${r.message}`
                    }]
                }
            }
        }
        )
    }
    async function BE(t, e, r) {
        const n = window.elementor.getContainer(t).view.el.outerHTML || ""
          , s = u => u && u.replace(/`/g, "").replace(/^css\s*/i, "")
          , i = await r.server.request({
            method: "sampling/createMessage",
            params: {
                messages: [{
                    role: "user",
                    content: {
                        type: "text",
                        text: e
                    }
                }],
                maxTokens: 1e3,
                modelPreferences: {
                    hints: [{
                        name: "elementor-css"
                    }]
                },
                metadata: {
                    element_id: t,
                    html_markup: n
                }
            }
        }, Pr);
        if (!(i != null && i.content))
            throw console.error("[Elementor Server] Error: No CSS text received from API", i),
            new Error("Failed to generate CSS: No text content received from API.");
        const l = s(i.content.text)
          , d = await xe({
            name: Se.CUSTOM_CSS_APPROVAL,
            cssToApprove: l,
            elementId: t,
            autoInsert: !1,
            hideSuggestionsOnEdit: !0
        });
        return d.approved ? {
            content: [{
                type: "text",
                text: JSON.stringify({
                    success: !0,
                    message: "Custom CSS was applied and approved by the user.",
                    generatedCss: d.finalCss || l,
                    action: d.action || "apply"
                })
            }]
        } : d.action === "copy" ? {
            content: [{
                type: "text",
                text: JSON.stringify({
                    success: !0,
                    message: "CSS code copied to clipboard. The CSS has been applied to the element.",
                    generatedCss: d.finalCss || l,
                    action: "copy"
                })
            }]
        } : d.action === "hide" ? {
            content: [{
                type: "text",
                text: JSON.stringify({
                    success: !0,
                    message: "CSS preview hidden. The CSS remains applied to the element.",
                    generatedCss: d.finalCss || l,
                    action: "hide"
                })
            }]
        } : {
            content: [{
                type: "text",
                text: JSON.stringify({
                    success: !0,
                    message: "Custom CSS rejected by user. Ask the user if they would like to try again with a different prompt.",
                    generatedCss: l,
                    action: d.action || "reject"
                })
            }]
        }
    }
    async function zE() {
        await Nf();
        const t = new He({
            name: "elementor-server",
            version: "1.0.0"
        },{
            capabilities: {
                resources: {
                    subscribe: !0
                }
            }
        });
        return _S(t),
        QS(t),
        dE(t),
        gE(t),
        wE(t),
        _E(t),
        IE(t),
        $E(t),
        DE(t),
        GE(t),
        t
    }
    const pu = 'IMPORTANT: Always use existing global style names (like "primary", "secondary", etc.) when they are close enough to the intended value, name, or meaning  even if not exact. Only create a new value if no suitable global exists.'
      , hu = a.object({
        id: a.string().describe("Unique element ID"),
        elType: a.enum(["widget", "section", "column", "container"]).describe("Element type"),
        settings: a.record(a.unknown()).optional().describe("Element settings")
    }).describe("Base Elementor element structure")
      , gu = hu.extend({
        elements: a.array(hu).optional().describe("Child elements (non-recursive, one level only)")
    }).describe("Elementor container object reference")
      , ZE = t => {
        var o, n;
        const e = ((n = (o = t.model) == null ? void 0 : o.attributes) == null ? void 0 : n.settings) || {}
          , r = {};
        return Object.keys(e).forEach(s => {
            const i = e[s];
            let l = null;
            i && typeof i == "object" && i.__dynamic__ && (l = i.__dynamic__),
            l && (r[s] = l)
        }
        ),
        {
            settingsNames: Object.keys(r.attributes || {}),
            dynamicContent: r
        }
    }
    ;
    function HE() {
        const t = new He({
            name: "elementor-server",
            version: "1.0.0"
        },{
            capabilities: {
                resources: {
                    subscribe: !0
                }
            }
        });
        async function e(c, m, p, h) {
            var S, w, _, I, k, C, L;
            const f = (I = (_ = (w = (S = window.elementor) == null ? void 0 : S.widgetsCache) == null ? void 0 : w[p]) == null ? void 0 : _.controls) == null ? void 0 : I[m]
              , y = (C = (k = c.settings) == null ? void 0 : k.attributes) == null ? void 0 : C[m];
            let b = ((L = y == null ? void 0 : y.models) == null ? void 0 : L.length) ?? 0;
            const x = {};
            for (Object.keys(f.fields ?? {}).forEach(N => {
                var $;
                const A = ($ = f == null ? void 0 : f.fields) == null ? void 0 : $[N];
                x[N] = (A == null ? void 0 : A.default) || ""
            }
            ),
            h[m].forEach(N => {
                const A = {};
                Object.keys(x).forEach($ => {
                    A[$] = N[$] ?? x[$]
                }
                ),
                A._id = window.elementorCommon.helpers.getUniqueId(),
                window.$e.run("document/repeater/insert", {
                    container: c,
                    name: m,
                    model: A
                })
            }
            ); b--; )
                await window.$e.run("document/repeater/remove", {
                    container: c,
                    name: m,
                    index: 0
                })
        }
        function r(c) {
            const m = {};
            return Object.keys(c).forEach(p => {
                const h = nu[p];
                h == null || h.forEach(f => {
                    c[f.mandatory] || (c[f.mandatory] = f.default,
                    m[f.mandatory] = f.default)
                }
                )
            }
            ),
            m
        }
        function o() {
            var m;
            const c = window.elementor;
            if (c.getCurrentElement) {
                const p = c.getCurrentElement();
                return (m = p == null ? void 0 : p.model) == null ? void 0 : m.id
            }
        }
        async function n(c) {
            if (c) {
                const m = window.elementor.getContainer(c);
                m && await window.$e.run("document/elements/select", {
                    container: m
                })
            }
        }
        function s(c) {
            const m = {};
            for (const [p,h] of Object.entries(c))
                typeof h == "string" && h.startsWith("globals/") ? m[p] = h : p.includes("typography") ? m[p] = `globals/typography?id=${h}` : m[p] = `globals/colors?id=${h}`;
            return m
        }
        async function i(c, m) {
            const p = {}
              , h = await window.$e.data.get("globals/colors")
              , f = await window.$e.data.get("globals/typography");
            if (Object.keys(c).forEach(y => {
                const b = c[y];
                if (typeof b == "string" && b)
                    if (h.data[b] || f.data[b])
                        p[y] = b;
                    else {
                        const x = Object.keys(h.data).find(S => {
                            var w;
                            return ((w = h.data[S]) == null ? void 0 : w.value) === b
                        }
                        )
                          , v = Object.keys(f.data).find(S => {
                            const w = f.data[S];
                            return w && JSON.stringify(w.value) === JSON.stringify(b)
                        }
                        );
                        x ? p[y] = x : v && (p[y] = v)
                    }
            }
            ),
            Object.keys(p).forEach(y => {
                delete c[y]
            }
            ),
            Object.keys(p).length > 0) {
                const y = window.elementor.getContainer(m);
                if (y) {
                    const b = s(p);
                    await window.$e.run("document/globals/enable", {
                        container: y,
                        settings: b
                    })
                }
            }
            return p
        }
        t.tool("update-element-settings", `Updates the settings of a specific Elementor element (widget, container, etc.) using the built-in options that are available through the Elementor's dashboard.
Use this to programmatically change an element's appearance or data.
Use this tool only if you have elementId which indicates the element to update.
you must call \`get-current-element-settings\` tool to get the current element settings before calling this tool.
`, {
            elementId: a.string().describe("The ID of the Elementor element to update."),
            settings: a.object({}).catchall(a.unknown()).describe("An object containing the settings to apply to the element as a valid Elementor settings object."),
            wasGetCurrentSettingsToolCalled: a.boolean().describe("Whether the `get-current-element-settings` tool was called before this command. If true, the settings object should match the current element settings schema.")
        }, async ({elementId: c, settings: m, wasGetCurrentSettingsToolCalled: p}) => {
            var v, S;
            if (console.log("[Elementor Server] update-element-settings", {
                elementId: c,
                settings: m
            }),
            !p)
                throw new Error(`You must get the current element settings before calling this tool.
I took the liberty to do it for you so you wouldn't need.
Here are the current settings for element ${c}:
"""
${JSON.stringify($a(c), null, 2)}
"""


Now that you have the required knowledge you can recall this tool (update-element-settings). Make sure to set wasGetCurrentSettingsToolCalled to true.`);
            const h = window.elementor.getContainer(c)
              , f = (S = (v = h.model) == null ? void 0 : v.attributes) == null ? void 0 : S.widgetType
              , y = r(m);
            f !== "document" && f !== "container" && Object.keys(m).forEach(w => {
                var k, C, L, N;
                const _ = (N = (L = (C = (k = window.elementor) == null ? void 0 : k.widgetsCache) == null ? void 0 : C[f ?? ""]) == null ? void 0 : L.controls) == null ? void 0 : N[w];
                (_ == null ? void 0 : _.type) === "repeater" && (e(h, w, f, m),
                delete m[w])
            }
            );
            let b;
            Object.keys(m).length && (b = window.$e.run("document/elements/settings", {
                container: h,
                settings: m || {},
                options: {
                    external: !0,
                    render: !0
                }
            })),
            window.elementorFrontend.elements.$body.resize(),
            console.log("[Commands Server] update-element-settings result:", b);
            let x = `Settings updated for element ${c}`;
            return Object.keys(y).length && (x += `
Note: The following mandatory fields were added: ${JSON.stringify(y, null, 2)}`),
            {
                content: [{
                    type: "text",
                    text: x
                }]
            }
        }
        );
        function l(c) {
            var p;
            const m = (p = window.elementor.widgetsCache[c ?? ""]) == null ? void 0 : p.controls;
            return Object.keys(m ?? {}).map(h => {
                const f = m == null ? void 0 : m[h];
                let y;
                f != null && f.options ? y = Object.keys(f == null ? void 0 : f.options) : f != null && f.return_value && (y = [f == null ? void 0 : f.return_value, ""]);
                const b = f != null && f.fields ? Object.keys((f == null ? void 0 : f.fields) ?? {}).map(x => {
                    var v, S;
                    return {
                        key: x,
                        default_value: (S = (v = f == null ? void 0 : f.fields) == null ? void 0 : v[x]) == null ? void 0 : S.default
                    }
                }
                ) : void 0;
                return {
                    key: h,
                    type: f == null ? void 0 : f.type,
                    options: y,
                    default_value: f == null ? void 0 : f.default,
                    fields: b,
                    size_units: f == null ? void 0 : f.size_units,
                    range: f == null ? void 0 : f.range
                }
            }
            ).reduce( (h, {key: f, type: y, default_value: b, options: x, size_units: v, range: S, fields: w}) => {
                h[f] = {
                    type: y,
                    default_value: b,
                    fields: w,
                    options: x,
                    size_units: v,
                    range: S
                };
                const _ = h[f];
                return Object.keys(_).forEach(I => {
                    _[I] === void 0 && delete _[I]
                }
                ),
                h
            }
            , {})
        }
        function d(c) {
            console.log("[Elementor Server] get-widget-config-by-type", {
                widgetType: c
            });
            const m = l(c);
            return console.log("[Commands Server] get-widget-config-by-type result:", m),
            {
                content: [{
                    type: "text",
                    text: JSON.stringify(m, null, 2)
                }]
            }
        }
        t.tool("get-widget-config-by-type", `Gets a list of all possible parameters of a specific Elementor widget type.
Must use it before **adding a new** Elementor widget, in order to have a correct understanding of the widgets's configuration parameters.`, {
            widgetType: a.string().describe("The type of the Elementor widget to get the settings of.")
        }, async ({widgetType: c}) => d(c));
        function u(c) {
            var h;
            console.log("[Elementor Server] get-current-element-settings", {
                elementId: c
            });
            const m = $a(c)
              , p = {
                values: {
                    ...(m == null ? void 0 : m.attributes) ?? {}
                },
                schema: l(((h = m.attributes) == null ? void 0 : h.widgetType) ?? "container")
            };
            return Object.keys(p.values).forEach(f => {
                var y;
                JSON.stringify(p.values[f]) === JSON.stringify(((y = p.schema[f]) == null ? void 0 : y.default_value) ?? "") && delete p.values[f]
            }
            ),
            console.log("[Commands Server] get-current-element-settings result:", p),
            {
                content: [{
                    type: "text",
                    text: JSON.stringify(p, null, 2)
                }]
            }
        }
        t.tool("get-current-element-settings", `Gets the current settings of a specific Elementor element.
Returns the current settings values and the schema for the element settings.
Must use it before **updating an existing** Elementor element, in order to have a correct understanding of the element's configuration parameters.`, {
            elementId: a.string().describe("The ID of the Elementor element to get the settings of.")
        }, async ({elementId: c}) => u(c)),
        t.tool("copy-element", "Copies a specific Elementor element (container, widget, etc.) to the internal Elementor clipboard using the `document/elements/copy` command. This content can then be pasted elsewhere.", {
            elementId: a.string().describe("The ID of the Elementor element (container) to copy.")
        }, async ({elementId: c}) => {
            console.log("[Elementor Server] copy-element", {
                elementId: c
            });
            const m = window.elementor.getContainer(c);
            if (!m)
                return {
                    content: [{
                        type: "text",
                        text: `Element with ID ${c} not found.`
                    }]
                };
            const p = await window.$e.run("document/elements/copy", {
                container: m
            });
            return console.log("[Commands Server] copy-element result:", p),
            {
                content: [{
                    type: "text",
                    text: `Element ${c} copied to clipboard.`
                }]
            }
        }
        ),
        t.tool("copy-all-elements", "Copies all root elements in the current Elementor page to the internal Elementor clipboard using `document/elements/copy-all`.", {}, async () => {
            console.log("[Elementor Server] copy-all-elements");
            const c = await window.$e.run("document/elements/copy-all");
            return console.log("[Commands Server] copy-all-elements result:", c),
            {
                content: [{
                    type: "text",
                    text: "All elements copied to clipboard."
                }]
            }
        }
        ),
        t.tool("create-widget", "Creates and inserts a new Elementor widget into the page structure. Widgets are content elements like headings, text, images, buttons, etc. USE THIS WHEN: You need to add specific content or functionality elements to your page. Widgets are the building blocks that contain actual content like text, images, videos, or interactive elements such as forms and buttons. Each widget serves a specific purpose. Widgets should always be placed inside containers. Must call get-widget-config-by-type and get-page-overview before calling this tool or the tool call will fail. You must use an available widgetType (types provided in the user context)", {
            widgetType: a.string().describe("The type of widget to create. MUST BE A VALID WIDGET TYPE TAKEN FROM THE AVAILABLE WIDGETS LIST."),
            settings: a.union([a.object({
                image: a.object({
                    url: Lc(zf)
                })
            }).passthrough().describe("Image widget settings"), a.any().refine(c => !(c && typeof c == "object" && "image"in c), {
                message: "Image settings must use the structured image object format."
            }).describe("Non-image widget settings. " + pu)]).describe("Widget settings"),
            parentId: a.string().optional().describe("The ID of the parent container to insert this widget into. If not provided, will use the document root container."),
            options: a.object({
                at: a.number().optional().describe("The index position where the widget should be inserted"),
                edit: a.boolean().optional().describe("Whether to switch to edit mode after creation")
            }).optional().describe("Options for widget creation"),
            wasGetWidgetSettingsToolCalled: a.boolean().describe("Whether the get-widget-config-by-type tool was called with this widget type anytime in the conversation before this command. If true, the settings object should match the widget settings schema."),
            wasGetPageOverviewToolCalled: a.boolean().describe("Whether the get-page-overview tool was called before this command. If true, the settings object should match the page overview schema.")
        }, async ({widgetType: c, settings: m, parentId: p, options: h, wasGetWidgetSettingsToolCalled: f, wasGetPageOverviewToolCalled: y}) => {
            var C, L;
            if (console.log("[Elementor Server] create-widget", {
                widgetType: c,
                settings: m,
                parentId: p,
                options: h
            }),
            !y || !f)
                throw new Error(`You must get the widget config and the page overview before calling this tool. 
I took the liberty to do it for you so you wouldn't need.
${f ? `Here is a list of all possible widget parameters:
"""
${JSON.stringify(d(c), null, 2)}
"""` : ""}

${y ? `Here is the page overview:
"""
${JSON.stringify(g(), null, 2)}
"""` : ""}

Now that you have the required knowledge you can recall this tool (create-widget). Make sure to set both wasGetWidgetSettingsToolCalled and wasGetPageOverviewToolCalled to true.`);
            if (!!!((L = (C = window.angieConfig) == null ? void 0 : C.plugins) != null && L.elementor_pro) && Object.keys(window.elementor.widgetsCache).filter(A => {
                var R, q;
                const $ = window.elementor.widgetsCache[A];
                return ((R = $.categories) == null ? void 0 : R.includes("pro-elements")) || ((q = $.categories) == null ? void 0 : q.includes("woocommerce-elements"))
            }
            ).includes(c))
                throw new Error(`Widget "${c}" is not available in this plan. Please upgrade to the Pro plan to use this widget.`);
            const x = {
                elType: "widget",
                widgetType: c,
                settings: m || {}
            }
              , v = o();
            let S = p ? window.elementor.getContainer(p) : window.elementor.getPreviewContainer();
            (!S || (S == null ? void 0 : S.type) !== "container") && (S = await window.$e.run("document/elements/create", {
                container: S,
                model: {
                    elType: "container"
                }
            }));
            const w = await window.$e.run("document/elements/create", {
                container: S,
                model: x,
                options: h || {}
            });
            if (w === !1)
                throw new Error(`Failed to create widget of type "${c}". Ensure that the parameters are correct.`);
            console.log("[Commands Server] create-widget result:", w);
            const _ = w
              , I = Array.isArray(_) ? _.map(N => N == null ? void 0 : N.id).filter(Boolean) : [_ == null ? void 0 : _.id].filter(Boolean);
            await n(v);
            const k = await i(m, I[0] ?? "");
            return {
                content: [{
                    type: "text",
                    text: `Widget "${c}" created with ID: ${I.join(", ")}${k && Object.keys(k).length > 0 ? " (with global styles applied)" : ""}`
                }]
            }
        }
        ),
        t.tool("create-container", "Creates and inserts a new Elementor container into the page structure. Containers are flexible layout elements that use flexbox or grid for positioning content. USE THIS WHEN: You need to create layout structures to organize your content. Containers act as structural elements that hold and organize widgets and other containers. They control the page layout using flex or grid display properties and provide the foundation for responsive design. Use containers to create rows, columns, sections, or any other structural divisions in your page. Containers can be nested inside other containers to create complex layouts.", {
            settings: a.object({
                content_width: a.enum(["boxed", "full"]).optional().describe("Container width type: boxed or full-width"),
                content_width_size: a.string().optional().describe('Width value when content_width is set to "boxed" (e.g., "1140px")'),
                display: a.enum(["flex", "grid"]).optional().describe("Container display type: flex (flexbox) or grid"),
                flex_direction: a.enum(["row", "column", "row-reverse", "column-reverse"]).optional().describe('Direction of flex items when display is "flex"'),
                flex_wrap: a.enum(["nowrap", "wrap", "wrap-reverse"]).optional().describe('Whether flex items should wrap when display is "flex"'),
                align_items: a.enum(["flex-start", "center", "flex-end", "stretch"]).optional().describe("Alignment of flex items along the cross axis"),
                justify_content: a.enum(["flex-start", "center", "flex-end", "space-between", "space-around", "space-evenly"]).optional().describe("Alignment of flex items along the main axis"),
                gap: a.object({
                    size: a.number().optional(),
                    unit: a.string().optional()
                }).optional().describe("Gap between flex or grid items"),
                background_color: a.string().optional().describe("Container background color, " + pu),
                background_image: a.object({
                    url: a.string(),
                    id: a.number().optional()
                }).optional().describe("Container background image"),
                padding: a.object({
                    top: a.string().optional(),
                    right: a.string().optional(),
                    bottom: a.string().optional(),
                    left: a.string().optional(),
                    unit: a.string().optional()
                }).optional().describe("Container padding"),
                margin: a.object({
                    top: a.string().optional(),
                    right: a.string().optional(),
                    bottom: a.string().optional(),
                    left: a.string().optional(),
                    unit: a.string().optional()
                }).optional().describe("Container margin")
            }).optional().describe("Container settings for layout and styling"),
            parentId: a.string().optional().describe("The ID of the parent container to insert this container into. If not provided, will use the document root container."),
            options: a.object({
                at: a.number().optional().describe("The index position where the container should be inserted"),
                edit: a.boolean().optional().describe("Whether to switch to edit mode after creation")
            }).optional().describe("Options for container creation")
        }, async ({settings: c, parentId: m, options: p}) => {
            console.log("[Elementor Server] create-container", {
                settings: c,
                parentId: m,
                options: p
            });
            const h = {
                elType: "container",
                settings: c || {}
            }
              , f = m ? window.elementor.getContainer(m) : window.elementor.getPreviewContainer()
              , y = await window.$e.run("document/elements/create", {
                container: f,
                model: h,
                options: p || {}
            });
            console.log("[Commands Server] create-container result:", y);
            const b = y
              , x = Array.isArray(b) ? b.map(S => S == null ? void 0 : S.id).filter(Boolean) : [b == null ? void 0 : b.id].filter(Boolean)
              , v = await i(c || {}, x[0] ?? "");
            return {
                content: [{
                    type: "text",
                    text: `Container created with ID: ${x.join(", ")}${v && Object.keys(v).length > 0 ? " (with global styles applied)" : ""}`
                }]
            }
        }
        ),
        t.tool("delete-element", "Deletes one or more Elementor elements (containers, widgets) from the page structure using `document/elements/delete`.", {
            elementIds: a.union([a.string(), a.array(a.string())]).describe("The ID or array of IDs of the Elementor element(s) to delete.")
        }, async ({elementIds: c}) => {
            console.log("[Elementor Server] delete-element", {
                elementIds: c
            });
            const p = (Array.isArray(c) ? c : [c]).map(b => window.elementor.getContainer(b)).filter(b => !!b);
            if (p.length === 0)
                return {
                    content: [{
                        type: "text",
                        text: "No valid elements found for the provided IDs."
                    }]
                };
            const h = await window.$e.run("document/elements/delete", {
                containers: p
            });
            console.log("[Commands Server] delete-element result:", h);
            const f = h;
            return {
                content: [{
                    type: "text",
                    text: `Element(s) deleted with ID(s): ${(Array.isArray(f) ? f.map(b => b == null ? void 0 : b.id).filter(Boolean) : [f == null ? void 0 : f.id].filter(Boolean)).join(", ")}`
                }]
            }
        }
        ),
        t.tool("duplicate-element", "Duplicates one or more Elementor elements (containers, widgets), creating identical copies adjacent to the originals using `document/elements/duplicate`.", {
            elementIds: a.union([a.string(), a.array(a.string())]).describe("The ID or array of IDs of the Elementor element(s) to duplicate.")
        }, async ({elementIds: c}) => {
            console.log("[Elementor Server] duplicate-element", {
                elementIds: c
            });
            const p = (Array.isArray(c) ? c : [c]).map(b => window.elementor.getContainer(b)).filter(b => !!b);
            if (p.length === 0)
                return {
                    content: [{
                        type: "text",
                        text: "No valid elements found for the provided IDs."
                    }]
                };
            const h = await window.$e.run("document/elements/duplicate", {
                containers: p
            });
            console.log("[Commands Server] duplicate-element result:", h);
            const f = h;
            return {
                content: [{
                    type: "text",
                    text: `Element(s) duplicated. New ID(s): ${(Array.isArray(f) ? f.map(b => b == null ? void 0 : b.id).filter(Boolean) : [f == null ? void 0 : f.id].filter(Boolean)).join(", ")}`
                }]
            }
        }
        ),
        t.tool("empty-container", "Removes all child elements from within a specific Elementor container element using `document/elements/empty`. Only applicable to containers.", {
            elementId: a.string().describe("The ID of the Elementor container element to empty.")
        }, async ({elementId: c}) => {
            console.log("[Elementor Server] empty-container", {
                elementId: c
            });
            const m = window.elementor.getContainer(c);
            if (!m)
                return {
                    content: [{
                        type: "text",
                        text: `Container with ID ${c} not found.`
                    }]
                };
            const p = await window.$e.run("document/elements/empty", {
                container: m
            });
            return console.log("[Commands Server] empty-container result:", p),
            {
                content: [{
                    type: "text",
                    text: `Container ${c} emptied.`
                }]
            }
        }
        ),
        t.tool("import-elements", "Imports Elementor elements from a data structure (e.g., from a file or template export) into the page using `document/elements/import`.", {
            data: a.object({
                content: a.array(gu).optional(),
                page_settings: a.record(a.unknown()).optional(),
                metadata: a.record(a.unknown()).optional()
            }).describe("The data to import (structure depends on Elementor format)."),
            options: a.object({
                at: a.number().optional().describe("The index position where the imported content should be inserted"),
                container: gu.optional().describe("The target container to import into"),
                withPageSettings: a.boolean().optional().describe("Whether to import page settings")
            }).optional().describe("Options for import")
        }, async ({data: c, options: m}) => {
            console.log("[Elementor Server] import-elements", {
                data: c,
                options: m
            });
            const p = await window.$e.run("document/elements/import", {
                data: c,
                options: m || {}
            });
            return console.log("[Commands Server] import-elements result:", p),
            {
                content: [{
                    type: "text",
                    text: "Elements import process completed."
                }]
            }
        }
        ),
        t.tool("paste-element", "Pastes element(s) from the internal Elementor clipboard into a specified target container or the document root using `document/elements/paste`. Requires a prior copy action.", {
            targetElementId: a.string().optional().describe("The ID of the target container element. If omitted, pastes into the document root."),
            options: a.object({
                at: a.number().optional().describe("The index position where the pasted content should be inserted"),
                rebuild: a.boolean().optional().describe("Whether to rebuild the container after pasting"),
                withStyle: a.boolean().optional().describe("Whether to paste styles with the content")
            }).optional().describe("Options for pasting")
        }, async ({targetElementId: c, options: m}) => {
            console.log("[Elementor Server] paste-element", {
                targetElementId: c,
                options: m
            });
            const p = c ? window.elementor.getContainer(c) : void 0
              , h = {
                ...p ? {
                    container: p
                } : {},
                ...m || {}
            }
              , f = await window.$e.run("document/elements/paste", h);
            console.log("[Commands Server] paste-element result:", f);
            const y = f
              , b = Array.isArray(y) ? y.map(v => v == null ? void 0 : v.id).filter(Boolean) : [y == null ? void 0 : y.id].filter(Boolean);
            return {
                content: [{
                    type: "text",
                    text: `Element(s) pasted ${c ? `into container ${c}` : "into document root"}. New ID(s): ${b.join(", ")}`
                }]
            }
        }
        ),
        t.tool("paste-element-style", "Pastes only the style attributes from the Elementor clipboard onto a target element using `document/elements/paste-style`. Requires a prior copy action.", {
            targetElementId: a.string().describe("The ID of the Elementor element (container) to paste the style onto.")
        }, async ({targetElementId: c}) => {
            console.log("[Elementor Server] paste-element-style", {
                targetElementId: c
            });
            const m = window.elementor.getContainer(c);
            if (!m)
                return {
                    content: [{
                        type: "text",
                        text: `Element with ID ${c} not found.`
                    }]
                };
            const p = await window.$e.run("document/elements/paste-style", {
                container: m
            });
            return console.log("[Commands Server] paste-element-style result:", p),
            {
                content: [{
                    type: "text",
                    text: `Style pasted onto element ${c}.`
                }]
            }
        }
        ),
        t.tool("reset-element-style", "Resets the style settings of an Elementor element to their default values using `document/elements/reset-style`.", {
            elementId: a.string().describe("The ID of the Elementor element (container) to reset the style of.")
        }, async ({elementId: c}) => {
            console.log("[Elementor Server] reset-element-style", {
                elementId: c
            });
            const m = window.elementor.getContainer(c);
            if (!m)
                return {
                    content: [{
                        type: "text",
                        text: `Element with ID ${c} not found.`
                    }]
                };
            const p = await window.$e.run("document/elements/reset-style", {
                container: m
            });
            return console.log("[Commands Server] reset-element-style result:", p),
            {
                content: [{
                    type: "text",
                    text: `Style reset for element ${c}.`
                }]
            }
        }
        ),
        t.tool("select-element", "Selects a specific Elementor element in the editor UI, highlighting it and typically opening its settings panel, using `document/elements/select`.", {
            elementId: a.string().describe("The ID of the Elementor element (container) to select.")
        }, async ({elementId: c}) => {
            console.log("[Elementor Server] select-element", {
                elementId: c
            });
            const m = window.elementor.getContainer(c);
            if (!m)
                return {
                    content: [{
                        type: "text",
                        text: `Element with ID ${c} not found.`
                    }]
                };
            const p = await window.$e.run("document/elements/select", {
                container: m
            });
            return console.log("[Commands Server] select-element result:", p),
            {
                content: [{
                    type: "text",
                    text: `Element ${c} selected.`
                }]
            }
        }
        ),
        t.tool("deselect-element", "Deselects a specific Elementor element in the editor UI, removing the selection highlight, using `document/elements/deselect`.", {
            elementId: a.string().describe("The ID of the Elementor element (container) to deselect.")
        }, async ({elementId: c}) => {
            console.log("[Elementor Server] deselect-element", {
                elementId: c
            });
            const m = window.elementor.getContainer(c);
            if (!m)
                return {
                    content: [{
                        type: "text",
                        text: `Element with ID ${c} not found.`
                    }]
                };
            const p = await window.$e.run("document/elements/deselect", {
                container: m
            });
            return console.log("[Commands Server] deselect-element result:", p),
            {
                content: [{
                    type: "text",
                    text: `Element ${c} deselected.`
                }]
            }
        }
        ),
        t.tool("deselect-all-elements", "Deselects all currently selected Elementor elements in the editor UI using `document/elements/deselect-all`.", {}, async () => {
            console.log("[Elementor Server] deselect-all-elements");
            const c = await window.$e.run("document/elements/deselect-all");
            return console.log("[Commands Server] deselect-all-elements result:", c),
            {
                content: [{
                    type: "text",
                    text: "All elements deselected."
                }]
            }
        }
        ),
        t.tool("toggle-element-selection", "Toggles the selection state (selected/deselected) of a specific Elementor element in the editor UI using `document/elements/toggle-selection`.", {
            elementId: a.string().describe("The ID of the Elementor element (container) to toggle selection for.")
        }, async ({elementId: c}) => {
            console.log("[Elementor Server] toggle-element-selection", {
                elementId: c
            });
            const m = window.elementor.getContainer(c);
            if (!m)
                return {
                    content: [{
                        type: "text",
                        text: `Element with ID ${c} not found.`
                    }]
                };
            const p = await window.$e.run("document/elements/toggle-selection", {
                container: m
            });
            return console.log("[Commands Server] toggle-element-selection result:", p),
            {
                content: [{
                    type: "text",
                    text: `Selection toggled for element ${c}.`
                }]
            }
        }
        ),
        t.tool("select-multiple-elements", "Selects multiple Elementor elements simultaneously in the editor UI, highlighting them all at once. This bulk operation is much more efficient than calling select-element multiple times when you need to select many elements. Use when performing operations on a group of elements or when you need to visualize multiple elements' relationships.", {
            elementIds: a.union([a.string(), a.array(a.string())]).describe("A single element ID or an array of element IDs to select all at once.")
        }, async ({elementIds: c}) => {
            console.log("[Elementor Server] select-multiple-elements", {
                elementIds: c
            });
            const p = (Array.isArray(c) ? c : [c]).map(f => window.elementor.getContainer(f)).filter(f => !!f);
            if (p.length === 0)
                return {
                    content: [{
                        type: "text",
                        text: "No valid elements found for the provided IDs."
                    }]
                };
            const h = [];
            for (const f of p)
                try {
                    await window.$e.run("document/elements/select", {
                        container: f
                    }),
                    h.push(f.id)
                } catch (y) {
                    console.error(`Error selecting element ${f.id}:`, y)
                }
            return console.log("[Commands Server] select-multiple-elements result:", h),
            {
                content: [{
                    type: "text",
                    text: h.length > 0 ? `Multiple elements selected: ${h.join(", ")}` : "No elements were successfully selected."
                }]
            }
        }
        ),
        t.tool("update-multiple-elements-settings", "Updates the settings (style, content, advanced) of multiple Elementor elements with the same settings object. This is much more efficient than calling update-element-settings multiple times when you need to apply identical styling or configuration to multiple elements. Perfect for batch operations like changing text color, padding, or other properties across a group of elements.", {
            elementIds: a.union([a.string(), a.array(a.string())]).describe("A single element ID or an array of element IDs to update with the same settings."),
            settings: a.any().describe("A single settings object containing the properties to apply to ALL specified elements."),
            options: a.object({
                external: a.boolean().optional().describe("Whether this is an external update"),
                render: a.boolean().optional().describe("Whether to render changes immediately")
            }).optional().describe("Optional settings for the command execution, e.g., { external: true }.")
        }, async ({elementIds: c, settings: m, options: p}) => {
            console.log("[Elementor Server] update-multiple-elements-settings", {
                elementIds: c,
                settings: m,
                options: p
            });
            const f = (Array.isArray(c) ? c : [c]).map(b => window.elementor.getContainer(b)).filter(b => !!b);
            if (f.length === 0)
                return {
                    content: [{
                        type: "text",
                        text: "No valid elements found for the provided IDs."
                    }]
                };
            const y = [];
            for (const b of f)
                try {
                    await window.$e.run("document/elements/settings", {
                        container: b,
                        settings: m,
                        options: p || {}
                    }),
                    y.push(b.id)
                } catch (x) {
                    console.error(`Error updating settings for element ${b.id}:`, x)
                }
            return console.log("[Commands Server] update-multiple-elements-settings result:", y),
            {
                content: [{
                    type: "text",
                    text: y.length > 0 ? `Settings updated for multiple elements: ${y.join(", ")}` : "No elements were successfully updated."
                }]
            }
        }
        ),
        t.tool("move-element", "Moves an Elementor element within the page structure to a new position relative to a target element (before, after, or inside) using `document/elements/move`.", {
            elementId: a.string().describe("The ID of the Elementor element (container) to move."),
            targetElementId: a.string().describe("The ID of the target Elementor element (container) to move relative to."),
            position: a.enum(["before", "after", "inside"]).describe('Position relative to the target: "before", "after", or "inside" (if target is a container).'),
            wasGetPageOverviewToolCalled: a.boolean().describe("Whether the get-page-overview tool was called before this command. If true, the targetElementId should match the page overview schema.")
        }, async ({elementId: c, targetElementId: m, position: p, wasGetPageOverviewToolCalled: h}) => {
            if (console.log("[Elementor Server] move-element", {
                elementId: c,
                targetElementId: m,
                position: p
            }),
            !h)
                throw new Error(`You must get the widget config and the page overview before calling this tool. 
I took the liberty to do it for you so you wouldn't need.
Here is the page overview:
"""
${JSON.stringify(g(), null, 2)}
"""

Now that you have the required knowledge you can recall this tool (move-element). Make sure to set wasGetPageOverviewToolCalled to true.
`);
            const f = window.elementor.getContainer(c);
            if (!f)
                return {
                    content: [{
                        type: "text",
                        text: `Element to move (ID ${c}) not found.`
                    }]
                };
            const y = window.elementor.getContainer(m);
            if (!y)
                return {
                    content: [{
                        type: "text",
                        text: `Target element (ID ${m}) not found.`
                    }]
                };
            if (p === "inside") {
                const k = y
                  , C = {
                    container: f,
                    target: k,
                    options: {
                        container: k
                    }
                }
                  , L = await window.$e.run("document/elements/move", C);
                return console.log("[Commands Server] move-element (inside) result:", L),
                {
                    content: [{
                        type: "text",
                        text: `Element ${c} moved ${p} element ${m}.`
                    }]
                }
            }
            const x = y.parent;
            if (!x)
                return {
                    content: [{
                        type: "text",
                        text: `Target element (ID ${m}) has no parent container.`
                    }]
                };
            const S = (Array.isArray(x.children) ? x.children : []).findIndex(k => k.id === m);
            if (S === -1)
                return {
                    content: [{
                        type: "text",
                        text: `Target element (ID ${m}) not found within its parent.`
                    }]
                };
            const w = p === "before" ? S : S + 1
              , _ = {
                container: f,
                target: x,
                options: {
                    at: w,
                    container: x
                }
            }
              , I = await window.$e.run("document/elements/move", _);
            return console.log("[Commands Server] move-element (before/after) result:", I),
            {
                content: [{
                    type: "text",
                    text: `Element ${c} moved ${p} element ${m}.`
                }]
            }
        }
        ),
        t.tool("reset-element-settings", "Resets the *content* settings (e.g., text in a heading, image source) of an Elementor element to their defaults using `document/elements/reset-settings`. Does not affect styles.", {
            elementId: a.string().describe("The ID of the Elementor element (container) to reset the settings of.")
        }, async ({elementId: c}) => {
            console.log("[Elementor Server] reset-element-settings", {
                elementId: c
            });
            const m = window.elementor.getContainer(c);
            if (!m)
                return {
                    content: [{
                        type: "text",
                        text: `Element with ID ${c} not found.`
                    }]
                };
            const p = await window.$e.run("document/elements/reset-settings", {
                container: m
            });
            return console.log("[Commands Server] reset-element-settings result:", p),
            {
                content: [{
                    type: "text",
                    text: `Content settings reset for element ${c}.`
                }]
            }
        }
        ),
        t.tool("history-undo", 'Performs an "Undo" action in the Elementor editor, reverting the last change recorded in the history stack, using `document/history/undo`.', {}, async () => {
            console.log("[Elementor Server] history-undo");
            const c = await window.$e.run("document/history/undo");
            return console.log("[Commands Server] history-undo result:", c),
            {
                content: [{
                    type: "text",
                    text: "Last action undone."
                }]
            }
        }
        ),
        t.tool("history-redo", 'Performs a "Redo" action in the Elementor editor, reapplying the last undone change from the history stack, using `document/history/redo`.', {}, async () => {
            console.log("[Elementor Server] history-redo");
            const c = await window.$e.run("document/history/redo");
            return console.log("[Commands Server] history-redo result:", c),
            {
                content: [{
                    type: "text",
                    text: "Last undone action redone."
                }]
            }
        }
        ),
        t.tool("history-undo-all", "Reverts *all* changes made in the current editing session back to the state when the editor was loaded, using `document/history/undo-all`. Use with extreme caution.", {}, async () => {
            console.log("[Elementor Server] history-undo-all");
            const c = await window.$e.run("document/history/undo-all");
            return console.log("[Commands Server] history-undo-all result:", c),
            {
                content: [{
                    type: "text",
                    text: "All changes in the session reverted."
                }]
            }
        }
        ),
        t.tool("save-page-draft", "Saves the current Elementor page state as a draft using `document/save/draft`.", {}, async () => {
            console.log("[Elementor Server] save-page-draft");
            const c = await window.$e.run("document/save/draft");
            return console.log("[Commands Server] save-page-draft result:", c),
            {
                content: [{
                    type: "text",
                    text: "page saved as draft."
                }]
            }
        }
        ),
        t.tool("save-page-publish", "Publishes or schedules the current Elementor document, making it live (or scheduled), using `document/save/publish`.", {}, async () => {
            console.log("[Elementor Server] save-page-publish");
            const c = await window.$e.run("document/save/publish");
            return console.log("[Commands Server] save-page-publish result:", c),
            {
                content: [{
                    type: "text",
                    text: "page published."
                }]
            }
        }
        ),
        t.tool("save-page-update", "Updates the currently saved/published Elementor page with the latest changes using `document/save/update`. This is the standard save operation.", {}, async () => {
            console.log("[Elementor Server] save-page-update");
            const c = await window.$e.run("document/save/update");
            return console.log("[Commands Server] save-page-update result:", c),
            {
                content: [{
                    type: "text",
                    text: "page updated."
                }]
            }
        }
        ),
        t.tool("save-page-discard", "Discards any unsaved changes made to the page since the last save, reloading the last saved state, using `document/save/discard`. Unsaved work will be lost.", {}, async () => {
            console.log("[Elementor Server] save-page-discard");
            const c = await window.$e.run("document/save/discard");
            return console.log("[Commands Server] save-page-discard result:", c),
            {
                content: [{
                    type: "text",
                    text: "Unsaved changes discarded."
                }]
            }
        }
        ),
        t.tool("paste-area", "Pastes the *child elements* of a previously copied container/section into a target container using `document/elements/paste-area`. Useful for transferring content between containers.", {
            targetElementId: a.string().describe("The ID of the target Elementor container to paste content into.")
        }, async ({targetElementId: c}) => {
            console.log("[Elementor Server] paste-area", {
                targetElementId: c
            });
            const m = window.elementor.getContainer(c);
            if (!m)
                return {
                    content: [{
                        type: "text",
                        text: `Target container with ID ${c} not found.`
                    }]
                };
            const p = await window.$e.run("document/elements/paste-area", {
                container: m
            });
            return console.log("[Commands Server] paste-area result:", p),
            {
                content: [{
                    type: "text",
                    text: `Copied content pasted into container ${c}.`
                }]
            }
        }
        ),
        t.tool("select-all-elements", "Selects all elements in the page or within a specific container in the editor UI using `document/elements/select-all`.", {
            containerElementId: a.string().optional().describe("The ID of the container element to select all children within. If omitted, selects all top-level elements.")
        }, async ({containerElementId: c}) => {
            console.log("[Elementor Server] select-all-elements", {
                containerElementId: c
            });
            const m = {};
            if (c) {
                const f = window.elementor.getContainer(c);
                if (!f)
                    return {
                        content: [{
                            type: "text",
                            text: `Container with ID ${c} not found.`
                        }]
                    };
                m.container = f
            }
            const p = await window.$e.run("document/elements/select-all", m);
            return console.log("[Commands Server] select-all-elements result:", p),
            {
                content: [{
                    type: "text",
                    text: `All elements ${c ? `within container ${c}` : "in the document"} selected.`
                }]
            }
        }
        ),
        t.tool("get-current-selection", "Gets detailed information about the currently selected Elementor element(s), including ID, type, widget type, and settings.", {}, async () => {
            var c;
            console.log("[Elementor Server] get-current-selection");
            try {
                const m = window.elementor;
                if (!m.getCurrentElement)
                    return {
                        content: [{
                            type: "text",
                            text: "getCurrentElement method is not available in this Elementor version."
                        }]
                    };
                const p = m.getCurrentElement();
                if (!p)
                    return {
                        content: [{
                            type: "text",
                            text: "No element is currently selected in the editor."
                        }]
                    };
                const h = p.model
                  , f = h.id
                  , y = m.getContainer(f);
                if (!y)
                    return {
                        content: [{
                            type: "text",
                            text: `Current element (ID: ${f}) container not found.`
                        }]
                    };
                const b = h.get("elType") || "unknown"
                  , x = h.get("widgetType") || "none";
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify({
                            id: f,
                            elementType: b,
                            widgetType: x,
                            isInner: !!h.get("isInner"),
                            settings: ((c = y.settings) == null ? void 0 : c.attributes) || {}
                        }, null, 2)
                    }]
                }
            } catch (m) {
                throw console.error("[Elementor Server] Error retrieving current selection:", m),
                new Error(`Error retrieving current selection: ${m}`)
            }
        }
        );
        function g() {
            console.log("[Elementor Server] get-page-overview");
            function c(m) {
                var y, b, x, v;
                if (!m)
                    return null;
                const p = m
                  , h = {
                    id: p.id || "unknown",
                    type: p.type
                };
                h.type === "widget" && (h.widgetType = (b = (y = p.model) == null ? void 0 : y.attributes) == null ? void 0 : b.widgetType),
                h.type = p.type;
                const f = (x = p.settings) == null ? void 0 : x.attributes;
                return f && (h.settings = {
                    content: f.title || f.editor || f.text || f.content,
                    text_color: f.text_color || f.title_color,
                    background_color: f._background_color || f.background_color,
                    font_size: f == null ? void 0 : f.typography_font_size,
                    width: f.content_width_size,
                    flex_direction: f.flex_direction,
                    align_items: f.align_items,
                    justify_content: f.justify_content
                },
                Object.keys(h.settings).forEach(S => {
                    h.settings[S] === void 0 && delete h.settings[S]
                }
                )),
                (v = p.children) != null && v.length && (h.children = p.children.map(S => c(S))),
                h
            }
            try {
                const m = window.elementor.getContainer("document");
                if (!m)
                    return {
                        content: [{
                            type: "text",
                            text: "Document container not found."
                        }]
                    };
                const p = c(m);
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(p, null, 2)
                    }]
                }
            } catch (m) {
                throw console.error("[Elementor Server] Error getting page overview:", m),
                new Error(`Error getting page overview: ${m}`)
            }
        }
        return t.tool("get-page-overview", `Retrieves the entire hierarchical structure of the current Elementor page as a nested object/JSON, showing elements and their relationships.
USE THIS WHEN: You need to analyze the whole page structure, understand the complete layout, or need comprehensive information about all elements on the page.
This is helpful for tasks requiring a complete overview of the current page content and structure.
Must use it before adding new elements or making structural changes like moving elements to ensure you have the latest state of the page.`, {}, async () => g()),
        t.tool("get-element-path", 'Gets the hierarchy path (breadcrumbs) for a specific element, showing its lineage from the document root (e.g., "Document > Section (123) > Column (456) > Heading (789)").', {
            elementId: a.string().describe("The ID of the Elementor element to get the path for.")
        }, async ({elementId: c}) => {
            var m, p;
            console.log("[Elementor Server] get-element-path", {
                elementId: c
            });
            try {
                const h = window.elementor.getContainer(c);
                if (!h)
                    return {
                        content: [{
                            type: "text",
                            text: `Element with ID ${c} not found.`
                        }]
                    };
                const f = [];
                let y = h;
                for (; y; ) {
                    const b = y
                      , x = ((m = b.model) == null ? void 0 : m.get("elType")) || "unknown"
                      , v = x === "widget" ? `${((p = b.model) == null ? void 0 : p.get("widgetType")) || "Widget"} (${b.id})` : `${x.charAt(0).toUpperCase() + x.slice(1)} (${b.id})`;
                    f.unshift(v),
                    y = b.parent
                }
                return {
                    content: [{
                        type: "text",
                        text: f.join(" > ")
                    }]
                }
            } catch (h) {
                throw console.error("[Elementor Server] Error getting element path:", h),
                new Error(`Error getting element path: ${h}`)
            }
        }
        ),
        t.tool("get-dynamic-settings", 'Gets dynamic settings for a specific element, including the list of field names that currently have dynamic content applied (like "editor", "url", "text", "css_post_id", etc.). Shows which element settings support dynamic content, which ones are currently dynamic, and lists all available dynamic tags. Returns field names in `dynamicFieldNames` array and detailed info in `dynamicFieldsInfo` object.', {
            elementId: a.string().describe("Current selected get always from in every request new id selectedElementId if not explicitly mentioned other element"),
            controlName: a.string().describe("The name of the control to get the dynamic settings for.")
        }, async ({elementId: c, controlName: m}) => {
            console.log("[Elementor Server] get-dynamic-settings", {
                elementId: c
            });
            const p = window.elementor.getContainer(c);
            if (!p)
                return {
                    content: [{
                        type: "text",
                        text: `Element with ID ${c} not found.`
                    }]
                };
            const h = p.settings.controls
              , {categories: f} = h[m].dynamic
              , y = Object.values(window.elementor.dynamicTags.getConfig("tags")).filter(b => b.categories.find(x => f.includes(x)));
            return console.log("[Commands Server] get-dynamic-settings result:", y),
            {
                content: [{
                    type: "text",
                    text: JSON.stringify(y, null, 2)
                }]
            }
        }
        ),
        t.tool("link-to-dynamic-content", "Connects element properties to dynamic WordPress data that updates automatically (e.g., link a heading to display the current Post Title, or connect an image to the Featured Image). This tool creates live data connections rather than setting static values. Use this when you want element content to automatically reflect WordPress post data, site information, or other dynamic sources. The connected property will update automatically whenever the underlying data changes. Different from update-element-settings which sets fixed values - this creates dynamic relationships with WordPress content.", {
            elementId: a.string().refine(c => c.length > 0, {
                message: "Element ID is required"
            }).describe("The ID of the Elementor element to enable dynamic content for."),
            controlName: a.string().refine(c => c.length > 0, {
                message: "Control name is required"
            }).describe('The name of the control/field to enable dynamic content for (e.g., "text", "title", "url"). This is the element setting that will become dynamic. Will be automatically converted to lowercase with dashes instead of spaces.'),
            dynamicName: a.string().refine(c => c.length > 0, {
                message: "Dynamic name is required"
            }).describe("The name of the dynamic tag to enable. output of get-dynamic-settings tool"),
            settings: a.object({}).catchall(a.unknown()).describe("The settings to apply to the dynamic tag. output of get-dynamic-settings tool"),
            hasRanGetDynamicSettings: a.boolean().refine(c => c === !0, {
                message: "get-dynamic-settings tool has not been run. run it first before using this tool."
            }).describe("Whether the get-dynamic-settings tool has already been run.")
        }, async ({elementId: c, controlName: m, dynamicName: p, settings: h}) => {
            console.log("[Elementor Server] dynamic-enable", {
                elementId: c,
                controlName: m,
                dynamicName: p,
                settings: h
            }),
            p = p.toLowerCase().replace(/\s+/g, "-").replace(/_/g, "-").replace(/[^a-z0-9-]/g, "");
            const f = window.elementor.getContainer(c);
            if (!f)
                return {
                    content: [{
                        type: "text",
                        text: `Element with ID ${c} not found.`
                    }]
                };
            h.toJSON = () => h;
            const y = window.elementorCommon.helpers.getUniqueId()
              , b = window.elementor.dynamicTags.tagDataToTagText(y, p, h)
              , x = await window.$e.run("document/dynamic/enable", {
                container: f,
                settings: {
                    [m]: b
                }
            });
            return console.log("[Commands Server] dynamic-enable result:", x),
            {
                content: [{
                    type: "text",
                    text: `Dynamic content enabled for element ${c}, control "${m}" with dynamic tag "${p}": ${b}`
                }]
            }
        }
        ),
        t.tool("dynamic-disable", "Disables dynamic tags from specific element controls, converting them back to static content. Use this when you want to unlink dynamic content (like Post Title, Site Name, etc.) from element fields and make them manually editable again.", {
            elementId: a.string().describe("The ID of the Elementor element to disable dynamic content for."),
            settingName: a.string().describe("The setting name to disable dynamic content for.").transform(c => c.toLowerCase()).nullable()
        }, async ({elementId: c, settingName: m}) => {
            console.log("[Elementor Server] dynamic-disable", {
                elementId: c,
                settingName: m
            });
            const p = window.elementor.getContainer(c);
            if (!p)
                return {
                    content: [{
                        type: "text",
                        text: `Element with ID ${c} not found.`
                    }]
                };
            const h = ZE(p).settingsNames;
            if (!m)
                return {
                    content: [{
                        type: "text",
                        text: `No setting name provided. here is the list of dynamic settings available: ${JSON.stringify(h, null, 2)}`
                    }]
                };
            if (!h.includes(m))
                return {
                    content: [{
                        type: "text",
                        text: `Setting "${m}" on element ${c} does not have dynamic content enabled. here is the list of dynamic settings available: ${JSON.stringify(h, null, 2)}`
                    }]
                };
            const f = await window.$e.run("document/dynamic/disable", {
                container: p,
                settings: {
                    [m]: ""
                }
            });
            return console.log("[Commands Server] dynamic-disable result:", f),
            {
                content: [{
                    type: "text",
                    text: `Dynamic content disabled for setting "${m}" on element ${c}.`
                }]
            }
        }
        ),
        t.tool("globals-enable", 'Links specific settings of THIS ELEMENT to existing site-wide Global Styles (Colors or Typography) using `document/globals/enable`. This applies global styling to the specific element/container only, ensuring design consistency. You can use simple color names like "primary", "secondary" - they will be automatically converted to the proper global format.', {
            elementId: a.string().describe("The ID of the Elementor element to update."),
            settings: a.object({}).catchall(a.unknown()).describe('An object containing the settings to apply to the element as a valid Elementor globals settings object, colors/typography, Put Elementor global format directly (like primary, secondary, accent, text) for example: {"background_color": "primary", "title_color": "secondary", "typography_typography": "primary"}')
        }, async ({elementId: c, settings: m}) => {
            console.log("[Elementor Server] globals-enable", {
                elementId: c,
                settings: m
            });
            const p = window.elementor.getContainer(c);
            if (!p)
                return {
                    content: [{
                        type: "text",
                        text: `Element with ID ${c} not found.`
                    }]
                };
            const h = s(m)
              , f = await window.$e.run("document/globals/enable", {
                container: p,
                settings: h
            });
            return console.log("[Commands Server] globals-enable result:", f),
            {
                content: [{
                    type: "text",
                    text: `Global styling enabled for element ${c}.`
                }]
            }
        }
        ),
        t.tool("globals-disable", "Detaches a specific element setting from its linked Global Style, allowing local overrides without affecting the Global Style itself, using `document/globals/disable`.", {
            elementId: a.string().describe("The ID of the Elementor element to disable global styling for."),
            settings: a.record(a.unknown()).describe("The setting key(s) to disable global linking for.")
        }, async ({elementId: c, settings: m}) => {
            console.log("[Elementor Server] globals-disable", {
                elementId: c,
                settings: m
            });
            const p = window.elementor.getContainer(c);
            if (!p)
                return {
                    content: [{
                        type: "text",
                        text: `Element with ID ${c} not found.`
                    }]
                };
            const h = await window.$e.run("document/globals/disable", {
                container: p,
                settings: m
            });
            return console.log("[Commands Server] globals-disable result:", h),
            {
                content: [{
                    type: "text",
                    text: `Global styling disabled for element ${c}.`
                }]
            }
        }
        ),
        t.tool("repeater-insert", "Inserts a new item (row) into a repeater control field within an element's settings using `document/repeater/insert`.", {
            elementId: a.string().describe("The ID of the Elementor element containing the repeater."),
            name: a.string().describe("The name (key) of the repeater control field."),
            index: a.number().optional().describe("The 0-based index at which to insert the new item. If omitted, usually adds to the end."),
            options: a.object({
                defaultValues: a.record(a.union([a.string(), a.number(), a.boolean(), a.array(a.unknown()), a.record(a.unknown())])).optional().describe("Default values for the new repeater item"),
                silent: a.boolean().optional().describe("Whether to run the command silently without triggering UI updates")
            }).optional().describe("Additional options for the insertion")
        }, async ({elementId: c, name: m, index: p, options: h}) => {
            console.log("[Elementor Server] repeater-insert", {
                elementId: c,
                name: m,
                index: p,
                options: h
            });
            const f = window.elementor.getContainer(c);
            if (!f)
                return {
                    content: [{
                        type: "text",
                        text: `Element with ID ${c} not found.`
                    }]
                };
            const y = await window.$e.run("document/repeater/insert", {
                container: f,
                name: m,
                index: p,
                options: h || {}
            });
            return console.log("[Commands Server] repeater-insert result:", y),
            {
                content: [{
                    type: "text",
                    text: `Item inserted in repeater field '${m}' for element ${c}.`
                }]
            }
        }
        ),
        t.tool("repeater-remove", "Removes an item (row) from a specific index within a repeater control field using `document/repeater/remove`.", {
            elementId: a.string().describe("The ID of the Elementor element containing the repeater."),
            name: a.string().describe("The name (key) of the repeater control field."),
            index: a.number().describe("The 0-based index of the item to remove.")
        }, async ({elementId: c, name: m, index: p}) => {
            console.log("[Elementor Server] repeater-remove", {
                elementId: c,
                name: m,
                index: p
            });
            const h = window.elementor.getContainer(c);
            if (!h)
                return {
                    content: [{
                        type: "text",
                        text: `Element with ID ${c} not found.`
                    }]
                };
            const f = await window.$e.run("document/repeater/remove", {
                container: h,
                name: m,
                index: p
            });
            return console.log("[Commands Server] repeater-remove result:", f),
            {
                content: [{
                    type: "text",
                    text: `Item removed from repeater field '${m}' at index ${p} for element ${c}.`
                }]
            }
        }
        ),
        t.tool("repeater-duplicate", "Duplicates an existing item (row) at a specific index within a repeater control field using `document/repeater/duplicate`.", {
            elementId: a.string().describe("The ID of the Elementor element containing the repeater."),
            name: a.string().describe("The name (key) of the repeater control field."),
            index: a.number().describe("The 0-based index of the item to duplicate.")
        }, async ({elementId: c, name: m, index: p}) => {
            console.log("[Elementor Server] repeater-duplicate", {
                elementId: c,
                name: m,
                index: p
            });
            const h = window.elementor.getContainer(c);
            if (!h)
                return {
                    content: [{
                        type: "text",
                        text: `Element with ID ${c} not found.`
                    }]
                };
            const f = await window.$e.run("document/repeater/duplicate", {
                container: h,
                name: m,
                index: p
            });
            return console.log("[Commands Server] repeater-duplicate result:", f),
            {
                content: [{
                    type: "text",
                    text: `Item duplicated in repeater field '${m}' at index ${p} for element ${c}.`
                }]
            }
        }
        ),
        t.tool("repeater-move", "Moves an item (row) within a repeater control field from a source index to a target index, changing its order, using `document/repeater/move`.", {
            elementId: a.string().describe("The ID of the Elementor element containing the repeater."),
            name: a.string().describe("The name (key) of the repeater control field."),
            sourceIndex: a.number().describe("The current 0-based index of the item to move."),
            targetIndex: a.number().describe("The target 0-based index for the item.")
        }, async ({elementId: c, name: m, sourceIndex: p, targetIndex: h}) => {
            console.log("[Elementor Server] repeater-move", {
                elementId: c,
                name: m,
                sourceIndex: p,
                targetIndex: h
            });
            const f = window.elementor.getContainer(c);
            if (!f)
                return {
                    content: [{
                        type: "text",
                        text: `Element with ID ${c} not found.`
                    }]
                };
            const y = await window.$e.run("document/repeater/move", {
                container: f,
                name: m,
                sourceIndex: p,
                targetIndex: h
            });
            return console.log("[Commands Server] repeater-move result:", y),
            {
                content: [{
                    type: "text",
                    text: `Item moved in repeater field '${m}' from index ${p} to ${h} for element ${c}.`
                }]
            }
        }
        ),
        t.tool("open-page", "Opens a different WordPress post/page/template for editing within the Elementor editor interface using `editor/documents/open`.", {
            id: a.union([a.string(), a.number()]).describe("The WordPress Post ID of the page to open.")
        }, async ({id: c}) => {
            console.log("[Elementor Server] open-page ", {
                id: c
            });
            const m = await window.$e.run("editor/documents/open", {
                id: c
            });
            return console.log("[Commands Server] open-page result:", m),
            {
                content: [{
                    type: "text",
                    text: `page ${c} opened in the editor.`
                }]
            }
        }
        ),
        t.tool("preview-page", "Opens the live preview of the current page in a new tab or triggers the editor's preview mode using `editor/documents/preview`.", {}, async () => {
            console.log("[Elementor Server] preview-page ");
            const m = window.elementor.documents.getCurrent().id
              , p = await window.$e.run("editor/documents/preview", {
                id: m
            });
            return console.log("[Commands Server] preview-page result:", p),
            {
                content: [{
                    type: "text",
                    text: "page preview opened."
                }]
            }
        }
        ),
        t.tool("open-library", "Opens the Elementor Template Library modal, allowing users to browse and insert templates, blocks, or pages, using `library/open`.", {
            config: a.object({
                filter: a.object({
                    source: a.string().optional().describe('Filter templates by source ("remote" or "local")'),
                    type: a.string().optional().describe('Filter templates by type (e.g., "page", "section", "widget")'),
                    subtype: a.string().optional().describe("Filter templates by subtype"),
                    text: a.string().optional().describe("Search text to filter templates")
                }).optional().describe("Filter options for the template library"),
                tab: a.enum(["blocks", "templates", "my-templates"]).optional().describe("Which library tab to open initially"),
                focus: a.boolean().optional().describe("Whether to focus on the library when opened"),
                updatePageSettings: a.boolean().optional().describe("Whether to update page settings from selected templates")
            }).optional().describe("Configuration options for the library opening")
        }, async ({config: c}) => {
            console.log("[Elementor Server] open-library", {
                config: c
            });
            const m = await window.$e.run("library/open", c);
            return console.log("[Commands Server] open-library result:", m),
            {
                content: [{
                    type: "text",
                    text: "Template library opened."
                }]
            }
        }
        ),
        t.tool("close-library", "Closes the Elementor Template Library modal if it is currently open, using `library/close`.", {}, async () => {
            console.log("[Elementor Server] close-library");
            const c = await window.$e.run("library/close");
            return console.log("[Commands Server] close-library result:", c),
            {
                content: [{
                    type: "text",
                    text: "Template library closed."
                }]
            }
        }
        ),
        t.tool("change-device-mode", "Changes the responsive device preview mode within the Elementor editor (Desktop, Tablet, Mobile) using `panel/change-device-mode`.", {
            device: a.enum(["desktop", "tablet", "mobile"]).describe("The device mode to switch to.")
        }, async ({device: c}) => {
            console.log("[Elementor Server] change-device-mode", {
                device: c
            });
            const m = await window.$e.run("panel/change-device-mode", {
                device: c
            });
            return console.log("[Commands Server] change-device-mode result:", m),
            {
                content: [{
                    type: "text",
                    text: `Device mode changed to ${c}.`
                }]
            }
        }
        ),
        t.tool("open-navigator", "Opens the Elementor Navigator window (the tree view of page elements) using `navigator/open`.", {}, async () => {
            console.log("[Elementor Server] open-navigator");
            const c = await window.$e.run("navigator/open");
            return console.log("[Commands Server] open-navigator result:", c),
            {
                content: [{
                    type: "text",
                    text: "Navigator opened."
                }]
            }
        }
        ),
        t.tool("close-navigator", "Closes the Elementor Navigator window using `navigator/close`.", {}, async () => {
            console.log("[Elementor Server] close-navigator");
            const c = await window.$e.run("navigator/close");
            return console.log("[Commands Server] close-navigator result:", c),
            {
                content: [{
                    type: "text",
                    text: "Navigator closed."
                }]
            }
        }
        ),
        t.tool("ui-paste", 'Triggers a UI-based paste action on a specific element (usually a container), simulating a user right-clicking and selecting "Paste", using `document/ui/paste`.', {
            elementId: a.string().describe("The ID of the Elementor element (typically container) to perform the UI paste action into.")
        }, async ({elementId: c}) => {
            console.log("[Elementor Server] ui-paste", {
                elementId: c
            });
            const m = window.elementor.getContainer(c);
            if (!m)
                return {
                    content: [{
                        type: "text",
                        text: `Element with ID ${c} not found.`
                    }]
                };
            const p = await window.$e.run("document/ui/paste", {
                container: m
            });
            return console.log("[Commands Server] ui-paste result:", p),
            {
                content: [{
                    type: "text",
                    text: `UI paste triggered for element ${c}.`
                }]
            }
        }
        ),
        t.tool("open-brand-voice", 'Opens the Elementor AI "Brand Voice" interface or modal using `ai-integration/open-brand-voice`. Requires Elementor AI feature.', {}, async () => {
            console.log("[Elementor Server] open-brand-voice");
            const c = await window.$e.run("ai-integration/open-brand-voice");
            return console.log("[Commands Server] open-brand-voice result:", c),
            {
                content: [{
                    type: "text",
                    text: "Brand Voice UI opened."
                }]
            }
        }
        ),
        t.tool("open-choose-element", 'Opens the Elementor AI "Choose Element" interface, likely part of an AI content/layout generation flow, using `ai-integration/open-choose-element`. Requires Elementor AI feature.', {}, async () => {
            console.log("[Elementor Server] open-choose-element");
            const c = await window.$e.run("ai-integration/open-choose-element");
            return console.log("[Commands Server] open-choose-element result:", c),
            {
                content: [{
                    type: "text",
                    text: "Choose Element UI opened."
                }]
            }
        }
        ),
        t.tool("open-text-to-elementor", 'Opens the Elementor AI "Text to Elementor" (or similar) interface for generating designs from text prompts, using `ai-integration/open-text-to-elementor`. Requires Elementor AI feature.', {}, async () => {
            console.log("[Elementor Server] open-text-to-elementor");
            const c = await window.$e.run("ai-integration/open-text-to-elementor");
            return console.log("[Commands Server] open-text-to-elementor result:", c),
            {
                content: [{
                    type: "text",
                    text: "Text to Elementor UI opened."
                }]
            }
        }
        ),
        t.tool("toggle-favorite", 'Toggles the "favorite" status of a specific Elementor widget type, affecting its visibility/sorting in the widget panel, using `favorites/toggle`.', {
            widgetType: a.string().describe("The type (slug) of the widget to toggle favorite status for (e.g., 'heading', 'image').")
        }, async ({widgetType: c}) => {
            console.log("[Elementor Server] toggle-favorite", {
                widgetType: c
            });
            const m = await window.$e.run("favorites/toggle", {
                widgetType: c
            });
            return console.log("[Commands Server] toggle-favorite result:", m),
            {
                content: [{
                    type: "text",
                    text: `Favorite status toggled for widget type '${c}'.`
                }]
            }
        }
        ),
        t.tool("reload-preview", "Forces a reload of the main preview iframe/area within the Elementor editor using `preview/reload`. Useful if the preview becomes desynchronized.", {}, async () => {
            console.log("[Elementor Server] reload-preview");
            const c = await window.$e.run("preview/reload");
            return console.log("[Commands Server] reload-preview result:", c),
            {
                content: [{
                    type: "text",
                    text: "Preview reloaded."
                }]
            }
        }
        ),
        t.tool("navigate-to-route", "Navigates to a specific route or page within the Elementor editor interface. Calls $e.routes.to(route, args). USE THIS WHEN: You need to access different pages or tabs within the Elementor interface, such as switching between panels, accessing specific settings, or navigating to other editor components. This allows you to change the current view of the editor for the user.", {
            route: a.string().describe('The route to navigate to (e.g., "panel/editor", "panel/menu", etc.)'),
            args: a.record(a.unknown()).describe("Optional arguments to pass to the route")
        }, async ({route: c, args: m}) => {
            var p;
            console.log("[Elementor Server] navigate-to-route", {
                route: c,
                args: m
            });
            try {
                const h = window.$e;
                if (!((p = h.routes) != null && p.to))
                    return {
                        content: [{
                            type: "text",
                            text: "routes.to() is not available in this Elementor version."
                        }]
                    };
                const f = h.routes.to(c, m);
                return console.log("[Commands Server] navigate-to-route result:", f),
                {
                    content: [{
                        type: "text",
                        text: `Navigated to route: ${c}${m ? ` with args: ${JSON.stringify(m)}` : ""}`
                    }]
                }
            } catch (h) {
                throw console.error("[Elementor Server] Error navigating to route:", h),
                new Error(`Error navigating to route: ${h}`)
            }
        }
        ),
        t.tool("save-route-state", "Saves the current state of a specific route using $e.routes.saveState(). USE THIS WHEN: You need to temporarily store the current state of a panel or section before making changes. This tool helps you preserve UI states that you might want to restore later. Useful when you need to perform operations that change the interface but want to return to the previous state afterward.", {
            route: a.string().describe('The route whose state to save (e.g., "panel")')
        }, async ({route: c}) => {
            var m;
            console.log("[Elementor Server] save-route-state", {
                route: c
            });
            try {
                const p = window.$e;
                if (!((m = p.routes) != null && m.saveState))
                    return {
                        content: [{
                            type: "text",
                            text: "routes.saveState() is not available in this Elementor version."
                        }]
                    };
                const h = p.routes.saveState(c);
                return console.log("[Commands Server] save-route-state result:", h),
                {
                    content: [{
                        type: "text",
                        text: `Saved state for route: ${c}`
                    }]
                }
            } catch (p) {
                throw console.error("[Elementor Server] Error saving route state:", p),
                new Error(`Error saving route state: ${p}`)
            }
        }
        ),
        t.tool("restore-route-state", "Restores a previously saved state of a specific route using $e.routes.restoreState(). USE THIS WHEN: You need to return to a previously saved UI state after performing operations that changed the interface. This tool helps you revert to saved states of panels or sections. Useful for maintaining UI consistency and user context after temporary interface changes.", {
            route: a.string().describe('The route whose state to restore (e.g., "panel")')
        }, async ({route: c}) => {
            var m;
            console.log("[Elementor Server] restore-route-state", {
                route: c
            });
            try {
                const p = window.$e;
                if (!((m = p.routes) != null && m.restoreState))
                    return {
                        content: [{
                            type: "text",
                            text: "routes.restoreState() is not available in this Elementor version."
                        }]
                    };
                const h = p.routes.restoreState(c);
                return console.log("[Commands Server] restore-route-state result:", h),
                {
                    content: [{
                        type: "text",
                        text: `Restored state for route: ${c}`
                    }]
                }
            } catch (p) {
                throw console.error("[Elementor Server] Error restoring route state:", p),
                new Error(`Error restoring route state: ${p}`)
            }
        }
        ),
        t.tool("check-route", "Checks if the current route is part of a specific route using $e.routes.isPartOf(). USE THIS WHEN: You need to verify the current location in the Elementor interface before performing operations. This tool helps you make decisions based on where the user is in the editor. Useful for conditional operations that depend on the current interface context.", {
            route: a.string().describe('The route to check against (e.g., "panel/editor")')
        }, async ({route: c}) => {
            var m;
            console.log("[Elementor Server] check-route", {
                route: c
            });
            try {
                const p = window.$e;
                if (!((m = p.routes) != null && m.isPartOf))
                    return {
                        content: [{
                            type: "text",
                            text: "routes.isPartOf() is not available in this Elementor version."
                        }]
                    };
                const h = p.routes.isPartOf(c);
                return console.log("[Commands Server] check-route result:", h),
                {
                    content: [{
                        type: "text",
                        text: h ? `Current route is part of ${c}` : `Current route is not part of ${c}`
                    }]
                }
            } catch (p) {
                throw console.error("[Elementor Server] Error checking route:", p),
                new Error(`Error checking route: ${p}`)
            }
        }
        ),
        t.tool("get-route-args", "Gets the arguments for the current route or a specific route using $e.routes.currentArgs. USE THIS WHEN: You need to access parameters or settings associated with the current interface state. This tool helps you understand the context and configuration of the current route. Useful for accessing route-specific data or parameters that affect the current editor state.", {
            route: a.string().optional().describe('Optional specific route to get arguments for (e.g., "panel")')
        }, async ({route: c}) => {
            var m;
            console.log("[Elementor Server] get-route-args", {
                route: c
            });
            try {
                const p = window.$e;
                if (!((m = p.routes) != null && m.currentArgs))
                    return {
                        content: [{
                            type: "text",
                            text: "routes.currentArgs is not available in this Elementor version."
                        }]
                    };
                const h = p.routes.currentArgs;
                return console.log("[Commands Server] get-route-args result:", h),
                {
                    content: [{
                        type: "text",
                        text: JSON.stringify(h, null, 2)
                    }]
                }
            } catch (p) {
                throw console.error("[Elementor Server] Error getting route arguments:", p),
                new Error(`Error getting route arguments: ${p}`)
            }
        }
        ),
        t.tool("get-current-route", "Gets the current route in the Elementor editor using $e.routes.getCurrent(). USE THIS WHEN: You need to know exactly where you are in the Elementor interface, such as which panel is open and what tab is selected. This tool helps you understand the current state of the editor interface. Useful for determining the exact location in the interface hierarchy, like whether you're in the style tab, content tab, or advanced settings of a widget.", {}, async () => {
            var c;
            console.log("[Elementor Server] get-current-route");
            try {
                const m = window.$e;
                if (!((c = m.routes) != null && c.getCurrent))
                    return {
                        content: [{
                            type: "text",
                            text: "routes.getCurrent() is not available in this Elementor version."
                        }]
                    };
                const p = m.routes.getCurrent();
                return console.log("[Commands Server] get-current-route result:", p),
                {
                    content: [{
                        type: "text",
                        text: `Current route: ${p}`
                    }]
                }
            } catch (m) {
                throw console.error("[Elementor Server] Error getting current route:", m),
                new Error(`Error getting current route: ${m}`)
            }
        }
        ),
        t.tool("add-custom-styling-to-element", `Tool for applying custom CSS styling.
Use this tool when the user request cannot be fulfilled using built-in Elementor settings ('update-element-settings') or the motion effects ('get-motion-effects').`, {
            elementId: a.string().describe("The ID of the element to style"),
            prompt: a.string().describe("The prompt describing the styling requirements")
        }, async ({elementId: c, prompt: m}) => {
            try {
                const h = window.elementor.getContainer(c).view.el.outerHTML || ""
                  , f = v => {
                    var w, _;
                    const S = c === "document" ? ((_ = (w = window.elementor.config.document) == null ? void 0 : w.settings) == null ? void 0 : _.cssWrapperSelector) || "body" : `.elementor-element.elementor-element-${c}`;
                    return v && v.replace(/`/g, "").replace(/^css\s*/i, "").replace(/selector/g, S)
                }
                  , y = await t.server.request({
                    method: "sampling/createMessage",
                    params: {
                        messages: [{
                            role: "user",
                            content: {
                                type: "text",
                                text: m
                            }
                        }],
                        maxTokens: 1e3,
                        modelPreferences: {
                            hints: [{
                                name: "elementor-css"
                            }]
                        },
                        metadata: {
                            element_id: c,
                            html_markup: h
                        }
                    }
                }, Pr);
                if (!(y != null && y.content))
                    throw console.error("[Elementor Server] Error: No CSS text received from API", y),
                    new Error("Failed to generate CSS: No text content received from API.");
                const b = f(y.content.text)
                  , x = await xe({
                    name: Se.CUSTOM_CSS_APPROVAL,
                    cssToApprove: b,
                    elementId: c,
                    autoInsert: !1,
                    hideSuggestionsOnEdit: !0
                });
                return x.approved ? {
                    content: [{
                        type: "text",
                        text: JSON.stringify({
                            success: !0,
                            message: "Custom CSS was applied and approved by the user.",
                            generatedCss: x.finalCss || b,
                            action: x.action || "apply"
                        })
                    }]
                } : x.action === "copy" ? {
                    content: [{
                        type: "text",
                        text: JSON.stringify({
                            success: !0,
                            message: "CSS code copied to clipboard. The CSS has been applied to the element.",
                            generatedCss: x.finalCss || b,
                            action: "copy"
                        })
                    }]
                } : x.action === "hide" ? {
                    content: [{
                        type: "text",
                        text: JSON.stringify({
                            success: !0,
                            message: "CSS preview hidden. The CSS remains applied to the element.",
                            generatedCss: x.finalCss || b,
                            action: "hide"
                        })
                    }]
                } : {
                    content: [{
                        type: "text",
                        text: JSON.stringify({
                            success: !0,
                            message: "Custom CSS rejected by user. Ask the user if they would like to try again with a different prompt.",
                            generatedCss: b,
                            action: x.action || "reject"
                        })
                    }]
                }
            } catch (p) {
                console.error("[Elementor Server] Error generating CSS:", p);
                const h = p instanceof Error ? p.message : String(p);
                throw new Error(h)
            }
        }
        ),
        t.tool("get-motion-effects", `****USE THIS TOOL only if the users requested TRIGGER supports the requested EFFECT.**

**TRIGGER  Supported EFFECTs**
- hover  Movements, Rotations, Scaling
- scroll  Rotations, Scaling, Fading, Blurring
- mouse_move  Movements
- entrance  All animate.css in effects  
  (fadeIn*, slideIn*, zoomIn*, rotateIn*, flipIn*, bounceIn*, backIn*, lightSpeedIn*, jackInTheBox, rollIn, etc...)

**How to decide:**
1) Identify the requested EFFECT and TRIGGER from the users request.  
   - Example: fade in on scroll  EFFECT = Fading, TRIGGER = scroll
2) Look up the TRIGGER in the table above.
3) If the EFFECT is in the TRIGGERs list  **use this tool**.
4) If the EFFECT is NOT in the TRIGGERs list  **do not use this tool**.  
   - Instead, suggest a TRIGGER that supports the EFFECT or use **add-custom-styling-to-element** for non-motion styling.
5) Unsupported TRIGGERs (click, focus, etc.)  always use **add-custom-styling-to-element**.`, {
            elementId: a.string().describe("The unique ID of the selected Elementor element to apply the motion effects to. This ID is required and must be obtained from a currently selected element in the Elementor editor. If this parameter is missing or empty, instruct the user to first select/target a specific element before applying motion effects."),
            prompt: a.string().describe("The prompt string describing the motion effects requirements to send to the API"),
            triggerList: a.array(a.enum(["hover", "scroll", "mouse_move", "entrance"])).describe("The list of triggers to use for the motion effects. Could be none of the available options")
        }, async ({elementId: c, prompt: m, triggerList: p}) => {
            try {
                const h = await xe({
                    name: Se.MOTION_EFFECTS,
                    elementId: c,
                    prompt: m,
                    motionEffectType: p
                });
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(h)
                    }]
                }
            } catch (h) {
                console.error("[Elementor Server] Error generating Motion Effects:", h);
                const f = h instanceof Error ? h.message : String(h);
                throw new Error(f)
            }
        }
        ),
        t.tool("trigger-copilot-container", `Triggers Elementor Copilot to generate a complete, AI-powered section with content and layout. It's best for creating standard website sections from a user's description.

**When to use:**
*   When the request mentions a standard section like **About, Archive, Audio, Benefits, Career, Clients, CTA, Contact Info, Event, FAQ, Form, Gallery, Hero, Mini Hero, Paragraph, Portfolio, Pricing, Product, Quote, Services, Statistics, Subscribe, Team, Terms of Use, Testimonial, Timeline, 404, Trust Badges, Content Overview, or Process**.
*   When the request implies both layout and meaning (e.g., "a 3-column layout for team members", "a testimonial carousel").
*   When the request describes the section's content and intent (e.g., "add a pricing table for 3 plans", "a 'why choose us' section with icons").

This tool creates an entire section at once using AI, instead of building it element by element. It will open the Copilot interface for the user to review and approve the results.
Don't mention the tool name in the response.`, {
            userInput: a.string().describe('A detailed user request describing the desired section. This should include the section type (e.g., "Hero", "Testimonials"), layout ("3 columns", "carousel"), and specific content ("for 3 plans", "with icons and text"). For example: "Create a testimonial carousel section" or "Add a pricing table for 3 plans (Basic, Pro, Enterprise)".')
        }, async ({userInput: c}) => {
            const {startCopilot: m} = await Promise.resolve().then( () => Es)
              , {askCopilotForNextLayout: p} = await Promise.resolve().then( () => vu)
              , h = "angie";
            console.log("[Elementor Server] trigger-copilot-container", {
                trigger: h
            });
            try {
                const f = await m();
                return f.style.opacity = "1",
                f.style.visibility = "visible",
                p(f, h, c),
                console.log("[Commands Server] trigger-copilot-container: Message posted to trigger Copilot"),
                {
                    content: [{
                        type: "text",
                        text: `Copilot container generation triggered successfully with trigger: "${h}". The Copilot interface should now be active and generating container layout suggestions.`
                    }]
                }
            } catch (f) {
                console.error("[Elementor Server] Error triggering Copilot:", f);
                const y = f instanceof Error ? f.message : String(f);
                throw new Error(`Error triggering Copilot container generation: ${y}`)
            }
        }
        ),
        t.tool("manage-copilot-suggestion", `This tool accepts or rejects the container suggestions generated by Elementor Copilot. Use this after 'trigger-copilot-container' has been called and a suggestion is available.

USE THIS WHEN: You need to programmatically accept or reject an AI-generated container layout. This allows for an automated or scripted workflow where the decision to keep or discard a layout can be made without direct user interaction in the Copilot UI.

- 'accept': Applies the suggested container to the page, making it a permanent part of the layout.
- 'reject': Discards the suggested container and removes it from the page.`, {
            action: a.enum(["accept", "reject"]).describe("The action to perform on the Copilot suggestion. Either 'accept' or 'reject'.")
        }, async ({action: c}) => {
            var p;
            const {getCopilotIframe: m} = await Promise.resolve().then( () => Es);
            console.log("[Elementor Server] manage-copilot-suggestion", {
                action: c
            });
            try {
                const h = m();
                if (!h)
                    throw new Error("Copilot iframe not found. Please trigger Copilot first.");
                return (p = h.contentWindow) == null || p.postMessage({
                    type: `copilot/next-layout/${c}`
                }, new URL(h.src).origin),
                {
                    content: [{
                        type: "text",
                        text: `Copilot suggestion has been '${c}'ed.`
                    }]
                }
            } catch (h) {
                console.error("[Elementor Server] Error managing Copilot suggestion:", h);
                const f = h instanceof Error ? h.message : String(h);
                throw new Error(`Error managing Copilot suggestion: ${f}`)
            }
        }
        ),
        t.tool("get-media-by-id", "Gets WordPress media library item details by media ID, including the source URL that can be used for image processing in Elementor. Use this when you have a media ID and need to get the image URL for processing operations.", {
            mediaId: a.number().describe("The WordPress media library ID of the image to get details for")
        }, async ({mediaId: c}) => {
            var m, p, h;
            console.log("[Elementor Server] get-media-by-id", {
                mediaId: c
            });
            try {
                const f = await U(`/wp/v2/media/${c}`, "GET");
                if (!f || !f.source_url)
                    throw new Error(`Media item with ID ${c} not found or has no source URL`);
                const y = {
                    id: f.id,
                    title: ((m = f.title) == null ? void 0 : m.rendered) || f.slug || "Untitled",
                    alt_text: f.alt_text || "",
                    source_url: f.source_url,
                    media_type: f.media_type,
                    mime_type: f.mime_type,
                    date: f.date,
                    caption: ((p = f.caption) == null ? void 0 : p.rendered) || "",
                    description: ((h = f.description) == null ? void 0 : h.rendered) || "",
                    media_details: f.media_details
                };
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(y, null, 2)
                    }]
                }
            } catch (f) {
                throw console.error("[Elementor Server] get-media-by-id error:", f),
                new Error(`Error retrieving media by ID ${c}: ${f.message}`)
            }
        }
        ),
        t.tool("assign-image-to-element", "Assigns an existing image URL to an Elementor element. Handles uploading the image to WordPress media library and updating the element settings. Use this when you have a generated or processed image URL that needs to be applied to a specific Elementor element.", {
            elementId: a.string().describe("ID of the Elementor element where the image should be assigned"),
            imageUrl: a.string().url().describe("URL of the image to assign to the element"),
            imageSize: a.enum(["full", "large", "medium", "thumbnail", "custom"]).optional().default("full").describe("Image size setting for Elementor display"),
            customWidth: a.number().optional().describe('Custom width when imageSize is "custom"'),
            customHeight: a.number().optional().describe('Custom height when imageSize is "custom"'),
            altText: a.string().describe("Alt text for accessibility"),
            filename: a.string().describe("Custom filename for the uploaded image"),
            title: a.string().describe("Title for the media library entry")
        }, async ({elementId: c, imageUrl: m, imageSize: p="full", customWidth: h, customHeight: f, altText: y, filename: b, title: x}) => {
            console.log("[Elementor Server] assign-image-to-element", {
                elementId: c,
                imageUrl: m
            });
            try {
                const v = await Rr({
                    imageUrl: m,
                    filename: b,
                    title: x,
                    altText: y
                });
                console.log("[Elementor Server] Image uploaded with ID:", v.id);
                const S = window.elementor.getContainer(c);
                if (!S)
                    throw new Error(`Elementor element with ID "${c}" not found`);
                const w = {
                    image: {
                        id: v.id,
                        url: v.url
                    },
                    image_size: p
                };
                return p === "custom" && h && f && (w.image_custom_dimension = {
                    width: h,
                    height: f
                }),
                y && (w.image_alt = y),
                await window.$e.run("document/elements/settings", {
                    container: S,
                    settings: w
                }),
                console.log("[Elementor Server] Successfully assigned image to element:", c),
                {
                    content: [{
                        type: "text",
                        text: JSON.stringify({
                            success: !0,
                            elementId: c,
                            mediaId: v.id,
                            imageUrl: v.url,
                            imageSize: p,
                            message: "Image successfully assigned to Elementor element!"
                        })
                    }]
                }
            } catch (v) {
                throw console.error("[Elementor Server] Error assigning image:", v),
                new Error(`Failed to assign image to Elementor element: ${vinstanceof Error ? v.message : String(v)}`)
            }
        }
        ),
        t.tool("remove-background-from-image", "This tool removes the background from existing images in Elementor elements, creating a transparent or clean background version. Use this when users want to remove the background from a photo, product image, or any image to isolate the main subject in an Elementor image widget. The tool provides preview functionality before applying the changes and will automatically update the element with the processed image.", {
            imageUrl: a.string().url().describe("The URL of the existing image from the WordPress media library to remove background from. Must be a media library URL (containing /wp-content/uploads/). If you don't have the media library URL, ask the user to select an image element first so you have the correct context."),
            elementId: a.string().describe("ID of the Elementor image widget/element where the processed image should be applied")
        }, async ({imageUrl: c, elementId: m}) => {
            try {
                console.log("[Elementor Server] Processing background removal request for:", c),
                Ye(c);
                const p = {
                    name: Se.REMOVE_BACKGROUND,
                    imageUrl: c,
                    elementId: m,
                    context: "editor",
                    supportsPreview: !0
                }
                  , h = await xe(p);
                return console.log("[Elementor Server] Background removal result:", h),
                {
                    content: [{
                        type: "text",
                        text: JSON.stringify(h)
                    }]
                }
            } catch (p) {
                console.error("[Elementor Server] Error removing background:", p);
                const h = p instanceof Error ? p.message : String(p);
                throw new Error(h)
            }
        }
        ),
        t.tool("upscale-image", "This tool upscales and resizes existing images in Elementor elements using AI to increase resolution and improve quality. Use this when users want to: upscale images, resize images to larger dimensions, enhance image quality, increase resolution, make images bigger/larger, scale up images, enlarge images, improve image sharpness, or change image size to specific dimensions. Supports any resolution from 512px to 2048px in 256px steps. The tool provides preview functionality before applying changes.", {
            imageUrl: a.string().url().describe("The URL of the existing image from the WordPress media library to upscale. Must be a media library URL (containing /wp-content/uploads/). If you don't have the media library URL, ask the user to select an image element first so you have the correct context."),
            elementId: a.string().describe("ID of the Elementor image widget/element where the upscaled image should be applied"),
            resolution: a.number().min(512).max(2048).describe("REQUIRED: The exact resolution for the upscaled image. Choose from: 512, 768, 1024, 1280, 1536, 1792, 2048. Higher resolutions create larger, more detailed images.")
        }, async ({imageUrl: c, elementId: m, resolution: p}) => {
            try {
                console.log("[Elementor Server] Processing image upscale request for:", c),
                Ye(c);
                const h = {
                    name: Se.UPSCALE_IMAGE,
                    imageUrl: c,
                    elementId: m,
                    context: "editor",
                    supportsPreview: !0,
                    resolution: p
                }
                  , f = await xe(h);
                return console.log("[Elementor Server] Image upscale result:", f),
                {
                    content: [{
                        type: "text",
                        text: JSON.stringify(f)
                    }]
                }
            } catch (h) {
                console.error("[Elementor Server] Error upscaling image:", h);
                const f = h instanceof Error ? h.message : String(h);
                throw new Error(f)
            }
        }
        ),
        t.tool("replace-background-from-image", "This tool replaces the background of existing images in Elementor elements with a new AI-generated background based on a text prompt. Use this when users want to change or manipulate the background scene of a photo while keeping the main subject intact.", {
            imageUrl: a.string().url().describe("The URL of the existing image from the WordPress media library to replace the background of. Must be a media library URL (containing /wp-content/uploads/). If you don't have the media library URL, ask the user to select an image element first so you have the correct context."),
            backgroundPrompt: a.string().describe('A description of the new background to generate (e.g., "a beautiful sunset over mountains", "modern office space", "tropical beach")'),
            elementId: a.string().describe("ID of the Elementor image widget/element where the processed image should be applied")
        }, async ({imageUrl: c, backgroundPrompt: m, elementId: p}) => {
            try {
                console.log("[Elementor Server] Processing background replacement request for:", c),
                Ye(c);
                const h = {
                    name: Se.REPLACE_BACKGROUND,
                    imageUrl: c,
                    backgroundPrompt: m,
                    elementId: p,
                    context: "editor",
                    supportsPreview: !0
                }
                  , f = await xe(h);
                return console.log("[Elementor Server] Background replacement result:", f),
                {
                    content: [{
                        type: "text",
                        text: JSON.stringify(f)
                    }]
                }
            } catch (h) {
                console.error("[Elementor Server] Error replacing background:", h);
                const f = h instanceof Error ? h.message : String(h);
                throw new Error(f)
            }
        }
        ),
        t.tool("generate-variation-for-existing-image", `This tool transforms and modifies existing images based on user instructions. Use this when users want to change, modify, or transform an image they already have - whether they want style variations, color changes (like "make this black and white"), artistic transformations, or different creative interpretations of the same subject. This is the go-to tool for any image modification request where the user has an existing image and wants it altered in some way. The tool analyzes the original image and generates 4 different versions based on the user's prompt, maintaining the core subject while applying the requested changes. Users can then select their preferred version to replace the original image.`, {
            prompt: a.string().describe(`Instructions for how to modify the image based on what the user actually wants to achieve. Understand the user's intent and perspective - if they want something "grim and dark," describe the visual elements that create that feeling. The prompt should capture the essence of their request, not just repeat their exact words. Focus on translating their vision into clear visual directions for the image transformation.`),
            imageUrl: a.string().url().describe("The URL of the existing image from the WordPress media library to create variations from. Must be a media library URL (containing /wp-content/uploads/). If you don't have the media library URL, ask the user to select an image element first so you have the correct context."),
            elementId: a.string().describe("ID of the Elementor image widget/element where the processed image should be applied")
        }, async ({imageUrl: c, elementId: m, prompt: p}) => {
            try {
                console.log("[Elementor Server] Processing image variations request for:", c),
                Ye(c);
                const h = {
                    name: Se.GENERATE_IMAGE_VARIATIONS,
                    imageUrl: c,
                    elementId: m,
                    prompt: p,
                    context: "editor",
                    supportsPreview: !0
                }
                  , f = await xe(h);
                return console.log("[Elementor Server] Image variations result:", f),
                {
                    content: [{
                        type: "text",
                        text: JSON.stringify(f)
                    }]
                }
            } catch (h) {
                console.error("[Elementor Server] Error generating image variations:", h);
                const f = h instanceof Error ? h.message : String(h);
                throw new Error(f)
            }
        }
        ),
        t.tool("isolate-object", "This tool isolates specific objects from images in Elementor elements using AI. Use this when users want to isolate, extract, or separate the main subject or object from an image while removing or replacing the background. The tool allows choosing a background color. Supports variations to provide multiple options.", {
            imageUrl: a.string().url().describe("The URL of the existing image from the WordPress media library to process. Must be a media library URL (containing /wp-content/uploads/). If you don't have the media library URL, ask the user to select an image element first so you have the correct context."),
            backgroundColor: a.string().optional().describe('Background color for the isolated object (e.g., "#ffffff", "#000000"). Defaults to white if not specified.'),
            elementId: a.string().describe("ID of the Elementor image widget/element where the processed image should be applied")
        }, async ({imageUrl: c, backgroundColor: m="#ffffff", elementId: p}) => {
            try {
                console.log("[Elementor Server] Processing isolate object request for:", c),
                Ye(c);
                const h = {
                    name: Se.ISOLATE_OBJECT,
                    imageUrl: c,
                    backgroundColor: m,
                    elementId: p,
                    context: "editor",
                    supportsPreview: !0
                }
                  , f = await xe(h);
                return console.log("[Elementor Server] Isolate object result:", f),
                {
                    content: [{
                        type: "text",
                        text: JSON.stringify(f)
                    }]
                }
            } catch (h) {
                console.error("[Elementor Server] Error isolating object:", h);
                const f = h instanceof Error ? h.message : String(h);
                throw new Error(f)
            }
        }
        ),
        t.tool("open-generative-fill", `Opens Elementor's Generative Fill tool (inpainting) where users can brush/mark areas of an image and use AI to fill or modify those areas with a text prompt. This provides the full interactive canvas with brush tools, and real-time mask editing. Perfect for "edit this part of the image", "remove this object", "change the background", etc. The user gets the complete Elementor AI inpainting interface and results are automatically applied.`, {
            imageUrl: a.string().describe("Direct URL to the image file to edit with generative fill"),
            elementId: a.string().optional().describe("ID of the Elementor image widget where the edited result should be applied automatically"),
            confirmed: a.boolean().optional().describe("Set to true only after user writes a message that he approve , after you ask him separately and confirms they want to proceed with opening the generative fill tool")
        }, async ({imageUrl: c, elementId: m, confirmed: p}) => {
            if (!Hr())
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify({
                            message: "Elementor AI is not active. Please activate it or buy an elementor ai subscription."
                        })
                    }]
                };
            if (!p)
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify({
                            message: `I'll open Elementor's Generative Fill tool for you. This will:
 Open an interactive canvas interface
 Let you brush/mark areas you want to edit
 Allow you to add text prompts for AI modifications
 Automatically apply the edited result to your element`,
                            question: "Do you want me to open the Generative Fill tool?",
                            requiresConfirmation: !0,
                            toolName: "open-generative-fill",
                            parameters: {
                                imageUrl: c,
                                elementId: m,
                                confirmed: !0
                            }
                        })
                    }]
                };
            try {
                const h = {
                    name: Se.IMAGE_TOOLS_MODAL,
                    modalType: Dr.IN_PAINTING,
                    imageUrl: c,
                    elementId: m
                }
                  , f = await xe(h);
                if (!f.success)
                    throw new Error(f.error || "Failed to open Generative Fill interface");
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify({
                            followup_message: `Done! I've applied the generative fill to your image. 
The edited image has been updated in your element.
Let me know if you want to make any adjustments or try another edit.`,
                            success: f.success,
                            action: f.action
                        })
                    }]
                }
            } catch (h) {
                console.error("[Elementor Server] Error opening Generative Fill:", h);
                const f = h instanceof Error ? h.message : String(h);
                throw new Error(`Failed to open Generative Fill: ${f}`)
            }
        }
        ),
        t.tool("open-cleanup-tool", `Opens Elementor's Cleanup tool where users can brush/mark unwanted areas of an image to remove or clean them up. This provides an interactive canvas with precise brush tools for object removal, blemish correction, and general image cleanup. Perfect for "remove this object", "clean up this area", "fix this spot", etc. The user gets the complete Elementor AI cleanup interface with undo/redo functionality and results are automatically applied.`, {
            imageUrl: a.string().describe("Direct URL to the image file to clean up"),
            elementId: a.string().optional().describe("ID of the Elementor image widget where the cleaned result should be applied automatically"),
            confirmed: a.boolean().optional().describe("Set to true only after user writes a message that he approve , after you ask him separately and confirms they want to proceed with opening the cleanup tool")
        }, async ({imageUrl: c, elementId: m, confirmed: p}) => {
            if (!Hr())
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify({
                            message: "Elementor AI is not active. Please activate it or buy an elementor ai subscription."
                        })
                    }]
                };
            if (!p)
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify({
                            message: `I'll open Elementor's Cleanup tool for you. This will:
 Open an interactive brush interface
 Let you mark unwanted areas to remove
 Provide precise editing with undo/redo functionality
 Automatically apply the cleaned result to your element`,
                            question: "Do you want me to open the Cleanup tool?",
                            requiresConfirmation: !0,
                            toolName: "open-cleanup-tool",
                            parameters: {
                                imageUrl: c,
                                elementId: m,
                                confirmed: !0
                            }
                        })
                    }]
                };
            try {
                const h = {
                    name: Se.IMAGE_TOOLS_MODAL,
                    modalType: Dr.CLEANUP,
                    imageUrl: c,
                    elementId: m
                }
                  , f = await xe(h);
                if (!f.success)
                    throw new Error(f.error || "Failed to open Cleanup tool interface");
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify({
                            followup_message: `Done! I've cleaned up your image. 
The edited image has been updated in your element.
Let me know if you want to make any adjustments or clean up other areas.`,
                            success: f.success,
                            action: f.action
                        })
                    }]
                }
            } catch (h) {
                console.error("[Elementor Server] Error opening Cleanup tool:", h);
                const f = h instanceof Error ? h.message : String(h);
                throw new Error(`Failed to open Cleanup tool: ${f}`)
            }
        }
        ),
        t.tool("open-expand-image-tool", `Opens Elementor's Expand Image tool for image expansion and extension. This tool allows users to expand images beyond their current borders by generating new content that seamlessly extends the existing image in any direction. Use this when users want to make images larger, wider, taller, or add more content around the edges. Perfect for "expand this image", "make this image wider", "extend the background", "add more space around the subject", etc. The tool provides an interactive interface for selecting expansion areas and automatically applies the extended results.`, {
            imageUrl: a.string().describe("Direct URL to the image file to expand"),
            elementId: a.string().optional().describe("ID of the Elementor image widget where the expanded result should be applied automatically"),
            confirmed: a.boolean().optional().describe("Set to true only after user writes a message that he approve , after you ask him separately and confirms they want to proceed with opening the expand image tool")
        }, async ({imageUrl: c, elementId: m, confirmed: p}) => {
            if (!Hr())
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify({
                            message: "Elementor AI is not active. Please activate it or buy an elementor ai subscription."
                        })
                    }]
                };
            if (!p)
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify({
                            message: `I'll open Elementor's Expand Image tool for you. This will:
 Open an interactive interface
 Let you select which areas to expand
 Generate new content around your image
 Automatically apply the result to your element`,
                            question: "Do you want me to open the Expand Image tool?",
                            requiresConfirmation: !0,
                            toolName: "open-expand-image-tool",
                            parameters: {
                                imageUrl: c,
                                elementId: m,
                                confirmed: !0
                            }
                        })
                    }]
                };
            try {
                const h = {
                    name: Se.IMAGE_TOOLS_MODAL,
                    modalType: Dr.OUT_PAINTING,
                    imageUrl: c,
                    elementId: m
                }
                  , f = await xe(h);
                if (!f.success)
                    throw new Error(f.error || "Failed to open Expand Image tool interface");
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify({
                            followup_message: `Done! I've expanded your image with new content. 
The extended image has been updated in your element.
Let me know if you want to make any adjustments or expand other areas.`,
                            success: f.success,
                            action: f.action
                        })
                    }]
                }
            } catch (h) {
                console.error("[Elementor Server] Error opening Expand Image tool:", h);
                const f = h instanceof Error ? h.message : String(h);
                throw new Error(`Failed to open Expand Image tool: ${f}`)
            }
        }
        ),
        t
    }
    const VE = async t => {
        var e;
        if ((e = window.angieConfig) != null && e.plugins) {
            if (await t.waitForReady(),
            window.angieConfig.plugins.acf && t.registerServer({
                name: "acf",
                version: "1.0.0",
                description: "ACF REST API",
                server: cb(),
                capabilities: {
                    tools: {}
                }
            }),
            window.angieConfig.plugins.elementor) {
                if (zo()) {
                    const r = nS() ? zE : HE;
                    t.registerServer({
                        name: "elementor",
                        version: "1.0.0",
                        description: "Elementor",
                        server: await r(),
                        capabilities: {
                            tools: {}
                        }
                    })
                }
                t.registerServer({
                    name: "elementor-kit",
                    version: "1.0.0",
                    description: "Elementor Kit",
                    server: await Mb(),
                    capabilities: {
                        tools: {}
                    }
                }),
                t.registerServer({
                    name: "elementor-pro",
                    version: "1.0.0",
                    description: "Elementor Pro",
                    server: await Ib(),
                    capabilities: {
                        tools: {}
                    }
                })
            }
            Bo() && t.registerServer({
                name: "gutenberg",
                version: "1.0.0",
                description: "Gutenberg Block Editor",
                server: Xb(),
                capabilities: {
                    tools: {}
                }
            }),
            window.angieConfig.plugins.woocommerce && (window.angieConfig.plugins.woocommerce.isSingleProductEdit ? t.registerServer({
                name: "woo-product-panel",
                version: "1.0.0",
                description: "WooCommerce Single Product Edit",
                server: await Zv(),
                capabilities: {
                    tools: {}
                }
            }) : t.registerServer({
                name: "woocommerce",
                version: "1.0.0",
                description: "WooCommerce",
                server: await hb(),
                capabilities: {
                    tools: {}
                }
            }))
        }
    }
      , Ss = "wp-admin-bar-angie-sidebar-toggle";
    function JE(t, e) {
        if (!t) {
            const r = document.getElementById(Ss);
            if (r) {
                const o = r.querySelector(".ab-item");
                e === 0 ? o.focus() : setTimeout(function() {
                    o.focus()
                }, e)
            }
        }
    }
    function YE(t) {
        const e = document.getElementById(Ss);
        if (e) {
            const r = e.querySelector(".ab-item")
              , o = r || e
              , n = "Toggle Angie";
            r && (r.textContent = n,
            r.setAttribute("title", n)),
            o.hasAttribute("aria-expanded") && o.setAttribute("aria-expanded", t ? "true" : "false"),
            o.hasAttribute("aria-label") && o.setAttribute("aria-label", n)
        }
    }
    async function KE() {
        await Xa(),
        setTimeout(function() {
            yu(),
            document.getElementById(Ss) || setTimeout(yu, 500)
        }, 100)
    }
    let fu = !1;
    function yu() {
        if (fu)
            return;
        const t = document.getElementById(Ss);
        if (t) {
            fu = !0;
            const e = t.querySelector(".ab-item")
              , r = s => {
                s.preventDefault(),
                typeof window < "u" && window.toggleAngieSidebar && window.toggleAngieSidebar()
            }
              , o = s => {
                (s.key === "Enter" || s.key === " ") && (s.preventDefault(),
                typeof window < "u" && window.toggleAngieSidebar && window.toggleAngieSidebar())
            }
              , n = e || t;
            n && (n.addEventListener("click", r),
            n.addEventListener("keydown", o)),
            Ov(),
            Dv()
        } else
            console.warn("Angie Sidebar: Toggle button not found!")
    }
    function QE(t, e, r) {
        YE(t),
        JE(t, r ? 0 : 300)
    }
    function XE() {
        ud(QE),
        KE()
    }
    const ex = () => window !== window.top
      , tx = () => {
        document.body.classList.remove("angie-sidebar-active")
    }
      , rx = () => {
        document.addEventListener("keydown", t => {
            if ((Ew() ? t.ctrlKey : t.altKey) && (t.code === "KeyN" || t.key === "n" || t.key === "N")) {
                const n = document.querySelector('iframe[src*="angie/"]');
                n && n.ownerDocument.activeElement === n || (t.preventDefault(),
                window.toggleAngieSidebar && window.toggleAngieSidebar())
            }
        }
        )
    }
      , nx = () => {
        var o, n, s, i, l;
        const t = window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light"
          , e = ((l = (i = (s = (n = (o = window.elementor) == null ? void 0 : o.config) == null ? void 0 : n.settings) == null ? void 0 : s.editorPreferences) == null ? void 0 : i.settings) == null ? void 0 : l.ui_theme) || t
          , r = new gd;
        r.loadSidebar({
            origin: "https://angie.elementor.com",
            uiTheme: e,
            isRTL: window.document.documentElement.dir === "rtl"
        }),
        yw(),
        Cw(),
        bw(),
        Nw(),
        XE(),
        Sw(),
        rx(),
        ib(r),
        VE(r)
    }
    ;
    ex() ? tx() : nx();
    const ox = (t, e, r) => {
        var o;
        console.log("asking copilot for next layout"),
        (o = t.contentWindow) == null || o.postMessage({
            type: "copilot/next-layout/ask",
            payload: {
                trigger: e,
                userInput: r
            }
        }, new URL(t.src).origin)
    }
      , pi = (t, e) => {
        var r;
        console.log("asking copilot to stop"),
        (r = t.contentWindow) == null || r.postMessage({
            type: "copilot/next-layout/stop",
            payload: {
                trigger: e
            }
        }, new URL(t.src).origin),
        yi()
    }
      , vu = Object.freeze(Object.defineProperty({
        __proto__: null,
        askCopilotForNextLayout: ox,
        askCopilotToStop: pi
    }, Symbol.toStringTag, {
        value: "Module"
    }))
      , sx = ["ai-integration/open-text-to-elementor", "container-converter/convert-all", "document/elements/create", "document/elements/delete", "document/elements/empty", "document/elements/settings", "document/ui/delete", "editor/documents/close", "editor/documents/preview", "editor/documents/switch", "library/open", "panel/close", "panel/exit", "panel/global/close", "panel/global/open", "panel/history/actions/do", "panel/history/actions/redo", "panel/history/actions/undo"]
      , ax = ["library/preview", "library/save-template", "library/templates/blocks", "library/templates/my-templates", "library/templates/pages", "panel/history/actions", "panel/history/revisions"]
      , wu = {
        isEnabled: !1,
        timeoutId: null,
        dropHoverTimeoutId: void 0,
        isWaitingForUser: !0,
        isRunning: !1,
        isUserHoverDropArea: !1,
        listeners: [],
        lastSessionEndedTime: 0
    }
      , ix = () => {
        wu.isEnabled = !1,
        wu.listeners.forEach(t => t())
    }
    ;
    var bu = (t => (t.ON = "on",
    t.OFF = "off",
    t.SNOOZED_24H = "snoozed_24h",
    t.SNOOZED_7D = "snoozed_7d",
    t))(bu || {});
    const Su = "copilot"
      , lx = "copilot_snooze_until"
      , Eu = "elementor-copilot/maybe-off/last-notice"
      , xu = (t, e) => new Promise(r => {
        var n;
        console.log("asking copilot for set user preferences");
        const o = new MessageChannel;
        o.port1.onmessage = s => {
            r(s.data)
        }
        ,
        (n = t.contentWindow) == null || n.postMessage({
            type: "copilot/user-preferences/set",
            payload: e
        }, new URL(t.src).origin, [o.port2])
    }
    )
      , cx = t => {
        const e = t === "snoozed_7d" ? 7 : 1
          , r = Date.now() + e * 24 * 60 * 60 * 1e3;
        window.localStorage.setItem(lx, r.toString())
    }
      , _u = async t => {
        const e = window.localStorage.getItem(Eu);
        if (e && Date.now() - parseInt(e, 10) < 3 * 24 * 60 * 60 * 1e3)
            return;
        window.localStorage.setItem(Eu, Date.now().toString());
        const {iframe: r, iframeUrlObject: o} = await fs({
            path: "copilot/turn-off-notice?colorScheme=dark&reason=" + t,
            css: {
                position: "fixed",
                height: "200px",
                width: "300px",
                bottom: "20px",
                "border-radius": "5px",
                "z-index": 999999999
            }
        })
          , n = s => {
            s.origin === o.origin && (s.data.type === "copilot/turn-off-notice/take-me-there" && (window.$e.route("panel/editor-preferences"),
            r.remove(),
            window.removeEventListener("message", n)),
            s.data.type === "copilot/turn-off-notice/got-it" && (r.remove(),
            window.removeEventListener("message", n)))
        }
        ;
        window.addEventListener("message", n)
    }
    ;
    window.addEventListener("message", async t => {
        var e, r;
        switch (t.data.type) {
        case "copilot/user-preferences/snooze":
            {
                const o = t.data.payload.status;
                cx(o),
                window.elementor.getPanelView().getPages("editorPreferences_settings").options.model.set(Su, o);
                const n = await Du({
                    status: o,
                    prevStatus: t.data.payload.prevStatus,
                    requestId: t.data.payload.requestId
                });
                n.status === "success" && ((e = n.result) != null && e.maybeTurnOff) ? await _u(o) : window.elementor.notifications.showToast({
                    sticky: !0,
                    message: o === "snoozed_7d" ? "Copilot will take the week off. You can change this setting in your User Preferences." : "Copilot will take the day off. You can change this setting in your User Preferences.",
                    buttons: [{
                        name: "take-me-there",
                        text: "Take me there",
                        callback: () => {
                            window.$e.route("panel/editor-preferences")
                        }
                    }]
                }),
                t.ports[0].postMessage({
                    status: "success"
                });
                break
            }
        case "copilot/user-preferences/enable":
            {
                window.elementor.getPanelView().getPages("editorPreferences_settings").options.model.set(Su, "on"),
                await Ou({
                    prevStatus: (r = t.data.payload) == null ? void 0 : r.prevStatus
                }),
                t.ports[0].postMessage({
                    status: "success"
                });
                break
            }
        }
    }
    );
    const dx = .2126
      , ux = .7152
      , mx = .0722
      , px = 2.4
      , hx = 4.5;
    function Tu(t) {
        t.length === 4 && (t = gx(t));
        const r = t.replace(/#|0x/g, "")
          , o = parseInt(r.slice(6, 8), 16) / 255;
        return {
            r: parseInt(r.slice(0, 2), 16),
            g: parseInt(r.slice(2, 4), 16),
            b: parseInt(r.slice(4, 6), 16),
            opacity: o
        }
    }
    function gx(t) {
        return t.split("").map(e => e + e).join("")
    }
    const Pu = (t, e) => {
        const r = t.opacity
          , o = 1 - r;
        return {
            r: Math.round(t.r * r + e.r * o),
            g: Math.round(t.g * r + e.g * o),
            b: Math.round(t.b * r + e.b * o)
        }
    }
      , ku = t => {
        const [e,r,o,n] = t.replace(/rgba?\(|\)/g, "").split(",").map( (s, i) => i === 3 ? parseFloat(s) : parseInt(s, 10));
        return {
            r: e,
            g: r,
            b: o,
            opacity: isNaN(n) ? 1 : n
        }
    }
      , hi = (t, e) => {
        let r = t.startsWith("#") ? Tu(t) : ku(t)
          , o = e.startsWith("#") ? Tu(e) : ku(e);
        r.opacity < 1 && (r = Pu(r, o)),
        o.opacity < 1 && (o = Pu(o, r));
        const n = l => {
            const d = [l.r, l.g, l.b].map(u => (u /= 255,
            u <= .03928 ? u / 12.92 : Math.pow((u + .055) / 1.055, px)));
            return d[0] * dx + d[1] * ux + d[2] * mx
        }
          , s = n(r)
          , i = n(o);
        return Math.round((Math.max(s, i) + .05) / (Math.min(s, i) + .05))
    }
    ;
    let gi = {};
    const fx = async () => {
        gi = (await window.$e.data.get("globals/colors")).data
    }
      , yx = (t, e) => {
        const r = e.map(o => ({
            ...o,
            contrast: hi(t, o.value)
        })).sort( (o, n) => n.contrast - o.contrast);
        return r[0].contrast >= hx ? r[0].id : ""
    }
      , vx = (t, e) => {
        const r = yx(t, e);
        if (r)
            return {
                type: "global",
                color: r
            };
        const o = hi("#FFFFFF", t)
          , n = hi("#000000", t);
        return {
            type: "fallback",
            color: o > n ? "#FFFFFF" : "#000000"
        }
    }
      , wx = () => {
        const t = window.elementor.documents.getCurrent();
        return {
            title: t.config.settings.settings.post_title,
            url: window.location.href,
            type: t.config.type,
            depth: 1
        }
    }
      , bx = (t, e, r) => {
        t.model.get("settings").set(e, r),
        t.render()
    }
      , Iu = (t, e) => window.$e.components.get("document").utils.findViewRecursive(t, "id", e, !1)[0] || null
      , Sx = t => {
        let e, r;
        if (t.includes(":"))
            [e,r] = t.split(":");
        else {
            const [o,...n] = t.split("_");
            e = o,
            r = n.join("_")
        }
        return {
            id: e,
            setting: r
        }
    }
      , Ex = (t, e) => {
        const r = {};
        for (const {textId: o, newText: n} of e) {
            if (!o || !n)
                continue;
            const {id: s, setting: i} = Sx(o);
            if (i.includes(".")) {
                const [d,u,g] = i.split(".");
                r[s] = r[s] || {},
                r[s][d] = r[s][d] || [],
                r[s][d][parseInt(u)] = {
                    settingKey: g,
                    newText: n
                };
                continue
            }
            const l = Iu(t, s);
            l && bx(l, i, n)
        }
        for (const [o,n] of Object.entries(r)) {
            const s = Iu(t, o);
            if (s) {
                for (const [i,l] of Object.entries(n)) {
                    const u = s.model.get("settings").get(i);
                    if (u)
                        for (const [g,{settingKey: c, newText: m}] of Object.entries(l)) {
                            const p = u.at(parseInt(g));
                            p && p.set(c, m)
                        }
                }
                s.container.render()
            }
        }
    }
      , Cu = (t, e) => t.map(r => {
        var o, n;
        return (n = (o = r.get("settings")) == null ? void 0 : o.get("ai")) == null ? void 0 : n[e]
    }
    ).filter(r => r).map(r => parseInt(r))
      , xx = async t => {
        const e = $u(t);
        for (const r of e)
            await window.$e.run("document/elements/create", {
                container: window.elementor.getPreviewContainer(),
                model: r,
                options: {
                    edit: !0,
                    scrollIntoView: e.indexOf(r) === 0
                }
            })
    }
      , _x = async t => ({
        size: {
            width: t.width
        },
        prevBlockIds: Cu(window.elementor.elements, "blockId"),
        prevBaseTemplateIds: Cu(window.elementor.elements, "baseTemplateId"),
        context: {
            editorSessionId: t.editorSessionId,
            prevLayout: t.currentHTML,
            website: await Pd(),
            page: wx(),
            supportedFeatures: window.elementorCommon.config.experimentalFeatures
        }
    })
      , $u = t => {
        const e = window.elementor.createBackboneElementsCollection(t)
          , r = window.elementor.createBackboneElementsModel(e)
          , o = async n => {
            const s = n.get("settings");
            if (s) {
                Object.values(s.controls).filter(m => m.type === "color").forEach(m => {
                    s.set(m.name, m.default)
                }
                ),
                Object.values(s.controls).filter(m => m.type === "choose" && m.name.endsWith("background")).forEach(m => {
                    s.set(m.name, m.default)
                }
                );
                const u = Object.values(s.controls).filter(m => m.name.endsWith("font_size"))
                  , g = u.map(m => s.get(m.name));
                if (Object.values(s.controls).filter(m => m.groupType === "typography").forEach(m => {
                    s.set(m.name, m.default)
                }
                ),
                u.forEach( (m, p) => {
                    s.set(m.name, g[p]),
                    s.set(m.name.replace("_font_size", "_typography"), "custom")
                }
                ),
                s.attributes.hasOwnProperty("button_text_color")) {
                    const m = vx(gi.accent.value, Object.values(gi));
                    if (m.type === "global") {
                        const p = s.get("__globals__") || {};
                        p.button_text_color = `globals/colors?id=${m.color}`,
                        s.set("__globals__", p)
                    } else
                        s.set("button_text_color", m.color)
                }
            }
            const i = n.get("elements");
            i && i.forEach(l => {
                o(l)
            }
            )
        }
        ;
        return o(r),
        r.get("elements").toJSON()
    }
      , Tx = (t, e, r) => {
        const o = window.elementor.$previewContents[0]
          , n = (r == null ? void 0 : r.previewAreaId) || "elementor-copilot-preview"
          , s = o.querySelector(`#${n}-wrapper`) || o.createElement("div")
          , i = s.querySelector(`#${n}`) || o.createElement("div");
        i.id = n,
        i.classList.add("elementor-editor-preview"),
        e.jsonWithTexts || (i.style.opacity = "0.32",
        s.classList.add("elementor-copilot-preview-loading")),
        s.id = `${n}-wrapper`,
        s.style.border = "2px dashed #eee",
        s.appendChild(i),
        o.body.appendChild(s),
        r != null && r.adjustPosition ? r.adjustPosition(s) : t == null || t.insertAdjacentElement("afterend", s);
        const l = o.createElement("style");
        if (l.innerHTML = `
		#elementor-copilot-preview {
			pointer-events: none;
		}

		#elementor-copilot-preview .elementor-inline-editing {
			transition: color 0.5s;
		}

		.elementor-copilot-preview-loading .elementor-inline-editing {
			color: transparent !important;
			position: relative;
		}
	`,
        l.innerHTML += `
	#editor-static-iframe#editor-static-iframe {
		pointer-events: all !important;
		position: absolute;
	}`,
        !window.elementor.createBackboneElementsCollection)
            return s.style.marginTop = "30px",
            i.style.opacity = "0.8",
            i.innerHTML = "Can't render the preview, Please update your Elementor to the latest version (>=3.20-beta2).",
            {
                previewAreaWrapper: s,
                elementsModel: null,
                previewView: null
            };
        window.elementor.$previewContents[0].head.appendChild(l);
        const d = e.jsonWithTexts || e.json
          , u = $u(d)
          , g = window.elementor.createBackboneElementsCollection(u)
          , c = window.elementor.createBackboneElementsModel(g)
          , m = window.elementor.createPreviewView(i, c, {
            allowEdit: !1
        });
        return window.elementor.renderPreview(m),
        parseInt(getComputedStyle(i).height) < 200 && (s.style.marginTop = "0"),
        {
            previewAreaWrapper: s,
            elementsModel: c,
            previewView: m
        }
    }
      , fi = []
      , Px = (t, e) => {
        const r = `command: ${t}`;
        sx.includes(t) && (pi(e, r),
        Au())
    }
      , kx = (t, e) => {
        const r = `route: ${t}`;
        ax.includes(t) && (pi(e, r),
        Au())
    }
      , Ix = t => {
        const e = (o, n) => {
            Px(n, t)
        }
          , r = (o, n) => {
            kx(n, t)
        }
        ;
        window.$e.commands.on("run:after", e),
        window.$e.routes.on("run:after", r),
        fi.push( () => {
            window.$e.commands.off("run:after", e),
            window.$e.routes.off("run:after", r)
        }
        )
    }
      , Au = () => {
        fi.forEach(t => t()),
        fi.length = 0
    }
      , Cx = async (t, e, r) => {
        if (!t.iframe)
            return null;
        const {iframe: o} = await fs({
            path: `upgrade-notice?reason=${e}&title=${r}`,
            css: {
                position: "fixed",
                height: "220px",
                width: "300px",
                top: t.iframe.getBoundingClientRect().bottom + "px",
                left: t.iframe.getBoundingClientRect().left + t.iframe.getBoundingClientRect().width / 2 - 150 + "px",
                "border-radius": "5px",
                "z-index": 999999999
            }
        });
        return t.noticeIframe = o,
        o
    }
      , ge = {
        started: !1,
        iframe: null,
        isOpen: !1,
        isHidden: !1,
        channel: null,
        iframeUrlObject: null,
        elementsModel: null,
        previewView: null,
        previewAreaWrapper: null,
        editorSessionId: window.EDITOR_SESSION_ID || "CNL-editor-session-" + Math.random().toString(16).substr(2, 7)
    }
      , Ru = async () => {
        const t = await vi();
        return ge.isOpen = !0,
        t
    }
      , $x = () => ge.iframe
      , Ou = async t => {
        console.log("copilot enabled");
        const e = await Ru();
        await xu(e, {
            status: bu.ON,
            prevStatus: t.prevStatus
        })
    }
      , Du = async t => {
        var o, n, s;
        console.log("copilot disabled"),
        ix();
        const e = await vi()
          , r = await xu(e, t);
        return e.remove(),
        (o = ge.iframe) == null || o.remove(),
        ge.iframe = null,
        ge.isOpen = !1,
        ge.elementsModel = null,
        (n = ge.previewView) == null || n.destroy(),
        (s = ge.previewAreaWrapper) == null || s.remove(),
        r
    }
      , Nu = async t => {
        var e, r, o;
        switch (t.data.type) {
        case "copilot/next-layout/replace-text":
            Ex(ge.previewView.children, t.data.payload.json),
            (e = ge.previewAreaWrapper) == null || e.classList.remove("elementor-copilot-preview-loading"),
            Lt(t.ports[0]);
            break;
        case "copilot/next-layout/show-default-text":
            (r = ge.previewAreaWrapper) == null || r.classList.remove("elementor-copilot-preview-loading"),
            Lt(t.ports[0]);
            break;
        case "copilot/next-layout/get-layout-context":
            Ix(ge.iframe);
            const s = window.elementor.$previewContents[0].querySelector(".elementor-edit-area-active")
              , i = s == null ? void 0 : s.cloneNode(!0);
            i.querySelectorAll(".elementor-editor-element-settings, #elementor-add-new-section, .elementor-add-section-inner").forEach(g => g.remove());
            const l = await _x({
                width: s.clientWidth,
                currentHTML: i.innerHTML,
                editorSessionId: ge.editorSessionId
            });
            window.location.search.includes("copilot-block-id") && (l.debugId = new URLSearchParams(window.location.search).get("copilot-block-id")),
            fx(),
            Lt(t.ports[0], l);
            break;
        case "copilot/next-layout/set-preview":
            const d = Tx(ge.iframe, t.data.payload);
            ge.previewView = d.previewView,
            ge.previewAreaWrapper = d.previewAreaWrapper,
            ge.elementsModel = d.elementsModel,
            Lt(t.ports[0]);
            break;
        case "copilot/next-layout/reset-preview":
            await yi(),
            Lt(t.ports[0]);
            break;
        case "copilot/next-layout/insert":
            await xx(t.data.payload.json),
            Lt(t.ports[0]);
            break;
        case "copilot/next-layout/upgrade-notice":
            Cx(ge, t.data.payload.reason, t.data.payload.title),
            Lt(t.ports[0]);
            break;
        case "copilot/turn-off-notice/show":
            _u(t.data.payload.reason),
            Lt(t.ports[0]);
            break;
        case "copilot/next-layout/status":
            if (!ge.iframe) {
                Lt(t.ports[0]);
                return
            }
            const u = t.data.payload.status === "idle";
            (o = ge.iframe) == null || o.classList.toggle("elementor-copilot--idle", u),
            u ? mw(ge.iframe) : uw(ge.iframe),
            Lt(t.ports[0]);
            break
        }
    }
      , yi = async () => {
        var t;
        (t = ge.previewAreaWrapper) == null || t.remove()
    }
      , vi = async () => {
        if (ge.iframe && ge.iframe.isConnected)
            return ge.iframe;
        const t = window.elementor.$previewContents[0]
          , e = t.querySelector("#elementor-add-new-section")
          , r = "copilot/next-layout-button"
          , {iframe: o, iframeUrlObject: n} = await fs({
            path: r,
            parent: t,
            insertCallback: s => {
                var i;
                (i = e == null ? void 0 : e.parentElement) == null || i.insertBefore(s, e)
            }
            ,
            css: {
                height: "80px",
                "z-index": 999999999
            }
        });
        return o.classList.add("elementor-copilot--idle"),
        ge.isOpen = !0,
        ge.iframe = o,
        ge.isHidden = !1,
        ge.iframeUrlObject = n,
        window.elementorFrontend.elements.$window[0].addEventListener("beforeunload", () => {
            ge.iframe && (ge.iframe = null)
        }
        ),
        window == null || window.addEventListener("message", async s => {
            if (s.origin === n.origin)
                try {
                    await Nu(s)
                } catch (i) {
                    Td(s.ports[0], i)
                }
        }
        ),
        ge.iframe
    }
      , Es = Object.freeze(Object.defineProperty({
        __proto__: null,
        appIframeState: ge,
        disableCopilot: Du,
        enableCopilot: Ou,
        getCopilotIframe: $x,
        handleCopilotNextLayoutMessage: Nu,
        openCopilotApp: vi,
        resetPreview: yi,
        startCopilot: Ru
    }, Symbol.toStringTag, {
        value: "Module"
    }))
});
